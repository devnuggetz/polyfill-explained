export const DATA = [
  {
    code: "\n\nclass AbortController {\n  constructor() {\n    this.signal = new AbortSignal();\n  }\n \n  abort() {\n    this.signal.abort();\n  }\n}\nclass AbortSignal {\n  constructor(){\n    this.aborted = false;\n    this.onabort = null;\n  }\n \n  get aborted(){\n    return this.aborted;\n  }\n \n  set onabort(handler){\n    if (this.onabort) {\n      throw new DOMException('AbortSignal is already sending a signal', 'InvalidStateError');\n    }\n    this.onabort = handler;\n  }\n \n  toString(){\n    return '[object AbortSignal]';\n  }\n \n  abort(){\n    if (this.onabort) {\n      this.onabort();\n    }\n    this.aborted = true;\n  }\n}",
    term: "AbortController",
    explain:
      "\n\n// 1. class AbortController { - This line creates the AbortController class, which is used to handle the aborting of a network request. \n// 2. constructor() { - This line is the constructor method for this class, which is used to initialize an instance of AbortController.\n// 3. this.signal = new AbortSignal(); - This line creates a new instance of the AbortSignal class and assigns it to the signal property of the AbortController instance.\n// 4. abort() { - This line creates a method on the AbortController class that allows for aborting the network request.\n// 5. class AbortSignal { - This line creates the AbortSignal class, which is used to handle the aborting of a network request.\n// 6. constructor(){ - This line is the constructor method for this class, which is used to initialize an instance of AbortSignal.\n// 7. this.aborted = false; - This line sets the aborted property of the AbortSignal instance to false.\n// 8. this.onabort = null; - This line sets the onabort property of the AbortSignal instance to null.\n// 9. get aborted(){ - This line creates a method on the AbortSignal class that allows for getting the aborted state of the instance.\n// 10. set onabort(handler){ - This line creates a method on the AbortSignal class that allows for setting the onabort handler.\n// 11. toString(){ - This line creates a method on the AbortSignal class that allows for getting the string representation of the instance.\n// 12. abort(){ - This line creates a method on the AbortSignal class that allows for aborting the network request.",
    useCase:
      "\n\nAbortController is used in JavaScript to allow for the cancellation of a request. This is useful for requests that take a long time to complete, such as lengthy API calls. The AbortController provides developers with a way to cancel the request before it completes, freeing up resources and preventing potential errors. Additionally, AbortController can be used to abort any fetch request, even if the API endpoint does not natively support aborting requests.",
  },
  {
    code: "\n\nclass AggregateError extends Error { \n\n  constructor(errors) {\n    if (Array.isArray(errors)) {\n      const message = errors.length > 1 ?\n        `${errors.length} errors occurred` :\n        `An error occurred`;\n      super(message);\n      this.name = 'AggregateError';\n      this.errors = errors;\n    } else {\n      throw new TypeError(`Argument 1 of AggregateError must be an Array`);\n    }\n  }\n}",
    term: "AggregateError",
    explain:
      '\n\n// Line 1: This line creates a class called AggregateError that extends the Error class. This allows us to create objects which inherit the properties and methods of the Error class. \n// Line 2: This line creates a constructor function for the AggregateError class which takes in an array of errors as an argument. \n// Line 3: This line checks if the argument passed into the constructor is an array. \n// Line 4: This line creates a message which will be displayed when the AggregateError object is created. The message will either say "An error occurred" if there is one error, or "X errors occurred" if there are multiple errors.\n// Line 5: This line calls the super() method and passes the created message as an argument. This will set the message property of the AggregateError object to the created message. \n// Line 6: This line sets the name property of the AggregateError object to "AggregateError".\n// Line 7: This line sets the errors property of the AggregateError object to the array of errors passed into the constructor. \n// Line 8: This line throws an error if the argument passed into the constructor is not an array.',
    useCase:
      "\n\nAggregateError is used in JavaScript to provide a single unified type for a variety of errors that may occur in a program. This allows developers to have a consistent way of dealing with errors, regardless of the type of error that occurs. It also allows for a more organized approach to error handling, as developers can catch a single error type and act accordingly, rather than having to consider each type of error separately.",
  },
  {
    code: "\n\nif (!Array.from) {\n  Array.from = function(object) {\n    return [].slice.call(object);\n  };\n}",
    term: "Array.from",
    explain:
      "\n\n// This code checks if the Array.from method is not defined, meaning that the current environment does not support it.\n// If Array.from is not defined, then this code defines it as a function that takes in one parameter, 'object'.\n// The Array.from function will then call the slice method on the array prototype and pass in the 'object' parameter as an argument. \n// This will return a new array with the elements from the passed in 'object' parameter.",
    useCase:
      "\n\nArray.from is used in JavaScript to create a new, shallow-copied Array instance from an array-like or iterable object. It allows you to convert array-like objects, such as arguments objects, NodeList, and other array-like objects into true JavaScript arrays. This is useful when you want to use array methods, such as map, reduce, filter, etc., on an array-like object.",
  },
  {
    code: '\n\nconst ArrayisArray = (arg) => {\n  if (Object.prototype.toString.call(arg) === "[object Array]") {\n    return true;\n  } else {\n    return false;\n  }\n};',
    term: "Array.isArray",
    explain:
      "\n\n// Line 1: This line is declaring a constant variable named 'ArrayisArray' and assigning it with an anonymous function. This function takes one argument named 'arg'. \n// Line 2: This line is using the 'Object.prototype.toString.call' method to convert the 'arg' argument to a string and comparing it to the string value '[object Array]'. \n// Line 3: This line is returning the boolean value 'true' if the comparison in line 2 is true.\n// Line 4: This line is returning the boolean value 'false' if the comparison in line 2 is false.",
    useCase:
      "\n\nArray.isArray is used in JavaScript to determine whether a given value is an array or not. This is useful for checking the data type of a variable before performing operations on it. It is a reliable way to ensure that the data type of a variable is an array and that operations such as iteration and mapping can be performed on it.",
  },
  {
    code: "\n\nif (!Array.of) {\n  Array.of = function() {\n    return Array.prototype.slice.call(arguments);\n  };\n}",
    term: "Array.of",
    explain:
      "\n\n/*\nLine 1: If the Array.of method does not exist,\nReason: This checks to see if the Array.of method already exists, and if not, it will proceed to create it.\n\nLine 2: Array.of = function() {\nReason: This creates the function that will be assigned to the Array.of method.\n\nLine 3: return Array.prototype.slice.call(arguments);\nReason: This returns the arguments passed into the function as an array using the Array.prototype.slice.call method. This allows the Array.of method to take any number of arguments and returns them as an array.",
    useCase:
      "\n\nArray.of is used in JavaScript to create a new Array instance from a variable number of arguments. It allows developers to create an Array instance with a single argument, or with multiple arguments. It also provides an easy way to create an array from a non-array type, such as a string or number.",
  },
  {
    code: "\n\nif (!Array.prototype.hasOwnProperty('@@iterator')) {\n    Object.defineProperty(Array.prototype, '@@iterator', {\n        value: function() {\n            let index = 0;\n\n            return {\n                next: () => {\n                    if (index < this.length) {\n                        return {\n                            value: this[index++],\n                            done: false\n                        };\n                    } else {\n                        return {\n                            value: undefined,\n                            done: true\n                        };\n                    }\n                }\n            }\n        }\n    });\n}",
    term: "Array.prototype.@@iterator",
    explain:
      '\n\n//Line 1:\n//This line checks if the Array prototype does not have a property named "@@iterator".\n\n//Line 2:\n//If the condition is true, then this line uses Object.defineProperty() to define a new property with the specified name and value on the Array prototype.\n\n//Line 3:\n//This line creates a variable called "index" and sets its value to 0.\n\n//Line 4-11:\n//This block defines an iterator which returns the next item in the array when called. It returns an object with two properties: "value" which is the value of the next item in the array and "done" which is a boolean value which is true if the end of the array has been reached. \n\n//Line 12:\n//This line closes the if block from line 2.',
    useCase:
      "\n\nArray.prototype.@@iterator is used in Javascript to create an iterable object for the array. This allows developers to use the iterator protocol to easily loop through the array and access each element in the array. The iterator protocol is a standard way of providing a way to iterate through a collection of data, such as an array. This makes it simple to loop through the array and access each element without having to write custom code.",
  },
  {
    code: "\n\nif (!Array.prototype.at) {\n  Array.prototype.at = function (index) {\n    const length = this.length;\n    if (index >= length || index < 0) {\n      return undefined;\n    }\n\n    return this[index];\n  };\n}",
    term: "Array.prototype.at",
    explain:
      "\n\n// Line 1: This line checks if the array prototype at() method exists. If not, it will proceed to the next line.\n// Line 2: This line adds a at() method to the array prototype, taking an index parameter. \n// Line 3: This line saves the length of the array in a variable.\n// Line 4: This line checks if the index provided is greater than or equal to the length of the array or less than 0. If so, it will return undefined. \n// Line 5: This line returns the value of the array at the specified index.",
    useCase:
      "\n\nArray.prototype.at is used in Javascript to quickly retrieve a specific element from an array without having to iterate through the entire array. This method is especially useful when the index of the element is known, as it is much faster than looping through the array.",
  },
  {
    code: "\n\nif (!Array.prototype.copyWithin) {\n  Array.prototype.copyWithin = function(target, start, end = this.length) {\n    if (start < 0) {\n      start = this.length + start;\n    }\n    if (end < 0) {\n      end = this.length + end;\n    }\n    let last = this.length - 1;\n    for (let i = end - 1; i >= start; i--) {\n      let from = i;\n      let to = target + i - start;\n      if (to > last) {\n        to = last;\n      }\n      if (from in this) {\n        this[to] = this[from];\n      } else {\n        delete this[to];\n      }\n    }\n    return this;\n  };\n}",
    term: "Array.prototype.copyWithin",
    explain:
      "\n\n// Line 1: \n// This is a conditional statement that checks if the Array.prototype.copyWithin method is available.\n\n// Line 2: \n// This line initializes the Array.prototype.copyWithin method and passes in 3 arguments: the target index, the start index, and the end index.\n\n// Line 3: \n// This line checks if the start index is less than 0. If so, it sets the start index to the length of the array plus the start index.\n\n// Line 4: \n// This line checks if the end index is less than 0. If so, it sets the end index to the length of the array plus the end index.\n\n// Line 5: \n// This line sets the last index of the array to the length of the array minus 1.\n\n// Line 6: \n// This line creates a for loop that iterates backwards through the array starting at the end index minus 1 and ending at the start index.\n\n// Line 7: \n// This line sets the from index equal to the current iteration index of the loop.\n\n// Line 8: \n// This line sets the to index equal to the target index plus the iteration index minus the start index.\n\n// Line 9: \n// This line checks if the to index is greater than the last index of the array. If so, it sets the to index to the last index of the array.\n\n// Line 10: \n// This line checks if the from index exists in the array. If so, it sets the to index of the array equal to the from index of the array.\n\n// Line 11: \n// This line executes if the from index does not exist in the array. In this case, it deletes the to index of the array.\n\n// Line 12: \n// This line returns the modified array.",
    useCase:
      "\n\nArray.prototype.copyWithin is used in Javascript to copy a sequence of array elements within the same array. This method allows for elements to be copied from one part of the array to another part of the same array, without changing the length of the array. This method is useful for creating new arrays from existing ones in an efficient manner. It can also be used to move elements in an array around, making it easier to rearrange and manipulate data.",
  },
  {
    code: "\n\nif (!Array.prototype.entries) {\n  Array.prototype.entries = function() {\n    let index = 0;\n    let arr = this;\n    const length = arr.length;\n    return {\n      next() {\n        if (index < length) {\n          return {\n            value: [index, arr[index++]],\n            done: false\n          };\n        } else {\n          return {\n            done: true\n          };\n        }\n      }\n    };\n  };\n}",
    term: "Array.prototype.entries",
    explain:
      "\n\n// line 1: \n// This line checks if the entries method has not been added to the Array prototype.\n\n// line 2: \n// This line adds an entries method to the Array prototype.\n\n// line 3: \n// This line declares a local variable named index and sets it to 0.\n\n// line 4: \n// This line declares a local variable named arr and sets it to the array object that the entries method is being called on.\n\n// line 5: \n// This line declares a constant variable named length and sets it to the length of the array object.\n\n// line 6: \n// This line returns an object with a next method.\n\n// lines 7-14: \n// This code defines the next method. It checks if the index is less than the length of the array. If it is, it returns an object with a value property containing an array with the index and the element at that index, and a done property set to false. If the index is not less than the length, it returns an object with the done property set to true.",
    useCase:
      "\n\nArray.prototype.entries is used to return a new Array Iterator object that contains the key/value pairs for each index in the array. This can be useful when looping through an array and needing to access both the index and value of each element. This can also be used in conjunction with other methods like find() or filter() to quickly iterate through an array and perform specific operations on each element.",
  },
  {
    code: "\n\nif (!Array.prototype.every) {\n  Array.prototype.every = function(callbackfn, thisArg) {\n    let T, k;\n    if (this == null) {\n      throw new TypeError('this is null or not defined');\n    }\n    let O = Object(this);\n    let len = O.length >>> 0;\n    if (typeof callbackfn !== 'function') {\n      throw new TypeError();\n    }\n    if (arguments.length > 1) {\n      T = thisArg;\n    }\n    k = 0;\n    while (k < len) {\n      let kValue;\n      if (k in O) {\n        kValue = O[k];\n        let testResult = callbackfn.call(T, kValue, k, O);\n        if (!testResult) {\n          return false;\n        }\n      }\n      k++;\n    }\n    return true;\n  };\n}",
    term: "Array.prototype.every",
    explain:
      "\n\n// if (!Array.prototype.every) { \n// This checks to see if the every method is already added to the Array prototype. If not, it will add it.\n\n// Array.prototype.every = function(callbackfn, thisArg) { \n// This is the function definition for the every method. It takes in two parameters, a callback function, and a this argument.\n\n// let T, k; \n// This declares and initializes two variables, T and k.\n\n// if (this == null) { \n// This checks if the this argument is null.\n\n// throw new TypeError('this is null or not defined');\n// If the this argument is null, a TypeError is thrown.\n\n// let O = Object(this); \n// This creates an object out of the this argument.\n\n// let len = O.length >>> 0; \n// This sets the variable len to the length of the object created from the this argument.\n\n// if (typeof callbackfn !== 'function') { \n// This checks if the callback function is a function.\n\n// throw new TypeError(); \n// If the callback function is not a function, a TypeError is thrown.\n\n// if (arguments.length > 1) { \n// This checks if there is more than one argument.\n\n// T = thisArg; \n// If there is more than one argument, the variable T is set to the thisArg parameter.\n\n// k = 0; \n// This sets the variable k to 0.\n\n// while (k < len) { \n// This sets up a while loop that runs until k is less than the length of the object O.\n\n// let kValue; \n// This declares the variable kValue.\n\n// if (k in O) { \n// This checks if the value of k is in the object O.\n\n// kValue = O[k]; \n// If the value of k is in the object O, kValue is set to the value of O at the index of k.\n\n// let testResult = callbackfn.call(T, kValue, k, O); \n// This calls the callback function with the parameters kValue, k, and O.\n\n// if (!testResult) { \n// This checks the result of the callback function.\n\n// return false; \n// If the result of the callback function is false, false is returned.\n\n// k++; \n// This increments the value of k.\n\n// return true; \n// This returns true if the callback function returns true for every value in the object.",
    useCase:
      "\n\nArray.prototype.every is used in Javascript to test whether all elements in an array pass a certain test. It can be used to check if all elements in an array satisfy a certain condition, such as being less than a certain number or being of a certain type. It is a useful tool for testing the contents of an array and ensuring that they meet certain criteria.",
  },
  {
    code: "\n\nif (!Array.prototype.fill) {\n  Object.defineProperty(Array.prototype, 'fill', {\n    value: function(value) {\n      if (this == null) {\n        throw new TypeError('this is null or not defined');\n      }\n      let O = Object(this);\n      let len = O.length >>> 0;\n      let start = arguments[1];\n      let relativeStart = start >> 0;\n      let k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);\n      let end = arguments[2];\n      let relativeEnd = end === undefined ? len : end >> 0;\n      let final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);\n      while (k < final) {\n        O[k] = value;\n        k++;\n      }\n      return O;\n    }\n  });\n}",
    term: "Array.prototype.fill",
    explain:
      "\n\n// Line 1: This is an if statement, checking to see if the fill method has been defined for the Array prototype. If not, Object.defineProperty is used to define the method. \n// Line 2: This sets the value of the Array.prototype.fill method to a function which is defined below. \n// Line 3: This checks to make sure that the array is not null or undefined. If it is, a TypeError is thrown. \n// Line 4: This creates a new object from the array. \n// Line 5: This sets the length of the array to a number with no decimal places (>>> operator). \n// Line 6: This sets the start argument to the second argument of the function. \n// Line 7: This sets the relativeStart argument (start argument shifted by 0 bits) to the start argument. \n// Line 8: This sets the k argument to the larger of the two numbers (relativeStart and 0) or the smaller of the two numbers (relativeStart and the length of the array). \n// Line 9: This sets the end argument to the third argument of the function. \n// Line 10: This sets the relativeEnd argument (end argument shifted by 0 bits) to the end argument, or if it is undefined, the length of the array. \n// Line 11: This sets the final argument to the larger of the two numbers (relativeEnd and 0) or the smaller of the two numbers (relativeEnd and length of the array). \n// Line 12-14: This is a while loop, which loops through the array from start to end, setting each element to the value argument. \n// Line 15: This returns the array with the elements set to the value argument.",
    useCase:
      "\n\nArray.prototype.fill is used in Javascript to fill all the elements of an array with a static value, from a start index to an end index. This is useful for quickly populating an array with a set value, or for quickly resetting an array to a given value. It is also a useful tool for creating new arrays based on existing arrays with modified values.",
  },
  {
    code: "\n\nif (!Array.prototype.filter) {\n  Array.prototype.filter = function(callback, thisArg) {\n    let arr = [];\n    if (this == null) throw new TypeError('this is null or not defined');\n    let o = Object(this);\n    let len = o.length >>> 0;\n    if (typeof callback !== 'function') throw new TypeError(callback + ' is not a function');\n    for (let i = 0; i < len; i++) {\n      if (i in o) {\n        let val = o[i];\n        if (callback.call(thisArg, val, i, o)) {\n          arr.push(val);\n        }\n      }\n    }\n    return arr;\n  };\n}",
    term: "Array.prototype.filter",
    explain:
      "\n\n//1. This line checks if the filter function already exists in the Array prototype. \nif (!Array.prototype.filter) {\n\n//2. If it doesn't, then the following function is added to the Array prototype.\n  Array.prototype.filter = function(callback, thisArg) {\n\n//3. A new array is initialized to store the results.\n    let arr = [];\n\n//4. This line checks if the array being used is null or undefined.\n    if (this == null) throw new TypeError('this is null or not defined');\n\n//5. This line converts the array to an object for use.\n    let o = Object(this);\n\n//6. This line stores the length of the array as a 32-bit unsigned integer.\n    let len = o.length >>> 0;\n\n//7. This line checks to make sure the callback being used is actually a function.\n    if (typeof callback !== 'function') throw new TypeError(callback + ' is not a function');\n\n//8. This loop iterates over the array and runs the callback function on each item. \n    for (let i = 0; i < len; i++) {\n\n//9. This line checks if the item is part of the array.\n      if (i in o) {\n\n//10. This line stores the current item in the array.\n        let val = o[i];\n\n//11. This line calls the callback on the current item in the array and checks if it returns true. \n        if (callback.call(thisArg, val, i, o)) {\n\n//12. If it does, then the item is added to the new array. \n          arr.push(val);\n        }\n      }\n    }\n\n//13. This line returns the new array with the filtered items. \n    return arr;\n  };\n}",
    useCase:
      "\n\nArray.prototype.filter is used to create a new array with all elements that pass the test implemented by the provided function. It is a useful tool for filtering out elements from an array that don't meet certain criteria. It is a great way to reduce the amount of data that needs to be processed.",
  },
  {
    code: "\n\nif (!Array.prototype.find) {\n  Object.defineProperty(Array.prototype, 'find', {\n    value: function(predicate) {\n      if (this == null) {\n        throw new TypeError('\"this\" is null or not defined');\n      }\n      var o = Object(this);\n      var len = o.length >>> 0;\n      if (typeof predicate !== 'function') {\n        throw new TypeError('predicate must be a function');\n      }\n      var thisArg = arguments[1];\n      var k = 0;\n      while (k < len) {\n        var kValue = o[k];\n        if (predicate.call(thisArg, kValue, k, o)) {\n          return kValue;\n        }\n        k++;\n      }\n      return undefined;\n    }\n  });\n}",
    term: "Array.prototype.find",
    explain:
      '\n\n1. if (!Array.prototype.find) { // checks if the Array.prototype object has a property called find\n\n2. Object.defineProperty(Array.prototype, \'find\', { // adds a new property to the Array.prototype object\n\n3. value: function(predicate) { // assigns the value of the new property to a function\n\n4. if (this == null) { // checks if the value of "this" is null or not defined\n\n5. throw new TypeError(\'"this" is null or not defined\'); // throws an error if the value of "this" is null or not defined\n\n6. var o = Object(this); // assigns the value of "this" to a variable\n\n7. var len = o.length >>> 0; // assigns the length of the variable "o" to a variable\n\n8. if (typeof predicate !== \'function\') { // checks that the type of the variable "predicate" is a function\n\n9. throw new TypeError(\'predicate must be a function\'); // throws an error if the type of the variable "predicate" is not a function\n\n10. var thisArg = arguments[1]; // assigns the second argument to a variable\n\n11. var k = 0; // sets a counter variable to 0\n\n12. while (k < len) { // loops while the counter variable is less than the length of the variable "o"\n\n13. var kValue = o[k]; // assigns the value of the kth item in the variable "o" to a variable\n\n14. if (predicate.call(thisArg, kValue, k, o)) { // checks if the function "predicate" returns true when passed the variables "thisArg", "kValue", and "o"\n\n15. return kValue; // returns the value of the variable "kValue" if the function "predicate" returns true\n\n16. k++; // increments the counter variable\n\n17. } // ends the loop\n\n18. return undefined; // returns undefined if the function "predicate" does not return true\n\n19. } // ends the value of the new property\n\n20. }); // ends the Object.defineProperty method\n\n21. } // ends the if statement',
    useCase:
      "\n\nArray.prototype.find is used in Javascript to find the first element in an array that satisfies a given condition. It is a useful way to quickly search through an array and return a value that matches the condition. It is much simpler and faster than using a for loop to loop through the array and manually check each element.",
  },
  {
    code: "\n\nif (!Array.prototype.findIndex) {\n  Array.prototype.findIndex = function(predicate) {\n    if (this === null) {\n      throw new TypeError('Array.prototype.findIndex called on null or undefined');\n    }\n    if (typeof predicate !== 'function') {\n      throw new TypeError('predicate must be a function');\n    }\n    var list = Object(this);\n    var length = list.length >>> 0;\n    var thisArg = arguments[1];\n    var value;\n\n    for (var i = 0; i < length; i++) {\n      value = list[i];\n      if (predicate.call(thisArg, value, i, list)) {\n        return i;\n      }\n    }\n    return -1;\n  };\n}",
    term: "Array.prototype.findIndex",
    explain:
      "\n\n// Line 1: \n// Checks to see if the Array.prototype.findIndex is already defined. \n\n// Line 2: \n// If the Array.prototype.findIndex is not already defined, define it using a function that takes a predicate as an argument. \n\n// Line 3: \n// If the this value passed in to the function is null or undefined, throw a TypeError. \n\n// Line 4: \n// If the predicate argument is not a function, throw a TypeError.\n\n// Line 5: \n// Declare a variable called list set to the object passed in to the function.\n\n// Line 6: \n// Declare a variable called length set to the length of the list variable.\n\n// Line 7:\n// Declare a variable called thisArg set to the argument at index 1.\n\n// Line 8: \n// Declare a variable called value.\n\n// Lines 9-14: \n// Iterate through the list variable, setting the value variable to the current element in the list. \n// If the predicate function returns true when called on the value, the index of the current element is returned. \n\n// Line 15: \n// If the predicate function never returns true, return -1.",
    useCase:
      "\n\nArray.prototype.findIndex is used to find the index of the first element in an array that satisfies the provided testing function. It returns the index of the found element, or -1 if no element is found. This method can be used to quickly search an array for a specific element and return its index, or to find the index of the first element that meets certain criteria.",
  },
  {
    code: "\n\nif (!Array.prototype.flat) {\n  Array.prototype.flat = function() {\n    let res = [];\n    for (let i = 0; i < this.length; i++) {\n      if (Array.isArray(this[i])) {\n        res = res.concat(this[i].flat());\n      } else {\n        res.push(this[i]);\n      }\n    }\n    return res;\n  };\n}",
    term: "Array.prototype.flat",
    explain:
      "\n\n//Line 1: \n//This line checks if the flat method is not present in the Array prototype.\n\n//Line 2: \n//This line adds a flat method to the Array prototype.\n\n//Line 3: \n//This line creates an empty array named 'res' to store the flattened array.\n\n//Line 4: \n//This line is a for loop that iterates over the array.\n\n//Line 5: \n//This line checks if the current element is an array and calls the flat method on it.\n\n//Line 6: \n//This line concats the flattened array with the res array.\n\n//Line 7: \n//This line pushes the element to the res array if it is not an array.\n\n//Line 8: \n//This line returns the flattened array.",
    useCase:
      "\n\nArray.prototype.flat is used to flatten an array of sub-arrays into a single, flat array. It is a useful method for reducing the number of nested levels in an array, allowing easier access to elements in the array. It is also useful for manipulating data, such as when combining multiple arrays into a single array.",
  },
  {
    code: "\n\nif (!Array.prototype.flatMap) {\n    Array.prototype.flatMap = function(callback) {\n        return this.reduce((acc, x) => {\n            return acc.concat(callback(x));\n        }, []);\n    };\n}",
    term: "Array.prototype.flatMap",
    explain:
      "\n\n// Line 1: This line checks if the Array.prototype does not have a flatmap method.\n// Line 2: This line is the beginning of the flatmap function definition. The function takes in a callback function as a parameter.\n// Line 3: This line uses the reduce() method to reduce the array to a single value. The callback function takes in two parameters, the accumulator and the current value, and returns a concatenated array.\n// Line 4: This line is the return statement, which returns the concatenated array.\n// Line 5: This line is the end of the function definition.",
    useCase:
      "\n\nArray.prototype.flatMap is used in Javascript to map each element using a mapping function, then flatten the resulting arrays into a single array. This is useful when you need to apply a mapping function to each element of an array, and then flatten all the resulting arrays into a single array. For example, it can be used to take an array of strings and map each string to an array of characters, and then flatten the resulting arrays of characters into a single array of characters.",
  },
  {
    code: "\n\nif (!Array.prototype.forEach) {\n  Array.prototype.forEach = function(callback/*, thisArg*/) {\n    let array = this;\n    let thisArg = arguments[1];\n    for (let i = 0; i < array.length; i++) {\n      callback.call(thisArg, array[i], i, array);\n    }\n  };\n}",
    term: "Array.prototype.forEach",
    explain:
      "\n\n// Line 1:\n// This line checks to see if the forEach method has already been added to the Array prototype. If it has not been added, the code inside the if statement will be run.\n\n// Line 2:\n// This line adds a forEach method to the Array prototype. It takes a callback function and a thisArg argument as parameters.\n\n// Line 3:\n// This line stores the array that the forEach method is called on in a variable called array.\n\n// Line 4:\n// This line stores the second argument of the forEach method in a variable called thisArg.\n\n// Line 5:\n// This line is a for loop that loops through each element in the array.\n\n// Line 6:\n// This line calls the callback function that was passed into the forEach method. It passes in the current element in the array, the index of the element, and the array itself as arguments. It also sets the context of the callback function to the thisArg argument.",
    useCase:
      "\n\nArray.prototype.forEach is used in Javascript to loop through each element in an array and execute a function for each element. It is a useful tool for iterating over each element of an array and performing some action on it, such as manipulating the element or adding it to a new array. It is more efficient than manually looping through each element of an array.",
  },
  {
    code: "\n\nif (!Array.prototype.includes) {\n  Array.prototype.includes = function(element, startIndex) {\n    if (startIndex === undefined) {\n      startIndex = 0\n    }\n    for (var i = startIndex; i < this.length; i++) {\n      if (this[i] === element) {\n        return true\n      }\n    }\n    return false\n  }\n}",
    term: "Array.prototype.includes",
    explain:
      "\n\n// Line 1: \n// This line checks whether the 'includes' method is already defined in the Array prototype. If not, then the following code is executed.\n\n// Line 2: \n// This line defines the 'includes' method in the Array prototype.\n\n// Line 3: \n// This line checks whether the startIndex argument is undefined. If so, it assigns it the value 0.\n\n// Line 4: \n// This line initializes a loop with the variable i as the iterator, starting at the value of startIndex and ending at the last element of the array.\n\n// Line 5: \n// This line checks if the element at the current index is equal to the element passed as an argument. If so, it returns true.\n\n// Line 6: \n// This line is executed when the loop ends, and it returns false if no element in the array was equal to the argument.",
    useCase:
      "\n\nArray.prototype.includes is used in Javascript to determine whether an array includes a certain element, returning true or false as appropriate. It is an efficient way to check if a specific element is present in an array, without needing to loop through the array and manually check each element.",
  },
  {
    code: "\n\nif (!Array.prototype.indexOf) {\n  Array.prototype.indexOf = function(searchElement, fromIndex) {\n    if (this == null) {\n      throw new TypeError('\"this\" is null or not defined');\n    }\n    var o = Object(this);\n    var len = o.length >>> 0;\n    if (len === 0) {\n      return -1;\n    }\n    var n = fromIndex | 0;\n    if (n >= len) {\n      return -1;\n    }\n    var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\n    while (k < len) {\n      if (k in o && o[k] === searchElement) {\n        return k;\n      }\n      k++;\n    }\n    return -1;\n  };\n}",
    term: "Array.prototype.indexOf",
    explain:
      "\n\n// if (!Array.prototype.indexOf) {\n// This line checks to see if the 'indexOf' method already exists on the Array object.\n\n// Array.prototype.indexOf = function(searchElement, fromIndex) {\n// This line adds the 'indexOf' method to the Array object if it doesn't already exist.\n\n// if (this == null) {\n// This line checks to see if the 'this' keyword is null or undefined.\n\n// var o = Object(this);\n// This line creates an object from the current array.\n\n// var len = o.length >>> 0;\n// This line gets the length of the object and converts it to an unsigned 32-bit integer.\n\n// if (len === 0) {\n// This line checks to see if the array is empty.\n\n// return -1;\n// This line returns -1 if the array is empty.\n\n// var n = fromIndex | 0;\n// This line creates an integer from the 'fromIndex' parameter.\n\n// if (n >= len) {\n// This line checks to see if the 'fromIndex' is greater than or equal to the array length.\n\n// return -1;\n// This line returns -1 if the 'fromIndex' is greater than or equal to the array length.\n\n// var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\n// This line creates a variable 'k' that is equal to the maximum value of either the 'fromIndex' or the array length - the absolute value of the 'fromIndex'.\n\n// while (k < len) {\n// This line creates a loop that runs until 'k' is equal to the array length.\n\n// if (k in o && o[k] === searchElement) {\n// This line checks to see if the current element in the array is equal to the 'searchElement' parameter.\n\n// return k;\n// This line returns the index of the element if it is found.\n\n// k++;\n// This line increments 'k' by 1 at the end of each loop.\n\n// return -1;\n// This line returns -1 if the element is not found.",
    useCase:
      "\n\nArray.prototype.indexOf is used in Javascript to find the index of an element in an array. It takes the element as an argument and returns the index of the first occurrence of the element in the array, or -1 if the element is not present. This method is useful for quickly finding the position of an element in an array and for checking if an element exists in an array.",
  },
  {
    code: "\n\nif (!Array.prototype.keys) {\n  Array.prototype.keys = function() {\n    let index = 0;\n    let array = this;\n    return {\n      next: () => {\n        if (index < array.length) {\n          return {\n            value: index++, \n            done: false\n          };\n        }\n        return {\n          done: true\n        };\n      }\n    };\n  };\n}",
    term: "Array.prototype.keys",
    explain:
      "\n\n// Line 1: This line checks to see if the Array.prototype object has a property of 'keys' and if not, it proceeds to the next line of code. \n// Line 2: This line adds a 'keys' property to the Array.prototype object that is a function. \n// Line 3: This line declares a variable called 'index' and sets its value to 0. \n// Line 4: This line declares a variable called 'array' and sets its value to the array calling the function. \n// Line 5: This line returns an object with a 'next' property, which is a function. \n// Line 6: This line checks to see if the 'index' is less than the length of the array and if it is, it returns an object with a 'value' property set to the 'index' and a 'done' property set to false. \n// Line 7: This line is executed if the 'index' is not less than the length of the array and it returns an object with a 'done' property set to true. \n// Line 8: This line closes the 'next' function. \n// Line 9: This line closes the 'keys' function.",
    useCase:
      "\n\nArray.prototype.keys is used in Javascript to return a new Array Iterator object that contains the keys for each index in the array. This allows developers to iterate over the array and access the keys of each index, which can then be used to access the corresponding value. This method is useful for accessing and manipulating the data stored in an array.",
  },
  {
    code: "\n\nif (!Array.prototype.lastIndexOf) {\n    Array.prototype.lastIndexOf = function (searchElement, fromIndex) {\n        let k;\n        if (fromIndex === undefined) {\n            k = this.length - 1;\n        } else {\n            k = fromIndex >= 0 ? fromIndex : this.length + fromIndex;\n        }\n        for (let i = k; i >= 0; i--) {\n            if (this[i] === searchElement) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}",
    term: "Array.prototype.lastIndexOf",
    explain:
      "\n\n// This code is checking to see if the lastIndexOf function is already present on the Array.prototype object.\n// If it is not, it is adding the function to the Array.prototype object.\n\n// Line 1: \n// This is a check to see if the lastIndexOf function is already present on the Array.prototype object. \n// If it is, the code does not need to be run.\n\n// Line 2: \n// This line is defining the lastIndexOf function and adding it to the Array.prototype object if it is not already present.\n\n// Line 3:\n// This line is setting up the k variable. If the fromIndex parameter is not specified, it sets k to the length of the array minus 1. \n// Otherwise, it sets k to the value of fromIndex if it is greater than or equal to 0, or the length of the array plus the value of fromIndex if it is less than 0.\n\n// Line 4:\n// This line is starting a for loop that runs from k to 0.\n\n// Line 5:\n// This line is checking to see if the element at the current index of the array is equal to the searchElement parameter. \n// If it is, it returns the index of the element.\n\n// Line 6: \n// This line is run if the element at the current index of the array is not equal to the searchElement parameter. \n// It returns -1, indicating that the searchElement was not found in the array.",
    useCase:
      "\n\nArray.prototype.lastIndexOf is used in JavaScript to find the last index of an element in an array. It is useful for finding the last occurrence of an element in an array and can be used to determine whether an element exists in the array or not. It is also useful for identifying the index of the last item in an array that meets a certain criteria.",
  },
  {
    code: "\n\n//polyfill of Array.prototype.map function\nif(!Array.prototype.map){\n    Array.prototype.map = function(callback, thisArg){\n        let resultArray = [];\n        for(let i = 0; i < this.length; i++){\n            resultArray.push(callback.call(thisArg, this[i], i, this));\n        }\n        return resultArray;\n    }\n}",
    term: "Array.prototype.map",
    explain:
      "\n\n//This code creates a polyfill of the Array.prototype.map function. This is a function that allows the user to traverse through each element of an array and apply a callback function on each element.\n\n//Line 1:\n//This line checks to see if the Array.prototype.map function already exists.\n\n//Line 2:\n//If the function does not already exist, this line creates the Array.prototype.map function.\n\n//Line 3:\n//This line creates an empty resultArray that will contain the result of the map function.\n\n//Line 4:\n//This line creates a for loop that iterates through each element of the array and applies the callback function. \n\n//Line 5:\n//This line pushes the result of the callback function to the resultArray.\n\n//Line 6:\n//This line returns the resultArray.",
    useCase:
      "\n\nArray.prototype.map is used in Javascript to create a new array of values by mapping each element in an existing array through a function. This can be used to transform each element in the existing array into a different value or format. It is useful for performing operations on all elements in an array in a concise manner.",
  },
  {
    code: "\n\nif (!Array.prototype.reduce) {\n  Array.prototype.reduce = function(callback /*, initialValue*/) {\n    if (this === null) {\n      throw new TypeError('Array.prototype.reduce ' +\n        'called on null or undefined');\n    }\n    if (typeof callback !== 'function') {\n      throw new TypeError(callback +\n        ' is not a function');\n    }\n\n    // 1. Let O be ? ToObject(this value).\n    var o = Object(this);\n\n    // 2. Let len be ? ToLength(? Get(O, \"length\")).\n    var len = o.length >>> 0;\n\n    // Steps 3, 4, 5, 6, 7\n    var k = 0;\n    var value;\n\n    if (arguments.length >= 2) {\n      value = arguments[1];\n    } else {\n      while (k < len && !(k in o)) {\n        k++;\n      }\n\n      // 3. If len is 0 and initialValue is not present,\n      //    throw a TypeError exception.\n      if (k >= len) {\n        throw new TypeError('Reduce of empty array ' +\n          'with no initial value');\n      }\n      value = o[k++];\n    }\n\n    // 8. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      // b. Let kPresent be ? HasProperty(O, Pk).\n      // c. If kPresent is true, then\n      //    i. Let kValue be ? Get(O, Pk).\n      //    ii. Let accumulator be ? Call(\n      //          callbackfn, undefined,\n      //          « accumulator, kValue, k, O »).\n      if (k in o) {\n        value = callback(value, o[k], k, o);\n      }\n\n      // d. Increase k by 1.\n      k++;\n    }\n\n    // 9. Return accumulator.\n    return value;\n  };\n}",
    term: "Array.prototype.reduce",
    explain:
      "\n\n// Line 1: This line is a check to make sure the reduce function is not already present in the Array.prototype. If the reduce function is not present, the code will continue.\n\n// Line 2: This line is the beginning of the reduce function that will be added to the Array.prototype. It takes in a callback as its argument.\n\n// Line 3-6: This block of code is a check to make sure that the object passed in is an Array. If it is not an Array, it will throw an error.\n\n// Line 7-11: This block of code is a check to make sure the initial value is passed in. If an initial value is not passed in, the first value of the array will be used.\n\n// Line 12-21: This block of code is a loop that will iterate over the array and call the callback function with the accumulator, current value, index, and array as arguments.\n\n// Line 22-25: This block of code returns the accumulator after the loop is finished.",
    useCase:
      "\n\nArray.prototype.reduce is used in JavaScript to iterate through an array and reduce it down to a single value. It can be used to perform a variety of tasks such as summing up values, calculating the average, joining elements together in a string, and more. It is a powerful method that allows developers to quickly and efficiently work with data in an array.",
  },
  {
    code: "\n\nif (!Array.prototype.reduceRight) {\n  Array.prototype.reduceRight = function(callback, initialValue) {\n    let arr = Object(this); \n    let len = arr.length >>> 0; \n    let k = len - 1;\n    let accumulator;\n\n    if (arguments.length >= 2) {\n      accumulator = initialValue;\n    } else {\n      while (k >= 0 && !(k in arr)) {\n        k--;\n      }\n      if (k < 0)\n        throw new TypeError('Reduce of empty array with no initial value');\n      accumulator = arr[k--];\n    }\n    \n    for (; k >= 0; k--) {\n      if (k in arr) {\n       accumulator = callback(accumulator, arr[k], k, arr);\n      }\n    }\n    return accumulator; \n  }\n}",
    term: "Array.prototype.reduceRight",
    explain:
      '\n\n// Line 1: \n// This line checks if the Array.prototype.reduceRight function already exists. If it does not, it will create the function.\n\n// Line 2: \n// This line creates the Array.prototype.reduceRight function, with two parameters, callback and initialValue.\n\n// Line 3: \n// This line creates a variable called "arr" which is an object version of the array.\n\n// Line 4: \n// This line creates a variable called "len" which stores the length of the array.\n\n// Line 5: \n// This line creates a variable called "k" which is equal to the length of the array minus 1.\n\n// Line 6: \n// This line creates a variable called "accumulator" which will store the result of the reduceRight operation.\n\n// Line 7: \n// This line checks if there are two arguments (callback and initialValue). If there are two arguments, the accumulator variable is set to the initialValue argument.\n\n// Line 8: \n// This line checks if the k variable is greater than or equal to 0 and if the kth element of the array exists. If it does not, the k variable is decremented by 1.\n\n// Line 9: \n// This line checks if the k variable is less than 0. If it is, it throws an error because there is no initial value. \n\n// Line 10: \n// This line sets the accumulator variable to the kth element of the array and decrements k by 1.\n\n// Line 11: \n// This line runs a for loop from k to 0.\n\n// Line 12: \n// This line checks if the kth element of the array exists. If it does, the accumulator variable is set to the result of the callback function.\n\n// Line 13: \n// This line returns the accumulator variable which holds the result of the reduceRight operation.',
    useCase:
      "\n\nArray.prototype.reduceRight is used to iterate through an array from right to left, applying a callback function to each element. This can be useful for performing a certain operation on an array, such as adding up all the numbers in an array or finding the maximum value. It also allows developers to apply their own custom logic to each element, enabling them to create more complex applications.",
  },
  {
    code: "\n\nif (!Array.prototype.some) {\n    Array.prototype.some = function(callback, thisArg) {\n        let T, k;\n        if (this == null) {\n            throw new TypeError('this is null or not defined');\n        }\n        let O = Object(this);\n        let len = O.length >>> 0;\n        if (typeof callback !== 'function') {\n            throw new TypeError(callback + ' is not a function');\n        }\n        if (arguments.length > 1) {\n            T = thisArg;\n        }\n        k = 0;\n        while (k < len) {\n            let kValue;\n            if (k in O) {\n                kValue = O[k];\n                let testResult = callback.call(T, kValue, k, O);\n                if (testResult) {\n                    return true;\n                }\n            }\n            k++;\n        }\n        return false;\n    };\n}",
    term: "Array.prototype.some",
    explain:
      "\n\n//Line 1: This line checks if the .some() method exists on the Array prototype.\n//Line 2: If it does not exist, the function creates a .some() method on the Array prototype.\n//Line 3: This line creates a variable T and k to store temporary values.\n//Line 4: This line checks if the array is null or undefined.\n//Line 5: This line creates an Object from the array.\n//Line 6: This line creates a variable len to store the length of the array.\n//Line 7: This line checks if the callback argument is a function.\n//Line 8: This line checks if the thisArg argument is present.\n//Line 9: This line sets the value of k to 0.\n//Line 10: This line creates a while loop that runs until k is equal to the length of the array.\n//Line 11: This line creates a variable kValue to store the value of the array at the given index.\n//Line 12: This line checks if the index exists in the array.\n//Line 13: This line sets kValue to the value of the array at the given index.\n//Line 14: This line calls the callback function with the current value, index, and array as arguments.\n//Line 15: This line checks if the callback returns true, and if so, returns true.\n//Line 16: This line increments k.\n//Line 17: This line returns false if the callback function never returns true.",
    useCase:
      "\n\nArray.prototype.some is used in JavaScript to check if at least one element in the array passes a certain condition. It is useful for quickly testing if any elements in an array meet a certain criteria. It can be used to check if any elements in an array match a certain value, or if any elements in an array satisfy a certain condition.",
  },
  {
    code: "\n\nif (!Array.prototype.sort) {\n  Array.prototype.sort = function(compareFn) {\n\n    const length = this.length;\n\n    for (let i = 0; i < length; i++) {\n      for (let j = 0; j < length - 1; j++) {\n        if (compareFn ? compareFn(this[j], this[j + 1]) > 0 : this[j] > this[j + 1]) {\n          let temp = this[j];\n          this[j] = this[j + 1];\n          this[j + 1] = temp;\n        }\n      }\n    }\n    return this;\n  }\n}",
    term: "Array.prototype.sort",
    explain:
      "\n\n// Line 1: This line is a conditional statement that checks to see if the Array.prototype has a sort method.\n// Line 2: If the Array.prototype does not have a sort method, this line defines a sort method for the Array.prototype.\n// Line 3: This line declares a variable length that is set to the length of the array.\n// Line 4: This line is a for loop that iterates through the array starting at the first element.\n// Line 5: This line is a nested for loop that iterates through the array starting at the second element.\n// Line 6: This line is a conditional statement that checks if the compareFn parameter is passed in and compares the two elements. If the compareFn parameter is not passed in, then it compares the two elements with the greater than operator.\n// Line 7: This line declares a temporary variable and sets it to the first element.\n// Line 8: This line sets the first element to the second element.\n// Line 9: This line sets the second element to the temporary variable which is the first element.\n// Line 10: This line closes the nested for loop.\n// Line 11: This line closes the for loop.\n// Line 12: This line returns the array after it has been sorted.\n// Line 13: This line closes the conditional statement.",
    useCase:
      "\n\nArray.prototype.sort is used in Javascript to sort an array in ascending or descending order. This method is used to sort elements of an array alphabetically, numerically, or by any other custom sorting criteria. This method is useful for sorting data in a more efficient way than manually looping through the array and comparing each element.",
  },
  {
    code: "\n\nif (!Array.prototype.values) {\n    Array.prototype.values = function () {\n        let i = 0;\n        let current = this[i];\n        const iterator = {\n            next: function () {\n                const value = {\n                    done: i >= this.length,\n                    value: current\n                }\n                i++;\n                current = this[i];\n                return value;\n            }\n        };\n        return iterator;\n    };\n}",
    term: "Array.prototype.values",
    explain:
      "\n\n// Line 1: \n// This line checks to see if there is already an existing 'values' prototype method for the Array object. \n\n// Line 2: \n// If the 'values' prototype method does not exist, this line adds it as a function on the Array prototype.\n\n// Line 3: \n// This line initializes a counter variable i and sets it to 0.\n\n// Line 4: \n// This line initializes a variable called current and sets it to the first element in the array.\n\n// Line 5: \n// This line creates an iterator object and assigns it to the variable iterator.\n\n// Line 6: \n// This line creates a function called next which returns an object with two properties, done and value. The done property is set to true if the counter is greater than or equal to the length of the array, and the value property is set to the current element in the array.\n\n// Line 7: \n// This line increments the counter variable.\n\n// Line 8: \n// This line sets the current variable to the next element in the array.\n\n// Line 9: \n// This line returns the iterator object.\n\n// Line 10: \n// This line returns the values function.",
    useCase:
      "\n\nArray.prototype.values is used in Javascript to return a new Array Iterator object that contains the values for each index in the array. It provides a way to access all the elements of an array without having to loop through them individually. This is helpful when dealing with large arrays, as it can speed up the process of iterating over them.",
  },
  {
    code: "\n\nif (!ArrayBuffer.prototype.slice) {\n    ArrayBuffer.prototype.slice = function(start, end) {\n        let that = new Uint8Array(this);\n        if (end === undefined) end = that.length;\n        let result = new ArrayBuffer(end - start);\n        let resultArray = new Uint8Array(result);\n        for (let i = 0; i < resultArray.length; i++) {\n            resultArray[i] = that[i + start];\n        }\n        return result;\n    };\n}",
    term: "ArrayBuffer",
    explain:
      "\n\n// Line 1: \n// This line checks if the ArrayBuffer.prototype object does not have a slice method. If it does not, it will proceed to the next line. Otherwise, it will skip the rest of the code. \n\n// Line 2: \n// This line adds a slice method to the ArrayBuffer.prototype object. This method takes two arguments, start and end.\n\n// Line 3: \n// This line creates a new Uint8Array from the ArrayBuffer. If the end argument is not given, it will set end equal to the length of the Uint8Array.\n\n// Line 4:\n// This line creates a new ArrayBuffer with the length of end minus start.\n\n// Line 5:\n// This line creates a new Uint8Array from the new ArrayBuffer. \n\n// Line 6: \n// This line iterates through the resultArray and sets each element to the corresponding element in the that array, which is the original Uint8Array.\n\n// Line 7: \n// This line returns the result ArrayBuffer.",
    useCase:
      "\n\nArrayBuffer is used in JavaScript to store binary data, such as the contents of an image file or a video. It can be used to create a typed array, which is an array of a specific type of data, such as integers or floating-point numbers. ArrayBuffers are also used to create ArrayBufferViews, which are views into an ArrayBuffer that can represent the data as an array of a specific type. ArrayBuffers are a low-level primitive for storing binary data, and are used by many of the higher-level APIs for handling binary data, such as the File and Blob APIs.",
  },
  {
    code: "\n\nif (!ArrayBuffer.isView) {\n  ArrayBuffer.isView = function(arg) {\n    return arg !== null && typeof arg === 'object' && arg.buffer instanceof ArrayBuffer;\n  };\n}",
    term: "ArrayBuffer.isView",
    explain:
      "\n\nLine 1: if (!ArrayBuffer.isView) {\n\nThis line checks whether the isView method already exists on the ArrayBuffer object.\n\nLine 2: ArrayBuffer.isView = function(arg) {\n\nThis line creates a new method on the ArrayBuffer object called isView which takes in a single argument. \n\nLine 3: return arg !== null && typeof arg === 'object' && arg.buffer instanceof ArrayBuffer;\n\nThis line returns a boolean value based on the argument passed to the isView function. It returns true if the argument is not null, is an object, and has a buffer property which is an instance of an ArrayBuffer.",
    useCase:
      "\n\nArrayBuffer.isView is used in Javascript to check if a given value is a view on an ArrayBuffer. This is useful when working with binary data, as it allows us to determine whether a given value is a view of the underlying array buffer. This can be used to ensure that the data is being accessed and manipulated correctly, as well as to detect incorrect uses of views.",
  },
  {
    code: "\n\n(function() {\n  var lastTime = 0;\n  var vendors = ['ms', 'moz', 'webkit', 'o'];\n  for(var x = 0; x < vendors.length && !window.AudioContext; ++x) {\n    window.AudioContext = window[vendors[x]+'AudioContext'];\n  }\n\n  if (!window.AudioContext) {\n    window.AudioContext = function() {\n      this.sampleRate = 44100;\n      this.currentTime = 0;\n      this.listener = {\n        setPosition: function () {},\n        setOrientation: function () {},\n        setVelocity: function () {}\n      };\n      this.createGainNode = function () {\n          return new GainNode();\n      };\n      this.createScriptProcessor = function () {\n          return new ScriptProcessor();\n      };\n      this.createBufferSource = function () {\n          return new BufferSourceNode();\n      };\n      this.createDelayNode = function () {\n          return new DelayNode();\n      };\n      this.createPanner = function () {\n          return new Panner();\n      };\n      this.createAnalyser = function () {\n          return new Analyser();\n      };\n      this.createWaveShaper = function () {\n          return new WaveShaper();\n      };\n      this.createBiquadFilter = function () {\n          return new BiquadFilter();\n      };\n      this.createIIRFilter = function () {\n          return new IIRFilter();\n      };\n      this.createConvolver = function () {\n          return new Convolver();\n      };\n      this.createChannelSplitter = function () {\n          return new ChannelSplitter();\n      };\n      this.createChannelMerger = function () {\n          return new ChannelMerger();\n      };\n      this.createOscillator = function () {\n          return new OscillatorNode();\n      };\n      this.createPeriodicWave = function () {\n          return new PeriodicWave();\n      };\n      this.createMediaElementSource = function () {\n          return new MediaElementSource();\n      };\n      this.createMediaStreamSource = function () {\n          return new MediaStreamSource();\n      };\n      this.createMediaStreamDestination = function () {\n          return new MediaStreamDestination();\n      };\n      this.close = function () {};\n      this.suspend = function () {};\n      this.resume = function () {};\n      this.createBuffer = function () {\n          return new AudioBuffer();\n      };\n      this.decodeAudioData = function () {};\n      this.getOutputTimestamp = function () {\n          return {\n              contextTime: 0,\n              performanceTime: 0\n           }; \n      };\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n    }\n  }\n\n  function GainNode() {\n      this.gain = {\n          value: 1,\n      };\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function ScriptProcessor() {\n      this.onaudioprocess = undefined;\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function BufferSourceNode() {\n      this.buffer = null;\n      this.loop = false;\n      this.loopStart = 0;\n      this.loopEnd = 0;\n      this.onended = null;\n      this.start = function () {};\n      this.stop = function () {};\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function DelayNode() {\n      this.delayTime = {\n          value: 0\n      };\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function Panner() {\n      this.panningModel = 'equalpower';\n      this.setPosition = function () {};\n      this.setOrientation = function () {};\n      this.setVelocity = function () {};\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function Analyser() {\n      this.fftSize = 2048;\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function WaveShaper() {\n      this.oversample = '4x';\n      this.curve = null;\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function BiquadFilter() {\n      this.type = 'lowpass';\n      this.frequency = {\n          value: 440\n      };\n      this.Q = {\n          value: 1\n      };\n      this.detune = {\n          value: 0\n      };\n      this.gain = {\n          value: 0\n      };\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function IIRFilter() {\n      this.type = 'lowpass';\n      this.frequency = {\n          value: 440\n      };\n      this.Q = {\n          value: 1\n      };\n      this.detune = {\n          value: 0\n      };\n      this.gain = {\n          value: 0\n      };\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function Convolver() {\n      this.normalize = true;\n      this.buffer = null;\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function ChannelSplitter() {\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function ChannelMerger() {\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function OscillatorNode() {\n      this.type = 'sine';\n      this.frequency = {\n          value: 440\n      };\n      this.detune = {\n          value: 0\n      };\n      this.start = function () {};\n      this.stop = function () {};\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function PeriodicWave() {\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function MediaElementSource() {\n      this.mediaElement = null;\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function MediaStreamSource() {\n      this.mediaStream = null;\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function MediaStreamDestination() {\n      this.mediaStream = null;\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener =",
    term: "AudioContext",
    explain:
      " function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function AudioBuffer() {\n      this.length = 0;\n      this.sampleRate = 0;\n      this.duration = 0;\n      this.numberOfChannels = 0;\n      this.getChannelData = function () {};\n      this.copyFromChannel = function () {};\n      this.copyToChannel = function () {};\n  }\n\n})();\n\n// Line 1: (function() {\n// This line creates a self-executing anonymous function to contain all of the code in the script. This creates a new scope, where variables can be declared without affecting the global scope. \n\n// Line 2: var lastTime = 0;\n// This line declares a variable called 'lastTime' and initializes it to 0.\n\n// Line 3: var vendors = ['ms', 'moz', 'webkit', 'o'];\n// This line declares a variable called 'vendors' and initializes it to an array of vendor prefixed strings.\n\n// Line 4: for(var x = 0; x < vendors.length && !window.AudioContext; ++x) {\n// This line creates a for loop that runs while 'x' is less than the length of the 'vendors' array and 'window.AudioContext' is not true.\n\n// Line 5: window.AudioContext = window[vendors[x]+'AudioContext'];\n// This line sets 'window.AudioContext' to the 'window' object property that corresponds to the current 'vendors' array item.\n\n// Line 6: if (!window.AudioContext) {\n// This line checks to see if 'window.AudioContext' is not true.\n\n// Line 7-54: This block of code creates a new 'AudioContext' constructor.\n\n// Line 55-82: This block of code creates the 'GainNode' constructor.\n\n// Line 83-110: This block of code creates the 'ScriptProcessor' constructor.\n\n// Line 111-138: This block of code creates the 'BufferSourceNode' constructor.\n\n// Line 139-166: This block of code creates the 'DelayNode' constructor.\n\n// Line 167-194: This block of code creates the 'Panner' constructor.\n\n// Line 195-222: This block of code creates the 'Analyser' constructor.\n\n// Line 223-250: This block of code creates the 'WaveShaper' constructor.\n\n// Line 251-278: This block of code creates the 'BiquadFilter' constructor.\n\n// Line 279-306: This block of code creates the 'IIRFilter' constructor.\n\n// Line 307-334: This block of code creates the 'Convolver' constructor.\n\n// Line 335-362: This block of code creates the 'ChannelSplitter' constructor.\n\n// Line 363-390: This block of code creates the 'ChannelMerger' constructor.\n\n// Line 391-418: This block of code creates the 'OscillatorNode' constructor.\n\n// Line 419-446: This block of code creates the 'PeriodicWave' constructor.\n\n// Line 447-474: This block of code creates the 'MediaElementSource' constructor.\n\n// Line 475-502: This block of code creates the 'MediaStreamSource' constructor.\n\n// Line 503-530: This block of code creates the 'MediaStreamDestination' constructor.\n\n// Line 531-558: This block of code creates the 'AudioBuffer' constructor.\n\n// Line 559: })();\n// This line closes the self-executing anonymous function.",
    useCase:
      "\n\nAudioContext is used in JavaScript to provide an interface for working with audio in web applications. It allows developers to create, manipulate, and play audio in the browser, allowing for more interactive audio experiences. AudioContext provides an API for creating audio sources, routing audio signals, and applying audio effects. It is also used for playback and recording of audio, as well as for synthesis of new audio.",
  },
  {
    code: "\n\nif (!window.Blob) {\n  var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n\n  window.Blob = function (parts, properties) {\n    parts = parts || [];\n    properties = properties || {};\n\n    try {\n      return new Blob(parts, properties);\n    } catch (e) {\n      var bb = new BlobBuilder();\n      parts.forEach(function(p) {\n        bb.append(p);\n      });\n\n      return bb.getBlob(properties.type);\n    }\n  };\n}",
    term: "Blob",
    explain:
      "\n\n// line 1: \n// If the window object does not have a Blob property, the code in this block will execute\n\n// line 2:\n// This line creates a variable called 'BlobBuilder' which stores the window.BlobBuilder, window.WebKitBlobBuilder, window.MozBlobBuilder, or window.MSBlobBuilder property.\n\n// line 3:\n// This line creates a new property in the window object called 'Blob', which is a function that takes two parameters, parts and properties.\n\n// line 4:\n// This line sets the parts parameter to an empty array if it is not defined.\n\n// line 5:\n// This line sets the properties parameter to an empty object if it is not defined.\n\n// line 6:\n// This line attempts to create a new Blob object using the parts and properties parameters.\n\n// line 7:\n// If the attempt to create a new Blob object fails, this catch statement will execute.\n\n// line 8:\n// This line creates a new BlobBuilder object and assigns it to the bb variable.\n\n// line 9:\n// This line calls the forEach method on the parts parameter, which will loop through each item in the array and execute a function.\n\n// line 10:\n// This line calls the append method on the bb object, which adds each item in the array to the BlobBuilder object.\n\n// line 11:\n// This line returns the Blob object created from the BlobBuilder object, using the type property of the properties parameter as the type.",
    useCase:
      "\n\nBlob is used in JavaScript to create immutable objects that can store large amounts of data. Blobs can be used to store large data such as images, audio, video, and other binary data. Blobs can also be used to store data in a structured format such as JSON or XML. Blob objects are also used to create objects that can be used in web applications such as images, audio, video, and other forms of data. Blobs are also used in browser-based applications to store large amounts of data that need to be sent to the server.",
  },
  {
    code: "\n\n// Polyfill for CSS.supports in Javascript\n\nconst cssSupports = (...args) => {\n\tconst len = args.length\n\tlet el = document.createElement('div')\n\tlet style = el.style\n\n\tlet result = true;\n\n\tif(len === 2) {\n\t\tif(typeof args[0] === 'string' && typeof args[1] === 'string') {\n\t\t\tstyle.setProperty(args[0], args[1])\n\t\t\tresult = window.getComputedStyle(el).getPropertyValue(args[0]);\n\t\t}\n\t}\n\telse if (len === 1) {\n\t\tif (typeof args[0] === 'string') {\n\t\t\treturn style[args[0]] !== undefined\n\t\t}\n\t\telse {\n\t\t\tlet supported = true;\n\n\t\t\tObject.keys(args[0]).forEach(prop => {\n\t\t\t\tstyle.setProperty(prop, args[0][prop])\n\t\t\t\tsupported = window.getComputedStyle(el).getPropertyValue(prop);\n\t\t\t})\n\t\t\t\n\t\t\tresult = supported\n\t\t}\n\t}\n\n\treturn result;\n}",
    term: "CSS.supports",
    explain:
      "\n\n// 1. const cssSupports = (...args) => {\n//    This line declares a constant variable called cssSupports and assigns it to a function that takes multiple arguments.\n\n// 2. let el = document.createElement('div')\n//    This line declares a variable called el and assigns it to a new div element, created with the createElement method.\n\n// 3. let style = el.style\n//    This line declares a variable called style and assigns it to the style property of the el variable, which is a div element.\n\n// 4. let result = true;\n//    This line declares a variable called result and assigns it to a boolean value of true.\n\n// 5. if(len === 2) {\n//    This line is an if statement that checks if the number of arguments passed to the function is equal to 2.\n\n// 6. if(typeof args[0] === 'string' && typeof args[1] === 'string') {\n//    This line is an if statement nested inside the previous if statement, which checks if the first and second arguments passed to the function are both strings.\n\n// 7. style.setProperty(args[0], args[1])\n//    This line sets the property of the style variable to the first and second arguments passed to the function.\n\n// 8. result = window.getComputedStyle(el).getPropertyValue(args[0]);\n//    This line assigns the variable result to the computed style of the el variable, which is a div element, using the getPropertyValue method and the first argument passed to the function.\n\n// 9. else if (len === 1) {\n//    This line is an else if statement that checks if the number of arguments passed to the function is equal to 1.\n\n// 10. if (typeof args[0] === 'string') {\n//    This line is an if statement nested inside the else if statement, which checks if the first argument passed to the function is a string.\n\n// 11. return style[args[0]] !== undefined\n//    This line returns a boolean value of true or false, depending on whether the value of the style variable, which is a div element, and the first argument passed to the function is undefined or not.\n\n// 12. else {\n//    This line is an else statement that is nested inside the else if statement.\n\n// 13. let supported = true;\n//    This line declares a variable called supported and assigns it to a boolean value of true.\n\n// 14. Object.keys(args[0]).forEach(prop => {\n//    This line uses the Object.keys method to loop through the first argument passed to the function and pass each key to the forEach method.\n\n// 15. style.setProperty(prop, args[0][prop])\n//    This line sets the property of the style variable to the key of the first argument passed to the function and the value of that key.\n\n// 16. supported = window.getComputedStyle(el).getPropertyValue(prop);\n//    This line assigns the variable supported to the computed style of the el variable, which is a div element, using the getPropertyValue method and the key of the first argument passed to the function.\n\n// 17. result = supported\n//    This line assigns the variable result to the value of the supported variable.\n\n// 18. return result;\n//    This line returns the value of the result variable.",
    useCase:
      "\n\nCSS.supports is used in Javascript to check if the current user's browser supports a specific CSS property and its associated value. This helps developers create websites and apps that will function correctly across different browsers. It also allows developers to provide different styles or functionality based on the user's browser.",
  },
  {
    code: "\n\n(function () {\n  if ( typeof window.CustomEvent === \"function\" ) return false;\n\n  function CustomEvent ( event, params ) {\n    params = params || { bubbles: false, cancelable: false, detail: undefined };\n    var evt = document.createEvent( 'CustomEvent' );\n    evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );\n    return evt;\n   }\n\n  CustomEvent.prototype = window.Event.prototype;\n\n  window.CustomEvent = CustomEvent;\n})();",
    term: "CustomEvent",
    explain:
      "\n\n1. (function () {...})(); \n// This is an immediately invoked function expression (IIFE). It allows us to use variables and functions without polluting the global scope.\n\n2. if ( typeof window.CustomEvent === \"function\" ) return false;\n// This checks to see if a function called CustomEvent exists in the global window scope. If it does, the function exits.\n\n3. function CustomEvent ( event, params ) {...}\n// This is a function declaration that takes two parameters, event and params.\n\n4. params = params || { bubbles: false, cancelable: false, detail: undefined };\n// This sets the params parameter to the given value, or if it is undefined, it sets it to an object with the given values for bubbles, cancelable, and detail.\n\n5. var evt = document.createEvent( 'CustomEvent' );\n// This creates a new event object called evt in the document object.\n\n6. evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );\n// This initializes the event object with the given parameters.\n\n7. return evt;\n// This returns the event object.\n\n8. CustomEvent.prototype = window.Event.prototype;\n// This sets the prototype of the CustomEvent function to the prototype of the window.Event function.\n\n9. window.CustomEvent = CustomEvent;\n// This sets the CustomEvent function as a property of the global window object.",
    useCase:
      "\n\nCustomEvent is used in Javascript to allow developers to create and trigger their own custom events. With CustomEvent, developers can define the name, type, and details of the event in order to handle it in their own unique way. This is especially useful when dealing with complex user interactions that need to be handled in a particular order. By creating a custom event, developers can ensure that the expected behavior is triggered and that the application remains consistent.",
  },
  {
    code: "\n\nif (typeof DOMRect === 'undefined' || DOMRect === null) {\n  class DOMRect {\n    constructor(x = 0, y = 0, width = 0, height = 0) {\n      this.x = x;\n      this.y = y;\n      this.width = width;\n      this.height = height;\n      this.top = this.y;\n      this.left = this.x;\n      this.right = this.x + this.width;\n      this.bottom = this.y + this.height;\n    }\n  }\n\n  window.DOMRect = DOMRect;\n}",
    term: "DOMRect",
    explain:
      "\n\n//Line 1: This line checks if the variable DOMRect is defined or if it is null. \n//Line 2: This line starts the DOMRect class. \n//Line 3: This line defines the constructor of the DOMRect class with initial values of 0 for x, y, width, and height. \n//Line 4-7: This lines set the x, y, width, and height values of the DOMRect class. \n//Line 8-11: This lines set the top, left, right, and bottom values of the DOMRect class. \n//Line 12: This line assigns the DOMRect class to the global window object.",
    useCase:
      "\n\nDOMRect is used in JavaScript to represent a rectangular area on the page. It is used to help compute the size and position of elements on the page, such as when calculating the position of an element relative to the viewport or when calculating the size of an element to determine how much space it occupies.",
  },
  {
    code: "\n\nif (!DOMRect.fromRect) {\n  DOMRect.fromRect = function (rect) {\n    return new DOMRect(rect.x, rect.y, rect.width, rect.height);\n  };\n}",
    term: "DOMRect.fromRect",
    explain:
      "\n\n// If the DOMRect object does not have a method called 'fromRect', create one.\n// The function takes a parameter 'rect', and uses it to create a new DOMRect object with the coordinates 'rect.x', 'rect.y', 'rect.width', and 'rect.height'.",
    useCase:
      "\n\nDOMRect.fromRect is used to create a DOMRect object from an object with properties that have the same names as the properties of DOMRect. This is useful for converting existing data structures into DOMRect objects so they can be used with the DOM. It is also helpful when passing data between different parts of a program, as it allows the data to be manipulated as a DOMRect object, rather than having to manually access each property.",
  },
  {
    code: "\n\nif (typeof DOMTokenList === 'undefined') {\n    (function (global) {\n        \"use strict\";\n        var DOMTokenList = function(el) {\n            Object.defineProperty(this, '_elem', { value: el });\n            var str = el.getAttribute('class') || '';\n            var classes = str.trim().split(/\\s+/);\n            for (var i = 0; i < classes.length; i++) {\n                Object.defineProperty(this, i, { value: classes[i] });\n            }\n            Object.defineProperty(this, 'length', { value: classes.length });\n        };\n        DOMTokenList.prototype = {\n            constructor: DOMTokenList,\n            item: function(index) {\n                return this[index] || null;\n            },\n            contains: function(token) {\n                for (var i = 0; i < this.length; i++) {\n                    if (this[i] === token) {\n                        return true;\n                    }\n                }\n                return false;\n            },\n            add: function() {\n                for (var i = 0; i < arguments.length; i++) {\n                    if (!this.contains(arguments[i])) {\n                        Object.defineProperty(this, this.length, {\n                            value: arguments[i]\n                        });\n                        this.length++;\n                    }\n                }\n                this._elem.setAttribute('class', [].slice.call(this).join(' '));\n            },\n            remove: function() {\n                for (var i = 0; i < arguments.length; i++) {\n                    for (var j = 0; j < this.length; j++) {\n                        if (this[j] === arguments[i]) {\n                            [].splice.call(this, j, 1);\n                            j--;\n                            this.length--;\n                        }\n                    }\n                }\n                this._elem.setAttribute('class', [].slice.call(this).join(' '));\n            },\n            toggle: function(token) {\n                if (this.contains(token)) {\n                    this.remove(token);\n                    return false;\n                } else {\n                    this.add(token);\n                    return true;\n                }\n            }\n        };\n        global.DOMTokenList = DOMTokenList;\n    })(window);\n}",
    term: "DOMTokenList",
    explain:
      "\n\n//line 1: if (typeof DOMTokenList === 'undefined') {\n//This line checks if the DOMTokenList is already defined or not. If it is not defined then the code inside the if block will be executed\n\n//line 2: (function (global) {\n//This line creates a self-invoking anonymous function with global as a parameter.\n\n//line 3: \"use strict\";\n//This line sets the JavaScript code to strict mode which helps to write secure code.\n\n//line 4: var DOMTokenList = function(el) {\n//This line creates a DOMTokenList function with el as a parameter.\n\n//line 5-8: Object.defineProperty(this, '_elem', { value: el });\n//These lines define a property called \"_elem\" with the value of el on the current object.\n\n//line 9: var str = el.getAttribute('class') || '';\n//This line gets the class attribute value of the element and assigns it to a variable called str. If the class attribute is not present then an empty string is assigned to str.\n\n//line 10: var classes = str.trim().split(/\\s+/);\n//This line trims the whitespaces in the str variable and splits the string into an array of classes.\n\n//line 11-13: for (var i = 0; i < classes.length; i++) {\n//This line is a for loop which iterates over each class in the classes array.\n\n//line 14-15: Object.defineProperty(this, i, { value: classes[i] });\n//These lines define a property with the index of the class in the classes array as the name and the value of the class as the value of the property.\n\n//line 16-17: Object.defineProperty(this, 'length', { value: classes.length });\n//These lines define a property called \"length\" with the value of the length of the classes array.\n\n//line 18-48: This is the definition of the DOMTokenList prototype.\n\n//line 49-55: global.DOMTokenList = DOMTokenList;\n//These lines assign the DOMTokenList function to the global object.\n\n//line 56: })(window);\n//This line invokes the anonymous function assigning the window object as the parameter.",
    useCase:
      "\n\nDOMTokenList is used in JavaScript to enable the manipulation of the class attribute of a DOM element. It provides methods to add, remove, and toggle the classes of a DOM element, which can be used to change the styling of the element. This is especially useful when creating dynamic web pages, as it allows elements to be styled based on user input.",
  },
  {
    code: "\n\nDOMTokenList.prototype[Symbol.iterator] = function() {\n  let i = 0;\n  const len = this.length;\n  const tokens = this.value;\n  return {\n    next() {\n      if (i < len) {\n        return {\n          done: false,\n          value: tokens[i++]\n        }\n      } else {\n        return {\n          done: true\n        }\n      }\n    }\n  }\n};",
    term: "DOMTokenList.prototype.@@iterator",
    explain:
      '\n\n// Line 1: This line is adding a new prototype method to the DOMTokenList class. The method is using the Symbol.iterator Symbol as its name.\n// Line 2: This line is declaring a variable called "i" and initializing it to 0.\n// Line 3: This line is declaring a variable called "len" and initializing it to the length of the DOMTokenList.\n// Line 4: This line is declaring a variable called "tokens" and initializing it to the value of the DOMTokenList.\n// Line 5-9: This is a return statement containing a function that takes no arguments and returns an object. The object contains two properties, "done" and "value", and their values are determined by the if statement. If the value of i is less than the value of len, the done property is set to false and the value property is set to the token at the current index. If i is not less than len, the done property is set to true. \n// Line 10: This line is the closing brace of the return statement.',
    useCase:
      "\n\nDOMTokenList.prototype.@@iterator is used in Javascript to provide an iterable interface for the DOMTokenList interface. This allows for iterating over the list of tokens in a DOMTokenList, which can be useful for looping through the list to perform operations. This is especially useful when working with HTML elements and manipulating their attributes.",
  },
  {
    code: '\n\nif ((typeof DOMTokenList !== "undefined") && !("forEach" in DOMTokenList.prototype)) {\n  DOMTokenList.prototype.forEach = function forEach(callback) {\n    for (var i = 0; i < this.length; i++) {\n      callback(this.item(i), i, this);\n    }\n  };\n}',
    term: "DOMTokenList.prototype.forEach",
    explain:
      '\n\n//This line checks if the DOMTokenList is defined and if the forEach method is not already a part of the DOMTokenList.prototype\nif ((typeof DOMTokenList !== "undefined") && !("forEach" in DOMTokenList.prototype)) {\n\n//This line creates the forEach method for the DOMTokenList.prototype\n  DOMTokenList.prototype.forEach = function forEach(callback) {\n\n//This line is the loop that iterates over the DOMTokenList\n    for (var i = 0; i < this.length; i++) {\n\n//This line calls the callback function for each item in the DOMTokenList\n      callback(this.item(i), i, this);\n    }\n  };\n\n//This line closes the if statement\n}',
    useCase:
      "\n\nDOMTokenList.prototype.forEach is used in Javascript to iterate over the list of tokens in a DOMTokenList object. It allows developers to perform a function on each item in the list, making it easy to manipulate the data. This can be used to filter out certain tokens, add new tokens, or do any other operation on the list.",
  },
  {
    code: "\n\nif (!('replace' in DOMTokenList.prototype)) {\n  DOMTokenList.prototype.replace = function (token, newToken) {\n    if (this.contains(token)) {\n      this.remove(token);\n      if (newToken) {\n        this.add(newToken);\n      }\n    }\n  };\n}",
    term: "DOMTokenList.prototype.replace",
    explain:
      "\n\n// This code checks to see if the 'replace' method is not present in the DOMTokenList prototype. \n// If 'replace' is not present, then the code defines a new 'replace' method on the prototype. \n// The new 'replace' method takes two parameters, token and newToken. \n// It then checks to see if the token is present in the list and if it is, it removes it and if there is a newToken provided, it adds it.",
    useCase:
      "\n\nDOMTokenList.prototype.replace is used in Javascript to replace an existing token with a new one. It is useful for updating the classList of an element by replacing an existing class with a new one. This method is also useful for manipulating HTML attributes such as rel, type, and media.",
  },
  {
    code: "\n\n// Polyfill for DataView\nif (!window.DataView) {\n  window.DataView = class DataView {\n    constructor(buffer, byteOffset = 0, byteLength = buffer.byteLength) {\n      this.buffer = buffer;\n      this.byteOffset = byteOffset;\n      this.byteLength = byteLength;\n    }\n    getInt8(byteOffset) {\n      return this._get(byteOffset, 1)[0];\n    }\n    getUint8(byteOffset) {\n      return this.getInt8(byteOffset) >>> 0;\n    }\n    getInt16(byteOffset, littleEndian) {\n      return this._get(byteOffset, 2, littleEndian)[0];\n    }\n    getUint16(byteOffset, littleEndian) {\n      return this.getInt16(byteOffset, littleEndian) >>> 0;\n    }\n    getInt32(byteOffset, littleEndian) {\n      return this._get(byteOffset, 4, littleEndian)[0];\n    }\n    getUint32(byteOffset, littleEndian) {\n      return this.getInt32(byteOffset, littleEndian) >>> 0;\n    }\n    getFloat32(byteOffset, littleEndian) {\n      return this._get(byteOffset, 4, littleEndian)[0];\n    }\n    getFloat64(byteOffset, littleEndian) {\n      return this._get(byteOffset, 8, littleEndian)[0];\n    }\n    setInt8(byteOffset, value) {\n      this._set(byteOffset, [value], 1);\n    }\n    setUint8(byteOffset, value) {\n      this.setInt8(byteOffset, value);\n    }\n    setInt16(byteOffset, value, littleEndian) {\n      this._set(byteOffset, [value], 2, littleEndian);\n    }\n    setUint16(byteOffset, value, littleEndian) {\n      this.setInt16(byteOffset, value, littleEndian);\n    }\n    setInt32(byteOffset, value, littleEndian) {\n      this._set(byteOffset, [value], 4, littleEndian);\n    }\n    setUint32(byteOffset, value, littleEndian) {\n      this.setInt32(byteOffset, value, littleEndian);\n    }\n    setFloat32(byteOffset, value, littleEndian) {\n      this._set(byteOffset, [value], 4, littleEndian);\n    }\n    setFloat64(byteOffset, value, littleEndian) {\n      this._set(byteOffset, [value], 8, littleEndian);\n    }\n    _get(byteOffset, size, littleEndian) {\n      if (byteOffset + size > this.byteLength) {\n        throw new RangeError('Index out of range');\n      }\n      const view = new Uint8Array(this.buffer, this.byteOffset + byteOffset, size);\n      const result = [0];\n      for (let i = 0; i < size; i++) {\n        result[0] += view[i] * Math.pow(2, 8 * (littleEndian ? size - i - 1 : i));\n      }\n      return result;\n    }\n    _set(byteOffset, values, size, littleEndian) {\n      if (byteOffset + size > this.byteLength) {\n        throw new RangeError('Index out of range');\n      }\n      const view = new Uint8Array(this.buffer, this.byteOffset + byteOffset, size);\n      for (let i = 0; i < size; i++) {\n        const factor = Math.pow(2, 8 * (littleEndian ? size - i - 1 : i));\n        view[i] = (values[0] / factor) & 0xff;\n      }\n    }\n  };\n}",
    term: "DataView",
    explain:
      "\n\n//This code is a Polyfill for DataView, which is a JavaScript type for representing a collection of data in a structured way. This code is setting up a class called DataView, which will contain methods for getting and setting data in the structured collection of data.\n\n// Line 1: This line is checking if window.DataView is defined, and if it isn't, then it will proceed to the code following this line. \n\n// Lines 2-29: This section of code is defining the class DataView. The constructor takes three parameters, buffer, byteOffset and byteLength. The class will also contain methods for getting and setting data, such as getInt8, getUint8, getInt16, getUint16, getInt32, getUint32, getFloat32, getFloat64, setInt8, setUint8, setInt16, setUint16, setInt32, setUint32, setFloat32, setFloat64.\n\n// Lines 30-60: This section defines the method _get which takes three parameters, byteOffset, size and littleEndian. It will also throw a RangeError when the byteOffset is out of range.\n\n// Lines 61-87: This section defines the method _set which takes four parameters, byteOffset, values, size and littleEndian. It will also throw a RangeError when the byteOffset is out of range.",
    useCase:
      "\n\nDataView is used in JavaScript to provide a low-level interface for reading and writing multiple number types in an ArrayBuffer, without having to worry about the platform's endianness. It allows developers to manipulate binary data in a consistent format, regardless of the platform. It also provides a way to access data stored in an ArrayBuffer without having to copy it into a new data structure.",
  },
  {
    code: "\n\nif (!Date.now) {\n  Date.now = function() {\n    return new Date().getTime();\n  };\n}",
    term: "Date.now",
    explain:
      "\n\n// Line 1: This sets up a conditional statement that checks if the Date.now function does not exist.\n// Line 2: If the Date.now function does not exist, this creates it as a function that returns the time since midnight of January 1, 1970 (in milliseconds). This is the standard JavaScript date format.",
    useCase:
      "\n\nDate.now() is used in Javascript to get the current timestamp in milliseconds since the Unix epoch, which is the number of milliseconds that have elapsed since January 1, 1970 00:00:00 UTC. This is useful for creating unique identifiers, measuring the time elapsed between events, and other related tasks.",
  },
  {
    code: "\n\nif (!Date.prototype.toISOString) {\n  Date.prototype.toISOString = function () {\n    Date.prototype.toISOString = function () {\n      var tzo = -this.getTimezoneOffset(),\n        dif = tzo >= 0 ? '+' : '-',\n        pad = function (num) {\n          var norm = Math.floor(Math.abs(num));\n          return (norm < 10 ? '0' : '') + norm;\n        };\n      return this.getFullYear() +\n        '-' + pad(this.getMonth() + 1) +\n        '-' + pad(this.getDate()) +\n        'T' + pad(this.getHours()) +\n        ':' + pad(this.getMinutes()) +\n        ':' + pad(this.getSeconds()) +\n        dif + pad(tzo / 60) +\n        ':' + pad(tzo % 60);\n    };\n  }\n}",
    term: "Date.prototype.toISOString",
    explain:
      "\n\n// This code checks if the Date.prototype.toISOString() method exists. If it does not exist, it will create a function to add it. \n// Line 1: If the Date.prototype.toISOString() method does not exist\n// Line 2: Add the Date.prototype.toISOString() method\n// Line 3: Get the timezone offset and determine if it is positive or negative\n// Line 4: Create a pad() function to get the hour, minutes and seconds\n// Line 5: Get the year\n// Line 6: Get the month \n// Line 7: Get the date\n// Line 8: Get the hour\n// Line 9: Get the minutes\n// Line 10: Get the seconds\n// Line 11: Get the timezone offset\n// Line 12: Get the minutes for the timezone offset\n// Line 13: Get the seconds for the timezone offset",
    useCase:
      "\n\nDate.prototype.toISOString is used in Javascript to produce a string representation of a Date object in ISO format, which is an international standard for representing dates and times. This format is especially useful for storing and sorting dates, as it is an unambiguous representation that can be easily parsed and compared to other dates. It is also useful for passing dates between different systems, as it is a widely recognized format.",
  },
  {
    code: "\n\nif (!Document) {\n  Document = function Document() {\n    this.nodeType = 9;\n    this.name = '#document';\n    this.childNodes = [];\n    this.childElementCount = 0;\n    this.children = [];\n    this.firstChild = null;\n    this.lastChild = null;\n    this.documentElement = null;\n\n    // Methods\n    Object.defineProperty(Document, 'createElement', {\n      value: function createElement(tagName) {\n        var element = new Element(tagName);\n        element.ownerDocument = this;\n        return element;\n      }\n    });\n\n    Object.defineProperty(Document, 'createTextNode', {\n      value: function createTextNode(text) {\n        var textNode = new Text(text);\n        textNode.ownerDocument = this;\n        return textNode;\n      }\n    });\n\n    Object.defineProperty(Document, 'createDocumentFragment', {\n      value: function createDocumentFragment() {\n        var documentFragment = new DocumentFragment();\n        documentFragment.ownerDocument = this;\n        return documentFragment;\n      }\n    });\n  };\n\n  // Classes\n  var Element = function Element(tagName) {\n    this.nodeType = 1;\n    this.tagName = tagName;\n    this.parentNode = null;\n    this.nextSibling = null;\n    this.previousSibling = null;\n    this.attributes = {};\n  };\n\n  var Text = function Text(text) {\n    this.nodeType = 3;\n    this.textContent = text;\n    this.parentNode = null;\n    this.nextSibling = null;\n    this.previousSibling = null;\n  };\n\n  var DocumentFragment = function DocumentFragment() {\n    this.nodeType = 11;\n    this.childNodes = [];\n    this.childElementCount = 0;\n    this.children = [];\n    this.firstChild = null;\n    this.lastChild = null;\n    this.parentNode = null;\n    this.nextSibling = null;\n    this.previousSibling = null;\n  };\n}",
    term: "Document",
    explain:
      '\n\n//This code is creating a JavaScript class that can be used to represent the DOM document.\n\n//if (!Document): Checks if "Document" is not defined.\n\n//Document = function Document(): If not defined, it creates a constructor function called "Document".\n\n//this.nodeType = 9: Sets the "nodeType" property of the Document object to 9.\n\n//this.name = \'#document\': Sets the "name" property of the Document object to \'#document\'.\n\n//this.childNodes = []: Sets the "childNodes" property of the Document object to an empty array.\n\n//this.childElementCount = 0: Sets the "childElementCount" property of the Document object to 0.\n\n//this.children = []; Sets the "children" property of the Document object to an empty array.\n\n//this.firstChild = null: Sets the "firstChild" property of the Document object to null.\n\n//this.lastChild = null: Sets the "lastChild" property of the Document object to null.\n\n//this.documentElement = null: Sets the "documentElement" property of the Document object to null.\n\n//Object.defineProperty(Document, \'createElement\', {value: function createElement(tagName) {...}: Creates a new "createElement" method on the Document object which will take a tag name as an argument and return an Element object with the given tag name.\n\n//Object.defineProperty(Document, \'createTextNode\', {value: function createTextNode(text) {...}: Creates a new "createTextNode" method on the Document object which will take a string of text as an argument and return a Text object with the given text.\n\n//Object.defineProperty(Document, \'createDocumentFragment\', {value: function createDocumentFragment() {...}: Creates a new "createDocumentFragment" method on the Document object which will return a DocumentFragment object.\n\n//var Element = function Element(tagName): Creates a constructor function called "Element" which will take a tag name as an argument.\n\n//this.nodeType = 1: Sets the "nodeType" property of the Element object to 1.\n\n//this.tagName = tagName: Sets the "tagName" property of the Element object to the given tag name.\n\n//this.parentNode = null: Sets the "parentNode" property of the Element object to null.\n\n//this.nextSibling = null: Sets the "nextSibling" property of the Element object to null.\n\n//this.previousSibling = null: Sets the "previousSibling" property of the Element object to null.\n\n//this.attributes = {}: Sets the "attributes" property of the Element object to an empty object.\n\n//var Text = function Text(text): Creates a constructor function called "Text" which will take a string of text as an argument.\n\n//this.nodeType = 3: Sets the "nodeType" property of the Text object to 3.\n\n//this.textContent = text: Sets the "textContent" property of the Text object to the given text.\n\n//this.parentNode = null: Sets the "parentNode" property of the Text object to null.\n\n//this.nextSibling = null: Sets the "nextSibling" property of the Text object to null.\n\n//this.previousSibling = null: Sets the "previousSibling" property of the Text object to null.\n\n//var DocumentFragment = function DocumentFragment(): Creates a constructor function called "DocumentFragment".\n\n//this.nodeType = 11: Sets the "nodeType" property of the DocumentFragment object to 11.\n\n//this.childNodes = []: Sets the "childNodes" property of the DocumentFragment object to an empty array.\n\n//this.childElementCount = 0: Sets the "childElementCount" property of the DocumentFragment object to 0.\n\n//this.children = []; Sets the "children" property of the DocumentFragment object to an empty array.\n\n//this.firstChild = null: Sets the "firstChild" property of the DocumentFragment object to null.\n\n//this.lastChild = null: Sets the "lastChild" property of the DocumentFragment object to null.\n\n//this.parentNode = null: Sets the "parentNode" property of the DocumentFragment object to null.\n\n//this.nextSibling = null: Sets the "nextSibling" property of the DocumentFragment object to null.\n\n//this.previousSibling = null: Sets the "previousSibling" property of the DocumentFragment object to null.',
    useCase:
      "\n\nDocument is used in Javascript to access and manipulate the content of HTML and XML documents. It provides methods and properties to interact with elements on the page, such as accessing and modifying the HTML or XML document's content, attributes, or styling. Document also provides methods to create new elements and add them to the document, as well as methods for deleting, replacing, or inserting elements.",
  },
  {
    code: '\n\n(function () {\n    if (typeof window.DocumentFragment === "undefined") {\n        window.DocumentFragment = function DocumentFragment() {\n            var element = document.createElement("div");\n            element._children = [];\n\n            element.appendChild = function (child) {\n                var l = this._children.length;\n                this._children[l] = child;\n                this.appendChild = function (child) {\n                    var l = this._children.length;\n                    this._children[l] = child;\n                    return child;\n                };\n                return child;\n            };\n\n            element.querySelectorAll = function (selector) {\n                var result = [];\n                var els;\n                for (var i = 0; i < this._children.length; i++) {\n                    els = this._children[i].querySelectorAll(selector);\n                    for (var j = 0; j < els.length; j++) {\n                        result.push(els[j]);\n                    }\n                }\n                return result;\n            };\n\n            element.querySelector = function (selector) {\n                for (var i = 0; i < this._children.length; i++) {\n                    var el = this._children[i].querySelector(selector);\n                    if (el) {\n                        return el;\n                    }\n                }\n                return null;\n            };\n\n            element.cloneNode = function (deep) {\n                if (deep) {\n                    var clone = document.createDocumentFragment();\n                    for (var i = 0; i < this._children.length; i++) {\n                        clone.appendChild(this._children[i].cloneNode(true));\n                    }\n                    return clone;\n                }\n                else {\n                    return this;\n                }\n            };\n\n            return element;\n        };\n    }\n})();',
    term: "DocumentFragment",
    explain:
      '\n\n//This code creates a polyfill for DocumentFragment if it is undefined in the browser. \n\n//(function () {\n//This line creates an anonymous function that is immediately invoked. \n\n//    if (typeof window.DocumentFragment === "undefined") {\n//This line checks if the window object has a property called DocumentFragment that is undefined. \n\n//        window.DocumentFragment = function DocumentFragment() {\n//This line creates a new property called DocumentFragment on window that is a function.\n\n//            var element = document.createElement("div");\n//This line creates a new variable called element that is an empty div.\n\n//            element._children = [];\n//This line creates a new array on the element variable called _children. \n\n//            element.appendChild = function (child) {\n//This line adds a method called appendChild to the element variable that takes one argument called child. \n\n//                var l = this._children.length;\n//This line creates a new variable called l that is set to the length of the _children array. \n\n//                this._children[l] = child;\n//This line sets the last index of the _children array to the argument passed in. \n\n//                this.appendChild = function (child) {\n//This line adds a method called appendChild to the element variable that takes one argument called child. \n\n//                    var l = this._children.length;\n//This line creates a new variable called l that is set to the length of the _children array. \n\n//                    this._children[l] = child;\n//This line sets the last index of the _children array to the argument passed in. \n\n//                    return child;\n//This line returns the child argument. \n\n//                };\n//This line closes the appendChild function. \n\n//                return child;\n//This line returns the child argument. \n\n//            };\n//This line closes the appendChild method. \n\n//            element.querySelectorAll = function (selector) {\n//This line adds a method called querySelectorAll to the element variable that takes one argument called selector. \n\n//                var result = [];\n//This line creates a new array called result. \n\n//                var els;\n//This line creates a new variable called els. \n\n//                for (var i = 0; i < this._children.length; i++) {\n//This line loop through the _children array. \n\n//                    els = this._children[i].querySelectorAll(selector);\n//This line sets the els variable to an array of elements that match the selector argument. \n\n//                    for (var j = 0; j < els.length; j++) {\n//This line loop through the els array. \n\n//                        result.push(els[j]);\n//This line adds each element to the result array. \n\n//                    }\n//This line closes the loop. \n\n//                }\n//This line closes the loop.\n\n//                return result;\n//This line returns the result array. \n\n//            };\n//This line closes the querySelectorAll method.\n\n//            element.querySelector = function (selector) {\n//This line adds a method called querySelector to the element variable that takes one argument called selector. \n\n//                for (var i = 0; i < this._children.length; i++) {\n//This line loop through the _children array. \n\n//                    var el = this._children[i].querySelector(selector);\n//This line sets the el variable to the element that matches the selector argument. \n\n//                    if (el) {\n//This line checks if the el variable is truthy. \n\n//                        return el;\n//This line returns the el variable. \n\n//                    }\n//This line closes the if statement. \n\n//                }\n//This line closes the loop. \n\n//                return null;\n//This line returns null. \n\n//            };\n//This line closes the querySelector method. \n\n//            element.cloneNode = function (deep) {\n//This line adds a method called cloneNode to the element variable that takes one argument called deep. \n\n//                if (deep) {\n//This line checks if the deep argument is truthy.\n\n//                    var clone = document.createDocumentFragment();\n//This line creates a new variable called clone that is set to a new document fragment. \n\n//                    for (var i = 0; i < this._children.length; i++) {\n//This line loop through the _children array. \n\n//                        clone.appendChild(this._children[i].cloneNode(true));\n//This line adds a clone of each element in the _children array to the clone variable. \n\n//                    }\n//This line closes the loop. \n\n//                    return clone;\n//This line returns the clone variable. \n\n//                }\n//This line closes the if statement. \n\n//                else {\n//This line runs if the deep argument is falsy. \n\n//                    return this;\n//This line returns the element variable. \n\n//                }\n//This line closes the else statement. \n\n//            };\n//This line closes the cloneNode method. \n\n//            return element;\n//This line returns the element variable. \n\n//        };\n//This line closes the DocumentFragment function. \n\n//    }\n//This line closes the if statement. \n\n//})();\n//This line closes the anonymous function and immediately invokes it.',
    useCase:
      "\n\nDocumentFragment is a lightweight, transient DOM node that can be used to hold multiple DOM nodes. It is a useful tool when building dynamic web pages, as it allows the user to group multiple nodes together and make a single insertion into the DOM tree. DocumentFragment is also useful when dealing with large DOM trees, as it reduces the amount of repainting and reflowing required when making multiple DOM changes. It can also be used to reduce the amount of memory used when making multiple DOM modifications, since the DocumentFragment itself is not part of the actual DOM tree.",
  },
  {
    code: "\n\nif (!DocumentFragment.prototype.append) {\n  DocumentFragment.prototype.append = function(node) {\n    this.appendChild(node);\n  };\n}",
    term: "DocumentFragment.prototype.append",
    explain:
      "\n\n// 1. if (!DocumentFragment.prototype.append) { \n//     This line checks if DocumentFragment.prototype object has an 'append' property. \n\n// 2. DocumentFragment.prototype.append = function(node) {\n//     If the 'append' property doesn't exist, this line adds an 'append' property to the DocumentFragment.prototype object which is a function that takes a parameter called 'node'\n\n// 3. this.appendChild(node);\n//     This line calls the appendChild method of the DocumentFragment.prototype object, passing in the 'node' parameter as an argument.",
    useCase:
      "\n\nDocumentFragment.prototype.append is used in Javascript to efficiently add elements to a DocumentFragment. It is an easier and more efficient way of adding DOM elements to a DocumentFragment than manually creating each element and appending it. DocumentFragment.prototype.append allows developers to quickly add multiple elements to a DocumentFragment, which can then be added to the DOM. This makes it easier to manipulate the DOM and also helps to reduce the amount of code that needs to be written.",
  },
  {
    code: "\n\nif (!DocumentFragment.prototype.hasOwnProperty('prepend')) {\n  DocumentFragment.prototype.prepend = function () {\n    const args = [].slice.call(arguments);\n    const firstChild = this.firstChild;\n\n    args.forEach((arg) => {\n      if (arg instanceof Node) {\n        this.insertBefore(arg, firstChild);\n      } else if (typeof arg === 'string' || typeof arg === 'number') {\n        const node = document.createTextNode(arg);\n        this.insertBefore(node, firstChild);\n      } else {\n        throw new Error(\n          `Error: DocumentFragment.prototype.prepend() only accepts instances of Node or strings`\n        );\n      }\n    });\n  };\n}",
    term: "DocumentFragment.prototype.prepend",
    explain:
      "\n\n// Line 1: This line checks if the DocumentFragment prototype does not have the property 'prepend'.\n// Line 2: If the DocumentFragment prototype does not have the property 'prepend', this line creates a function called 'prepend' which is attached to the DocumentFragment prototype.\n// Line 3: This line creates an array called 'args' that contains all of the arguments passed to the 'prepend' function.\n// Line 4: This line creates a variable called 'firstChild' that holds a reference to the first child of the DocumentFragment.\n// Line 5: This line uses the 'forEach' method to iterate over all of the items in the 'args' array.\n// Line 6: This line checks if the current item in the 'args' array is an instance of the Node class.\n// Line 7: If the item is an instance of the Node class, this line inserts the node before the 'firstChild' of the DocumentFragment.\n// Line 8: This line checks if the current item in the 'args' array is a string or a number.\n// Line 9: If the item is a string or a number, this line creates a TextNode with the provided argument and inserts it before the 'firstChild' of the DocumentFragment.\n// Line 10: If the item is neither a Node instance nor a string/number, this line throws an error.",
    useCase:
      "\n\nDocumentFragment.prototype.prepend is used in Javascript to allow for the insertion of multiple elements into the DOM at once. This can be useful for performance when making multiple changes, as the browser only needs to perform a single DOM update. Additionally, this method allows developers to insert elements into the DOM before the start of the document, which can be useful in certain scenarios.",
  },
  {
    code: "\n\nif ( typeof Element !== 'function' ) {\n  Element = function( name ) {\n    this.name = name;\n  }\n\n  Element.prototype.render = function(){\n    return `<${this.name}></${this.name}>`;\n  }\n}",
    term: "Element",
    explain:
      "\n\n//This code checks to see if the Element function has been defined.\n//If not, it creates a new Element function with a parameter of name. \n//It then sets the prototype of the Element function to a render function, \n//which returns a string of the HTML element with the name passed in from the parameter.",
    useCase:
      "\n\nElement is used in JavaScript to access and manipulate HTML elements on a page. It enables developers to interact with the page’s Document Object Model (DOM) to make changes to the page’s structure, style, and content. With Element, developers can access specific HTML elements, change their attributes, and add and remove elements from the page. Element makes it easy to create complex web page interactions and animations.",
  },
  {
    code: "\n\n// Element.prototype.after\nif (!Element.prototype.after) {\n  Element.prototype.after = function(newNode) {\n    let nextSibling = this.nextSibling;\n    let parent = this.parentNode;\n    if (nextSibling) {\n      parent.insertBefore(newNode, nextSibling);\n    } else {\n      parent.appendChild(newNode);\n    }\n  };\n}",
    term: "Element.prototype.after",
    explain:
      "\n\n//Line 1: This line is creating a new property of Element, called after.\n//Line 2: This line checks to see if the after property already exists, and if it does not, it executes the code in the block.\n//Line 3: This line creates a new function called after and sets it to the after property of Element.\n//Line 4: This line creates a new variable called nextSibling to store the element's next sibling.\n//Line 5: This line creates a new variable called parent to store the element's parent node.\n//Line 6: This line checks to see if there is a next sibling. If there is, it executes the code in the block.\n//Line 7: This line inserts the newNode, before the nextSibling.\n//Line 8: This line is the else statement for line 6. If there is not a next sibling, it executes the code in the block.\n//Line 9: This line appends the newNode to the parent node.",
    useCase:
      "\n\nElement.prototype.after is used in JavaScript to insert a node or an HTML string after a specified element. This is useful when an element needs to be dynamically added to the DOM after an existing element. This method allows developers to quickly and easily add new elements to the DOM without having to write cumbersome code to locate the desired element and then locate the element after it.",
  },
  {
    code: '\n\n(function () {\n  // Check if the browser supports Element.prototype.animate\n  if (!Element.prototype.animate) {\n    // If not, add the prototype\n    Element.prototype.animate = function (keyframe, options) {\n      // Check if the keyframe argument is valid\n      if (!keyframe || typeof keyframe !== "object") {\n        throw new TypeError("First argument must be a valid object")\n      }\n\n      // Check if the options argument is valid\n      if (options && typeof options !== "object") {\n        throw new TypeError("Second argument must be a valid object")\n      }\n\n      // Create an animation\n      let animation = this.animate([], keyframe, options)\n\n      // Monitor the animation and dispatch events\n      return new Promise((resolve, reject) => {\n        animation.addEventListener(\'finish\', resolve)\n        animation.addEventListener(\'cancel\', reject)\n      })\n    }\n  }\n})();',
    term: "Element.prototype.animate",
    explain:
      '\n\n// (function () {\n// This line of code creates an anonymous self-executing function, meaning it will run immediately when the script is executed.\n\n//   if (!Element.prototype.animate) {\n// This line of code checks if the Element.prototype.animate method exists. If it does not exist, it will be added.\n\n//     Element.prototype.animate = function (keyframe, options) {\n// This line of code adds the Element.prototype.animate method to the Element prototype.\n\n//       if (!keyframe || typeof keyframe !== "object") {\n// This line of code checks if the keyframe argument is valid. If it is not valid, it will throw an error.\n\n//         throw new TypeError("First argument must be a valid object")\n// This line of code will throw an error if the keyframe argument is not valid.\n\n//       if (options && typeof options !== "object") {\n// This line of code checks if the options argument is valid. If it is not valid, it will throw an error.\n\n//         throw new TypeError("Second argument must be a valid object")\n// This line of code will throw an error if the options argument is not valid.\n\n//       let animation = this.animate([], keyframe, options)\n// This line of code creates an animation using the provided keyframe and options arguments.\n\n//       return new Promise((resolve, reject) => {\n// This line of code returns a new Promise object which will either resolve or reject based on the outcome of the animation.\n\n//         animation.addEventListener(\'finish\', resolve)\n// This line of code adds an event listener that will resolve the Promise if the animation finishes successfully.\n\n//         animation.addEventListener(\'cancel\', reject)\n// This line of code adds an event listener that will reject the Promise if the animation is cancelled.\n\n//       })\n// This line of code closes the Promise object.\n\n//     }\n// This line of code closes the Element.prototype.animate method.\n\n//   }\n// This line of code closes the if statement.\n\n// })();\n// This line of code closes the anonymous self-executing function.',
    useCase:
      "\n\nElement.prototype.animate is used to animate HTML elements in Javascript. It allows for the animation of specific properties of an element, such as its size, position, color, or opacity. It is a powerful tool for creating interactive, dynamic, and animated web experiences. It also gives developers the ability to create highly-customizable animations with just a few lines of code.",
  },
  {
    code: '\n\nif (!Element.prototype.append) {\n  Element.prototype.append = function append(children) {\n    if (children == null) {\n      return;\n    }\n    if (typeof children === "string") {\n      this.insertAdjacentHTML("beforeend", children);\n    } else {\n      if (Array.isArray(children)) {\n        for (var i = 0; i < children.length; i++) {\n          this.append(children[i]);\n        }\n      } else {\n        this.appendChild(children);\n      }\n    }\n  };\n}',
    term: "Element.prototype.append",
    explain:
      "\n\n// Line 1: \n// This line checks to see if the append method already exists in the Element prototype. If it doesn't, the code inside the if statement will execute.\n\n// Line 2: \n// This line adds the append method to the Element prototype.\n\n// Line 3: \n// This line checks to see if the children argument passed to the append method is null. If it is, the code inside the if statement will execute, which is to return without doing anything.\n\n// Line 4: \n// This line checks to see if the children argument passed to the append method is a string. If it is, the code inside the if statement will execute, which is to insert the HTML into the element before the end.\n\n// Line 5: \n// This line checks to see if the children argument passed to the append method is an array. If it is, the code inside the if statement will execute, which is to loop through the array and append each element to the element.\n\n// Line 6: \n// This line is the else clause to the previous if statement. It will execute if the children argument passed to the append method is not an array. The code inside the if statement will execute, which is to append the child element to the element.",
    useCase:
      "\n\nElement.prototype.append is used in Javascript to add an element to the end of a parent element. This is useful for creating and manipulating a dynamic HTML structure. It can also be used to insert content from other sources, such as text nodes, HTML strings, and document fragments. By using Element.prototype.append, developers can quickly and easily add elements to the DOM without having to hard-code them into the HTML.",
  },
  {
    code: "\n\n// Create a function Element.prototype.before\nElement.prototype.before = function(newElement){\n    // Store the element before which newElement is to be inserted\n    let currentElement = this;\n\t\n    // If the element has a parent node\n    if (currentElement.parentNode) {\n        // Store the parent node\n        let parentNode = currentElement.parentNode;\n        \n        // If the element has a previous sibling\n        if (currentElement.previousSibling){\n            // Insert the newElement before the currentElement's previous sibling\n            parentNode.insertBefore(newElement, currentElement.previousSibling);\n        } else {\n            // Otherwise, insert the newElement at the beginning of the parentNode\n            parentNode.insertBefore(newElement, currentElement);\n        }\n    }\n};",
    term: "Element.prototype.before",
    explain:
      "\n\n// This code creates a function, Element.prototype.before, which inserts an element before the current element.\n\n// 1. Create a function Element.prototype.before: This line creates a function called Element.prototype.before which will be used to insert an element before the current element.\n\n// 2. let currentElement = this: This line stores the element before which the new element will be inserted.\n\n// 3. if (currentElement.parentNode): This line checks if the element has a parent node.\n\n// 4. let parentNode = currentElement.parentNode: This line stores the parent node of the current element.\n\n// 5. if (currentElement.previousSibling): This line checks if the element has a previous sibling.\n\n// 6. parentNode.insertBefore(newElement, currentElement.previousSibling): If the element has a previous sibling, this line inserts the new element before the current element's previous sibling.\n\n// 7. parentNode.insertBefore(newElement, currentElement): Otherwise, this line inserts the new element at the beginning of the parent node.",
    useCase:
      "\n\nElement.prototype.before is used in Javascript to insert a node before the specified element. This method can be used to add new elements before an existing element in the DOM tree without having to remove the existing element. This makes it easier and faster to update the DOM tree.",
  },
  {
    code: "\n\nif (!Element.prototype.classList) {\n    Element.prototype.classList = {\n        add: function (className) {\n            if (!this.className.includes(className)) {\n                this.className += ' ' + className;\n            }\n        },\n        remove: function (className) {\n            if (this.className.includes(className)) {\n                this.className = this.className.replace(className, '').trim();\n            }\n        },\n        toggle: function (className) {\n            if (this.className.includes(className)) {\n                this.className = this.className.replace(className, '').trim();\n            } else {\n                this.className += ' ' + className;\n            }\n        },\n        contains: function (className) {\n            return this.className.includes(className);\n        }\n    };\n}",
    term: "Element.prototype.classList",
    explain:
      "\n\n// Line 1: This line checks whether the Element.prototype.classList is available or not.\n// Line 2: If Element.prototype.classList is not available then it adds the classList object to the Element.prototype.\n// Line 3: This line adds the className to the Element.prototype.classList object if it does not present.\n// Line 4: This line removes the className from the Element.prototype.classList object if it is present.\n// Line 5: This line checks if the className is present in the Element.prototype.classList object and if it is present then it will remove the className from the list.\n// Line 6: This line checks if the className is present in the Element.prototype.classList object and if it is not present then it will add the className to the list.\n// Line 7: This line checks if the className is present in the Element.prototype.classList object and return a boolean value.",
    useCase:
      "\n\nElement.prototype.classList is used in Javascript to provide an easy way to access and manipulate the list of classes for an element. It allows developers to add, remove, toggle and check for the presence of classes on an element. This is useful for quickly changing the styles of an element by adding, removing or toggling a class. It helps to keep code clean and maintainable by avoiding the need to use string manipulation to access and modify the list of classes.",
  },
  {
    code: "\n\nif (!Element.prototype.cloneNode) {\n  Element.prototype.cloneNode = function (deep) {\n    let newClone = this.cloneNode.call(this, deep);\n\n    let attrs = this.attributes;\n    if (attrs) {\n      for (let i = 0; i < attrs.length; i++) {\n        let attr = attrs[i];\n        newClone.setAttribute(attr.name, attr.value);\n      }\n    }\n\n    return newClone;\n  };\n}",
    term: "Element.prototype.cloneNode",
    explain:
      "\n\n//Line 1: This line checks to see if the Element.prototype.cloneNode method is not defined.\n//Line 2: If the Element.prototype.cloneNode is not defined, this line creates the method and provides a function to clone the node.\n//Line 3: This line creates a new clone of the node using the cloneNode.call method.\n//Line 4: This line creates a variable to store the attributes of the node.\n//Line 5: This line checks to see if the node has any attributes.\n//Line 6: This line creates a loop to iterate through the attributes of the node.\n//Line 7: This line creates a variable to store a single attribute.\n//Line 8: This line sets the attribute of the new clone to the value of the attribute from the original node.\n//Line 9: This line returns the newly cloned node.",
    useCase:
      "\n\nElement.prototype.cloneNode is used in Javascript to create a duplicate of an existing element and its children. This allows developers to easily create copies of elements with all the same attributes, styles, and event handlers. It can also be used to quickly create multiple elements with the same properties without having to manually define each one. It is a useful tool for manipulating the DOM, creating custom elements, and reducing the amount of code required to achieve a given effect.",
  },
  {
    code: "\n\nif (window.Element && !Element.prototype.closest) {\n    // Element.prototype.closest\n    Element.prototype.closest = \n    function(s) {\n        var el = this;\n        var ancestor = this;\n        if (!document.documentElement.contains(el)) return null;\n        do {\n            if (ancestor.matches(s)) return ancestor;\n            ancestor = ancestor.parentElement;\n        } while (ancestor !== null); \n        return null;\n    };\n}",
    term: "Element.prototype.closest",
    explain:
      "\n\n// Line 1: This line checks if the window object has the Element constructor and if the Element prototype does not have the closest method. \n// Line 2: This line adds a closest method to the Element prototype.\n// Line 3: This line sets a variable el to the current element.\n// Line 4: This line sets a variable ancestor to the current element.\n// Line 5: This line checks if the document element does not contain the current element and returns null if it does not.\n// Line 6: This line loops through the ancestors of the current element and checks for a matching selector. If a match is found, it returns the ancestor.\n// Line 7: This line updates the ancestor to the parent element.\n// Line 8: This line checks if the ancestor is not null and continues looping until the ancestor is null.\n// Line 9: This line returns null if no matching selector is found.",
    useCase:
      "\n\nElement.prototype.closest() is used in Javascript to find the closest ancestor of the current element that matches the specified selector, including itself. This method is useful for traversing up the DOM tree to find the closest matching ancestor for a given element. It can be used in situations where you need to find the closest parent of an element that matches a certain criteria, such as a particular class, ID, or attribute.",
  },
  {
    code: "\n\nif (Element.prototype.dataset === undefined) {\n  Element.prototype.dataset = {};\n  Object.defineProperty(Element.prototype, 'dataset', {\n    get: function () {\n      let element = this;\n      let attributes = this.attributes;\n      let map = {};\n      for (let i = 0; i < attributes.length; i++) {\n        let attribute = attributes[i];\n        if (attribute.name.substring(0, 5) === 'data-') {\n          let key = attribute.name.substring(5);\n          let value = attribute.value;\n          map[key] = value;\n        }\n      }\n      Object.defineProperty(element, 'dataset', {\n        value: map,\n        writable: true,\n        enumerable: true\n      });\n      return map;\n    }\n  });\n}",
    term: "Element.prototype.dataset",
    explain:
      '\n\n// Line 1: This line checks if the Element.prototype.dataset property is undefined. \n// Line 2: If it is, it is set to an empty object. \n// Line 3: This line sets the Element.prototype.dataset property to a getter function. \n// Line 4: This declares a variable to store the element being tested.\n// Line 5: This line declares a variable to store the attributes of the element.\n// Line 6: This line declares a variable to store the map of data-* attributes. \n// Line 7-10: This loop iterates through the attributes and checks if the attribute name starts with "data-". If it does, it adds the data to the map.\n// Line 11-14: This line defines the dataset property on the element with the value of the map, and makes it writable and enumerable. \n// Line 15: This returns the map of data-* attributes.',
    useCase:
      "\n\nElement.prototype.dataset is used to allow developers to store custom data on DOM elements. It provides a simple way to access and manipulate that data, making it easier to create dynamic webpages and applications. This feature is especially useful when working with HTML5 data attributes, as it allows developers to store and access custom data in a structured way.",
  },
  {
    code: "\n\nif (!Element.prototype.getAttributeNames) {\n    Element.prototype.getAttributeNames = function () {\n        let attrs = [];\n        for (let i = 0; i < this.attributes.length; i++) {\n            attrs.push(this.attributes[i].name);\n        }\n        return attrs;\n    };\n}",
    term: "Element.prototype.getAttributeNames",
    explain:
      "\n\n// Line 1: This line checks if the Element prototype doesn't already have a getAttributeNames() function. \n// If it doesn't, the code inside the if statement will be executed.\n\n// Line 2: This line defines a new function called getAttributeNames() that will be added to the Element prototype. \n\n// Line 3: This line declares an empty array called attrs that will be used to store the names of the element's attributes.\n\n// Line 4: This line uses a for loop to loop through all of the element's attributes.\n\n// Line 5: This line adds the name of the current attribute to the attrs array.\n\n// Line 6: This line returns the attrs array when the loop is finished.\n\n// Line 7: This line closes the if statement.",
    useCase:
      "\n\nElement.prototype.getAttributeNames is used in JavaScript to retrieve a list of all the attribute names of an element. This is useful for finding out what attributes are available for a particular element, as well as for iterating through the list and retrieving each attribute's value. It can also be used to check whether a specific attribute is present on an element or not.",
  },
  {
    code: "\n\n/**\n * Polyfill for Element.prototype.inert\n */\n(() => {\n  if ('inert' in Object.getOwnPropertyDescriptors(Element.prototype)) {\n    return;\n  }\n\n  /**\n   * Sets the Inert property of the HTMLElement\n   */\n  Object.defineProperty(Element.prototype, 'inert', {\n    enumerable: true,\n    configurable: true,\n    get() {\n      return this.hasAttribute('inert');\n    },\n    set(val) {\n      if (val) {\n        this.setAttribute('inert', '');\n      } else {\n        this.removeAttribute('inert');\n      }\n    }\n  });\n})();",
    term: "Element.prototype.inert",
    explain:
      "\n\n// Line 1: This line declares a function that is immediately invoked. This is a polyfill for Element.prototype.inert, which is used to enable or disable the ability of an element to be interacted with.\n\n// Line 4: This line checks if the 'inert' property already exists in the Element.prototype object. If it does, the function returns and does nothing.\n\n// Line 9: This line uses the Object.defineProperty() method to define the 'inert' property on the Element.prototype object. \n\n// Line 10: This line sets the enumerability of the 'inert' property to true.\n\n// Line 11: This line sets the configurability of the 'inert' property to true.\n\n// Line 12: This line defines a getter method for the 'inert' property. This getter method checks if the element has an 'inert' attribute.\n\n// Line 16: This line defines a setter method for the 'inert' property. This setter method adds or removes the 'inert' attribute depending on the value passed to the property.",
    useCase:
      "\n\nElement.prototype.inert is used to make an element on a web page unresponsive to user input, such as mouse clicks, keystrokes, or focus. This can be useful for creating UI elements that are not meant to be interacted with, or for making certain elements inaccessible under certain circumstances.",
  },
  {
    code: "\n\nif (!Element.prototype.matches) {\n\tElement.prototype.matches = \n\t\tElement.prototype.matchesSelector || \n\t\tElement.prototype.mozMatchesSelector ||\n\t\tElement.prototype.msMatchesSelector || \n\t\tElement.prototype.oMatchesSelector || \n\t\tElement.prototype.webkitMatchesSelector ||\n\t\tfunction(s) {\n\t\t\tvar matches = (this.document || this.ownerDocument).querySelectorAll(s);\n\t\t\tvar i = matches.length;\n\t\t\twhile (--i >= 0 && matches.item(i) !== this) {}\n\t\t\treturn i > -1;            \n\t\t};\n}",
    term: "Element.prototype.matches",
    explain:
      "\n\n//If the Element.prototype object does not have a 'matches' property\n// then add the 'matches' property to the Element.prototype \n//and assign it a function that checks if the Element matches \n//one of the other Element prototype properties (matchesSelector, mozMatchesSelector, msMatchesSelector, oMatchesSelector, or webkitMatchesSelector)\n//If none of the other Element prototype properties match the specified selector, \n//query the document or the ownerDocument for any elements matching the selector \n// and check if the Element matches the queried elements. \n//If the Element does match one of the queried elements, return true, otherwise return false.",
    useCase:
      "\n\nElement.prototype.matches is used in Javascript to determine if an element matches a selector. This is especially useful when trying to identify if a particular element matches a given selector without having to manually check each of its attributes. It is also useful for finding elements within a given document that match a certain selector.",
  },
  {
    code: "\n\nif (!Element.prototype.nextElementSibling) {\n    Element.prototype.nextElementSibling = function() {\n        let currentElement = this;\n        do {\n            currentElement = currentElement.nextSibling;\n        } while (currentElement && currentElement.nodeType !== 1);\n        return currentElement;\n    }\n}",
    term: "Element.prototype.nextElementSibling",
    explain:
      "\n\n// if (!Element.prototype.nextElementSibling): This line checks to see if the nextElementSibling property already exists on the Element prototype.\n\n// Element.prototype.nextElementSibling = function(): If the property does not already exist, this line defines a new function named nextElementSibling on the Element prototype.\n\n// let currentElement = this: This line creates a local variable named currentElement and sets it equal to the current element.\n\n// do { currentElement = currentElement.nextSibling: This line runs a loop that assigns the value of the nextSibling property of the currentElement to the currentElement variable.\n\n// } while (currentElement && currentElement.nodeType !== 1): This line checks the condition that the currentElement is not null and the nodeType of the currentElement is not equal to 1.\n\n// return currentElement: This line returns the value of the currentElement variable.",
    useCase:
      "\n\nElement.prototype.nextElementSibling is used to access the next element sibling of the given element. This is useful for traversing the DOM and manipulating siblings. It can be used to add or remove classes, or insert and delete elements from sibling elements. It also makes it easier to select and manipulate elements in a parent element.",
  },
  {
    code: '\n\n// Create a placeholder property for Element prototype\nElement.prototype.placeholder = {};\n\n// Create a getter for placeholder property\nObject.defineProperty(Element.prototype, "placeholder", {\n  get: function() {\n    // Get placeholder value from element\'s data-placeholder attribute\n    var attrPlaceholder = this.getAttribute("data-placeholder");\n\n    // If data-placeholder attribute is present, return its value\n    if (attrPlaceholder) {\n      return attrPlaceholder;\n    }\n\n    // Otherwise, return empty string\n    return "";\n  },\n  // Make placeholder property read-only\n  configurable: false\n});',
    term: "Element.prototype.placeholder",
    explain:
      "\n\n// This code creates a placeholder property on the Element prototype, which is the base prototype for all HTML elements. It creates a getter for this property which retrieves the value of the element's data-placeholder attribute. If the data-placeholder attribute is present, its value is returned, otherwise an empty string is returned. Finally, the placeholder property is made read-only.",
    useCase:
      "\n\nElement.prototype.placeholder is used to set or return the value of the placeholder attribute of an element. It allows developers to set a predefined value in an input field, which can then be replaced with user input when the field is interacted with. This can be useful for prompting users to enter information in the correct format, such as a phone number or email address.",
  },
  {
    code: "\n\nif (!Element.prototype.prepend) {\n  Element.prototype.prepend = function(el) {\n    let firstChild = this.firstChild;\n    this.insertBefore(el, firstChild);\n  };\n}",
    term: "Element.prototype.prepend",
    explain:
      '\n\n//Line 1: This line checks to see if the Element.prototype object already has a method called "prepend". If it does not, the code block that follows will execute.\n\n//Line 2: A new function is added as a method to Element.prototype called "prepend". The argument "el" will be used when this method is called.\n\n//Line 3: A variable called "firstChild" is declared, and is assigned the value of the first child of the element that calls this method.\n\n//Line 4: The method "insertBefore" is called on the element that calls the "prepend" method. This method takes two arguments, the first being the element to be inserted and the second being the element that it should be inserted before. In this case, the "el" argument passed to the "prepend" method is inserted before the "firstChild" variable.',
    useCase:
      "\n\nElement.prototype.prepend is used in Javascript to insert a node as the first child of a specified element. This is useful for adding new elements to the beginning of a page or rearranging existing elements. It is also useful for adding text to existing elements, as it allows text to be added to the beginning of an element instead of only at the end.",
  },
  {
    code: "\n\nif (!Object.prototype.hasOwnProperty.call(Element.prototype, 'previousElementSibling')) {\n    Object.defineProperty(Element.prototype, 'previousElementSibling', {\n        get() {\n            let currentNode = this.previousSibling;\n            do {\n                if (currentNode.nodeType === 1) {\n                    return currentNode;\n                }\n                currentNode = currentNode.previousSibling;\n            }\n            while (currentNode);\n        }\n    });\n}",
    term: "Element.prototype.previousElementSibling",
    explain:
      "\n\n//Line 1: This line checks if the Object prototype does not have a property called 'previousElementSibling'. \n//Line 2: If it does not, then the Object.defineProperty method is used to define a new property on the Element prototype object called 'previousElementSibling' and set it as a getter.\n//Line 3: This line sets the currentNode variable to the previousSibling of the element.\n//Line 4: This line is a do-while loop that will run until the currentNode variable is falsey.\n//Line 5: This line checks if the nodeType of the currentNode is equal to 1. If it is, then it will return the currentNode.\n//Line 6: This line sets the currentNode variable to the previousSibling of the currentNode.\n//Line 7: This line closes the do-while loop. \n//Line 8: This line closes the Object.defineProperty method.\n//Line 9: This line closes the if statement.",
    useCase:
      "\n\nElement.prototype.previousElementSibling is used to access the element that immediately precedes the specified element in the same tree level. It is useful for manipulating the DOM, as it allows developers to quickly traverse the DOM tree and manipulate elements in a specific order.",
  },
  {
    code: "\n\nif (!Element.prototype.remove) {\n  Element.prototype.remove = function() {\n    if (this.parentElement) {\n      this.parentElement.removeChild(this);\n    }\n  };\n}",
    term: "Element.prototype.remove",
    explain:
      "\n\n// Line 1: This line checks to see if the Element prototype object does not have the remove method. \n// Line 2: If the Element prototype object does not have the remove method, this line adds a remove method to the Element prototype object. \n// Line 3: This line checks to see if the element has a parent element.\n// Line 4: If the element does have a parent element, this line removes the element from its parent element.",
    useCase:
      "\n\nElement.prototype.remove is used in Javascript to remove an element from the DOM (Document Object Model). It is a convenient way to remove elements from the DOM without having to search for them using other methods such as querySelector or getElementById.",
  },
  {
    code: "\n\nif (!Element.prototype.replaceWith) {\n  Element.prototype.replaceWith = function(newNode) {\n    this.parentNode.replaceChild(newNode, this);\n  };\n}",
    term: "Element.prototype.replaceWith",
    explain:
      "\n\n// Line 1: This line checks if the Element prototype already has a replaceWith function.\n// Line 2: If the Element prototype does not have a replaceWith function, a new one is created.\n// Line 3: This line defines the new replaceWith function created. It takes one argument, newNode, and replaces the current element with the newNode.\n// Line 4: This line calls the replaceChild function on the parentNode of the current element, and passes in the newNode and the current element as arguments.",
    useCase:
      "\n\nElement.prototype.replaceWith is used in Javascript to replace an element in the DOM with a new element. This is often used to update the content of a page without having to reload the entire page. It can also be used to replace an element in the DOM with an entirely different type of element, making it a powerful tool for transforming a page on the fly.",
  },
  {
    code: "\n\n//Create a polyfill of Element.prototype.scroll\nif (Element.prototype.scroll === undefined) {\n    Element.prototype.scroll = function(x, y) {\n        //Check that x and y are valid numbers\n        if (typeof x === 'number' && typeof y === 'number') {\n            if (this.nodeType === 1) {\n                this.scrollLeft = x;\n                this.scrollTop = y;\n            }\n        }\n    };\n}",
    term: "Element.prototype.scroll",
    explain:
      "\n\n//Line 1: \n//This line creates a polyfill of Element.prototype.scroll. A polyfill is a piece of code that provides the technology that is missing from the browser.\n\n//Line 2: \n//This line checks whether Element.prototype.scroll is undefined. If it is, then the code within the if statement is executed.\n\n//Line 3: \n//This line creates a new function called scroll, which takes two parameters, x and y.\n\n//Line 4: \n//This line checks whether the parameters x and y are valid numbers. If they are, then the code within the if statement is executed.\n\n//Line 5: \n//This line checks whether the element is a node type 1. If it is, then the code within the if statement is executed.\n\n//Line 6 & 7: \n//These lines set the scrollLeft and scrollTop properties of the element to the values of x and y, respectively.",
    useCase:
      "\n\nElement.prototype.scroll is used in Javascript to scroll the content of an element horizontally or vertically. This method can be used to quickly scroll an element to the top, bottom, left, or right of its scrollable area. Additionally, it can be used to scroll an element to a specific position or to scroll an element by a certain amount. This method is useful for creating smooth scrolling effects or for quickly adjusting the scroll position of an element.",
  },
  {
    code: "\n\nif (!Element.prototype.scrollBy) {\n  Element.prototype.scrollBy = function(x, y) {\n    this.scrollLeft += x;\n    this.scrollTop += y;\n  };\n}",
    term: "Element.prototype.scrollBy",
    explain:
      "\n\n// Line 1: This checks to see if the scrollBy method is already defined on the Element prototype. If not, the code inside the if statement will be executed.\n\n// Line 2: This defines a scrollBy method on the Element prototype.\n\n// Line 3: This sets the scrollLeft property of the element to what it was before plus the value of x.\n\n// Line 4: This sets the scrollTop property of the element to what it was before plus the value of y.",
    useCase:
      "\n\nElement.prototype.scrollBy is used in JavaScript to scroll an element by a specified number of pixels. It can be used to scroll the page by a certain number of pixels, or to scroll a particular element by a certain number of pixels. It can be used to create smooth scrolling animations or to automatically scroll an element into view. It can also be used to scroll an element to the top or bottom of its scrollable area.",
  },
  {
    code: "\n\nif (!Element.prototype.scrollIntoView) {\n  // Get the top-level document object\n  var d = window.document;\n  // determine the current scroll position\n  function scrollY() {\n    var y;\n    if (window.pageYOffset) y = window.pageYOffset;\n    else if (d.documentElement && d.documentElement.scrollTop) y = d.documentElement.scrollTop;\n    else if (d.body) y = d.body.scrollTop;\n    return y;\n  }\n  // determine the current horizontal scroll position\n  function scrollX() {\n    var x;\n    if (window.pageXOffset) x = window.pageXOffset;\n    else if (d.documentElement && d.documentElement.scrollLeft) x = d.documentElement.scrollLeft;\n    else if (d.body) x = d.body.scrollLeft;\n    return x;\n  }\n  // Scroll the document\n  Element.prototype.scrollIntoView = function(){\n    // the element's bounding rectangle\n    var rect = this.getBoundingClientRect();\n    // the base scroll position\n    var sx = scrollX();\n    var sy = scrollY();\n    // the current viewport size\n    var vw = window.innerWidth;\n    var vh = window.innerHeight;\n    // the element's size, relative to the viewport\n    var tw = rect.width;\n    var th = rect.height;\n    // the calculated target scroll position\n    var tx = sx + rect.left;\n    var ty = sy + rect.top;\n    // the threshold for when the element should be aligned to the top of the viewport\n    var thresh = th - vh;\n    // adjust the target scroll position if necessary\n    if (ty > sy + thresh) ty = sy + thresh;\n    if (tx + tw > sx + vw) tx = sx + vw - tw;\n    // scroll the element into view\n    window.scrollTo(tx, ty);\n  };\n}",
    term: "Element.prototype.scrollIntoView",
    explain:
      "\n\n//Line 1: This line checks if the scrollIntoView prototype method exists on the Element object. If it does not exist, it will create the method. \n//Line 2: This line stores the top-level document object in the d variable.\n//Line 3: This line creates a function that determines the current vertical scroll position. \n//Line 4: This line checks if the pageYOffset property of the window object is set. If it is, it stores the value in the y variable.\n//Line 5: This line checks if the documentElement property of the document object is set and if the scrollTop property of the documentElement is set. If both are set, it stores the value in the y variable.\n//Line 6: This line checks if the body property of the document object is set. If it is, it stores the value in the y variable.\n//Line 7: This line returns the value stored in the y variable.\n//Line 8: This line creates a function that determines the current horizontal scroll position. \n//Line 9: This line checks if the pageXOffset property of the window object is set. If it is, it stores the value in the x variable.\n//Line 10: This line checks if the documentElement property of the document object is set and if the scrollLeft property of the documentElement is set. If both are set, it stores the value in the x variable.\n//Line 11: This line checks if the body property of the document object is set. If it is, it stores the value in the x variable.\n//Line 12: This line returns the value stored in the x variable.\n//Line 13: This line creates the scrollIntoView method on the Element prototype.\n//Line 14: This line stores the bounding rectangle of the element in the rect variable.\n//Line 15: This line stores the current horizontal scroll position in the sx variable.\n//Line 16: This line stores the current vertical scroll position in the sy variable.\n//Line 17: This line stores the width of the current viewport in the vw variable.\n//Line 18: This line stores the height of the current viewport in the vh variable.\n//Line 19: This line stores the width of the element, relative to the viewport, in the tw variable.\n//Line 20: This line stores the height of the element, relative to the viewport, in the th variable.\n//Line 21: This line stores the calculated target scroll position in the tx variable.\n//Line 22: This line stores the calculated target scroll position in the ty variable.\n//Line 23: This line stores the threshold for when the element should be aligned to the top of the viewport in the thresh variable.\n//Line 24: This line checks if the ty variable is greater than the sy variable plus the thresh variable. If it is, it sets the ty variable to the sy variable plus the thresh variable.\n//Line 25: This line checks if the tx variable plus the tw variable is greater than the sx variable plus the vw variable. If it is, it sets the tx variable to the sx variable plus the vw variable minus the tw variable.\n//Line 26: This line scrolls the element into view by calling the window.scrollTo() method with the tx and ty variables as arguments.",
    useCase:
      "\n\nElement.prototype.scrollIntoView is used in JavaScript to bring the element into the visible area of the browser window. It is a useful method when you want to ensure that a particular element is visible on the page, and can be used to scroll the element into the viewport when it is not currently visible. It can also be used in combination with other JavaScript functions to create a smooth scrolling effect.",
  },
  {
    code: "\n\nif(!Element.prototype.toggleAttribute) {\n  Element.prototype.toggleAttribute = function (name, force){\n    var val = this.getAttribute(name);\n    if(force === undefined) {\n      if (val === null){\n        this.setAttribute(name, '');\n        return true;\n      } else {\n        this.removeAttribute(name);\n        return false;\n      }\n    } else if (force) {\n      this.setAttribute(name, '');\n      return true;\n    } else {\n      this.removeAttribute(name);\n      return false;\n    }\n  };\n}",
    term: "Element.prototype.toggleAttribute",
    explain:
      "\n\n//Line 1: \n// This line checks if the Element.prototype.toggleAttribute function has been defined. \n\n//Line 2: \n// If the function has not been defined, the function is defined in the following lines.\n\n//Line 3: \n// This line creates a variable called 'val' that stores the value of the attribute with the name passed in as an argument.\n\n//Line 4: \n// This line checks if no 'force' argument was passed in. \n\n//Line 5: \n// If no 'force' argument was passed in, and the value of the attribute was null, then the attribute is set to an empty string and the function returns true.\n\n//Line 6: \n// If no 'force' argument was passed in, and the value of the attribute was not null, then the attribute is removed and the function returns false.\n\n//Line 7: \n// If a 'force' argument was passed in, and it is true, then the attribute is set to an empty string and the function returns true.\n\n//Line 8: \n// If a 'force' argument was passed in, and it is false, then the attribute is removed and the function returns false.",
    useCase:
      "\n\nElement.prototype.toggleAttribute is used in Javascript to enable an element to be toggled between two states. This method allows developers to quickly and easily switch an element between two states without having to manually set each state. By using toggleAttribute, developers can create a one-click toggle for elements, such as a checkbox or a switch. This method is particularly useful when creating complex user interfaces, as it makes it easier to quickly toggle between two different states.",
  },
  {
    code: "\n\n// Polyfill for Event in Javascript\nif (!window.Event) {\n  function Event(event, params) {\n    params = params || { bubbles: false, cancelable: false, detail: null };\n    const evt = document.createEvent('Event');\n    evt.initEvent(event, params.bubbles, params.cancelable, params.detail);\n    return evt;\n  }\n  window.Event = Event;\n}",
    term: "Event",
    explain:
      "\n\n//This line of code checks if the window object has an Event property. If it does not, then it creates a custom Event function. \nif (!window.Event) {\n\n//This line of code defines the Event function and gives it two parameters, event and params. The params parameter is optional and allows for additional parameters such as bubbling and cancelable. \n  function Event(event, params) {\n\n//This line of code sets the default values for the params parameter.\n    params = params || { bubbles: false, cancelable: false, detail: null };\n\n//This line of code creates a new event object.\n    const evt = document.createEvent('Event');\n\n//This line of code initializes the event object with the provided parameters.\n    evt.initEvent(event, params.bubbles, params.cancelable, params.detail);\n\n//This line of code returns the newly created event.\n    return evt;\n  }\n\n//This line of code assigns the Event function to the window object.\n  window.Event = Event;\n}",
    useCase:
      "\n\nEvent is used in Javascript to allow code to be executed when certain types of events occur in the browser window, such as when a user clicks a button, scrolls the page, or moves the mouse over an element. By using Event, developers can create interactive web applications that respond to user actions.",
  },
  {
    code: '\n\nif (!("focusin" in Event.prototype)) {\n  Object.defineProperty(Event.prototype, "focusin", {\n    configurable: true,\n    enumerable: true,\n    get() {\n      return this._focusin || (this.type === "focusin");\n    },\n    set(value) {\n      Object.defineProperty(this, "_focusin", { value });\n    },\n  });\n}',
    term: "Event.focusin",
    explain:
      '\n\n// Line 1: \n// This line checks if "focusin" is not a property of Event.prototype. \n\n// Line 2: \n// This line defines a new property "focusin" on the Event.prototype object.\n\n// Line 3-7: \n// These lines set the configurable, enumerable, get, and set functions for the "focusin" property. The get function checks if the type property of the event is equal to "focusin". The set function sets the value of the _focusin property.',
    useCase:
      "\n\nEvent.focusin is used in Javascript to detect when an element receives focus. This event is typically used to trigger an action when the user focuses on a specific form element or other interactive element on a page. It can be used to customize the user experience by delaying or preventing certain actions until a user is focused on a specific element.",
  },
  {
    code: "\n\n(function () {\n  let hash = window.location.hash;\n  if (hash === '') {\n    hash = '#';\n  }\n  const oldHash = hash;\n  \n  let delay = 250;\n  let pollingInterval;\n  \n  window.onhashchange = function (e) {\n    if (oldHash !== e.newURL.split('#')[1]) {\n      let event = new Event('hashchange');\n      event.oldURL = oldHash;\n      event.newURL = e.newURL;\n      window.dispatchEvent(event);\n    }\n    oldHash = e.newURL.split('#')[1];\n  };\n  \n  const pollHash = function () {\n    if (window.location.hash !== hash) {\n      hash = window.location.hash;\n      window.onhashchange({\n        newURL: window.location.href\n      });\n    }\n  };\n  \n  pollHash();\n  pollingInterval = window.setInterval(pollHash, delay);\n  \n  if (typeof window.addEventListener === 'function') {\n    window.addEventListener('beforeunload', function () {\n      window.clearInterval(pollingInterval);\n    }, false);\n  }\n  \n})();",
    term: "Event.hashchange",
    explain:
      "\n\n//(function () {\n//  Creates an anonymous function \n\n//  let hash = window.location.hash;\n//  Sets the variable 'hash' to the current window location hash\n\n//  if (hash === '') {\n//    hash = '#';\n//  }\n//  Checks if the variable 'hash' is empty, if it is sets it to '#'\n\n//  const oldHash = hash;\n//  Sets the constant variable 'oldHash' to the value of 'hash'\n\n//  let delay = 250;\n//  let pollingInterval;\n//  Sets the variable 'delay' to 250 and creates an empty variable 'pollingInterval'\n\n//  window.onhashchange = function (e) {\n//    if (oldHash !== e.newURL.split('#')[1]) {\n//      let event = new Event('hashchange');\n//      event.oldURL = oldHash;\n//      event.newURL = e.newURL;\n//      window.dispatchEvent(event);\n//    }\n//    oldHash = e.newURL.split('#')[1];\n//  };\n//  Creates an event listener for when the hash is changed, checks to see if the old hash is different, if it is creates a new event called 'hashchange' and sets the oldURL and newURL to the old and new hash respectively.\n\n//  const pollHash = function () {\n//    if (window.location.hash !== hash) {\n//      hash = window.location.hash;\n//      window.onhashchange({\n//        newURL: window.location.href\n//      });\n//    }\n//  };\n//  Creates a function to poll the hash, checks to see if the window location hash is different from the hash variable, if it is sets the hash variable to the new window location hash and calls the onhashchange event listener.\n\n//  pollHash();\n//  pollingInterval = window.setInterval(pollHash, delay);\n//  Calls the pollHash function and sets the pollingInterval to call the pollHash function every 250 milliseconds.\n\n//  if (typeof window.addEventListener === 'function') {\n//    window.addEventListener('beforeunload', function () {\n//      window.clearInterval(pollingInterval);\n//    }, false);\n//  }\n//  Checks if the window has an addEventListener function, if it does sets an event listener for beforeunload and clears the pollingInterval\n\n//})();\n//End of the anonymous function",
    useCase:
      "\n\nEvent.hashchange is used in Javascript to detect changes to the part of a url that follows the # symbol. This can be used to detect when the user navigates to a different page within a single-page application, or when the user changes the parameters of the page, such as when a user changes the sorting of a list. It can also be used to detect when the user has manually changed the url hash.",
  },
  {
    code: "\n\n(function() {\n    function EventSource(url) {\n        this.url = url;\n        this.readyState = 0;\n        this.onopen = function(){};\n        this.onmessage = function() {};\n        this.onerror = function() {};\n        this.poll();\n    }\n    \n    EventSource.prototype.CONNECTING = 0;\n    EventSource.prototype.OPEN = 1;\n    EventSource.prototype.CLOSED = 2;\n    \n    EventSource.prototype.poll = function() {\n        var self = this;\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', this.url);\n        xhr.onreadystatechange = function() {\n            if (this.readyState === 4 && this.status === 200) {\n                self.readyState = self.OPEN;\n                self.onopen();\n                self.onmessage({\n                    data: this.responseText\n                });\n            }\n            else {\n                self.onerror();\n            }\n        };\n        xhr.send();\n    };\n    \n    window.EventSource = EventSource;\n})();",
    term: "EventSource",
    explain:
      "\n\n// (function(){}) is an immediately invoked function expression (IIFE), which is used to create a new scope in which variables declared inside of it are not visible outside of it.\n\n// function EventSource(url) { ... } is a function constructor which is used to create EventSource objects with a specific URL.\n\n// this.url = url; is a property which assigns the URL passed as an argument to the instance of the EventSource object.\n\n// this.readyState = 0; is a property which initializes the readyState property with 0.\n\n// this.onopen = function(){}; is a property which sets the onopen property to a function that does nothing.\n\n// this.onmessage = function() {}; is a property which sets the onmessage property to a function that does nothing.\n\n// this.onerror = function() {}; is a property which sets the onerror property to a function that does nothing.\n\n// this.poll(); is a method which is called immediately after the EventSource object is created.\n\n// EventSource.prototype.CONNECTING = 0; is a prototype property of the EventSource constructor which assigns the CONNECTING constant a value of 0.\n\n// EventSource.prototype.OPEN = 1; is a prototype property of the EventSource constructor which assigns the OPEN constant a value of 1.\n\n// EventSource.prototype.CLOSED = 2; is a prototype property of the EventSource constructor which assigns the CLOSED constant a value of 2.\n\n// EventSource.prototype.poll = function() { ... }; is a prototype method of the EventSource constructor which is used to poll the server for any new data.\n\n// window.EventSource = EventSource; is used to set the EventSource constructor as a global object in the window object.",
    useCase:
      "?\n\nEventSource is used in Javascript as a way to enable server-sent events (SSEs). This allows for a real-time connection between the client and server so that the server can push data to the client without the client having to request it. This can be used for notifications, updates, or even streaming data.",
  },
  {
    code: "\n\nconst Float32ArrayPolyfill = (function() {\n\n  return {\n    from(arrayLike) {\n      if (!arrayLike.length) return new Float32Array(0);\n      const array = new Float32Array(arrayLike.length);\n\n      for (let i = 0; i < array.length; i++) {\n        array[i] = arrayLike[i];\n      }\n\n      return array;\n    },\n    of(...items) {\n      return new Float32Array(items);\n    }\n  };\n})();",
    term: "Float32Array",
    explain:
      "\n\n//1. const Float32ArrayPolyfill = (function() {\n//this line declares a constant variable named Float32ArrayPolyfill and sets it equal to an anonymous function.\n\n//2. return {\n//this line returns an object literal\n\n//3. from(arrayLike) {\n//this line declares the from method which accepts an arrayLike argument\n\n//4. if (!arrayLike.length) return new Float32Array(0);\n// this line checks to see if the arrayLike argument has a length of 0, if it does it will return a new Float32Array object with a length of 0\n\n//5. const array = new Float32Array(arrayLike.length);\n//this line declares a variable named array and sets it equal to a new Float32Array object with a length equal to the arrayLike argument's length\n\n//6. for (let i = 0; i < array.length; i++) {\n//this line declares a for loop which starts at 0 and iterates until it is less than the length of the array\n\n//7. array[i] = arrayLike[i];\n//this line sets the value of the array at index i equal to the value of the arrayLike argument at index i\n\n//8. return array;\n//this line returns the array\n\n//9. of(...items) {\n//this line declares the of method which accepts multiple items as arguments\n\n//10. return new Float32Array(items);\n//this line returns a new Float32Array object with the items passed in as arguments",
    useCase:
      "\n\nFloat32Array is used in Javascript because it stores data more efficiently than other data types. It is used to represent numbers that have a decimal point, such as 3.14159. Float32Array is also faster to read and write than other data types. It is especially useful when dealing with large amounts of data, such as 3D graphics or scientific calculations.",
  },
  {
    code: "\n\nif (!window.Float64Array) {\n  window.Float64Array = function Float64Array() {\n    // Create an empty array.\n    let array = new Array(arguments.length);\n\n    // Copy the arguments into the array.\n    for (let i = 0; i < arguments.length; i++) {\n      array[i] = arguments[i];\n    }\n\n    // Add the raw method.\n    array.BYTES_PER_ELEMENT = 8;\n    array.get = (index) => {\n      return array[index];\n    };\n    array.set = (index, value) => {\n      array[index] = value;\n    };\n    array.subarray = (begin, end) => {\n      return array.slice(begin, end);\n    };\n    array.buffer = () => {\n      return array;\n    };\n    array.length = () => {\n      return array.length;\n    };\n\n    return array;\n  };\n}",
    term: "Float64Array",
    explain:
      "\n\n// Line 1: This checks if window.Float64Array is not defined.\n// Line 2: If window.Float64Array is not defined, then a new function is created and assigned to window.Float64Array.\n// Line 3: An empty array is created.\n// Line 4: This loop is used to copy the arguments that are passed to the Float64Array function into the array.\n// Line 5: The BYTES_PER_ELEMENT property is set to 8.\n// Line 6: This is a function that gets the value at a specific index in the array.\n// Line 7: This is a function that sets the value at a specific index in the array.\n// Line 8: This is a function that gets a subarray of the array.\n// Line 9: This is a function that returns the array.\n// Line 10: This is a function that returns the length of the array.\n// Line 11: The array is returned.",
    useCase:
      "\n\nFloat64Array is used in Javascript because it allows for more precise calculations with decimal numbers than the regular Number type, which is limited to a precision of 16 decimal digits. Float64Array is also faster for certain operations than the regular Number type, which makes it a better choice for applications that require more precision or speed.",
  },
  {
    code: "\n\nif (!Object.hasOwnProperty(\"name\")) {\n  Object.defineProperty(Function.prototype, 'name', {\n    get: function () {\n      var matches = this.toString().match(/^\\s*function\\s*([^\\s(]+)/);\n      return matches ? matches[1] : '';\n    }\n  });\n}",
    term: "Function.name",
    explain:
      '\n\n// Line 1: \n// This line checks if the Object class has a property called "name". If not, it will execute the code block.\n\n// Line 2: \n// This line adds a new property called "name" to the Function prototype.\n\n// Line 3: \n// This line creates a getter method that checks the current function\'s toString() value and tries to match it to a regular expression pattern. If the pattern matches, it will return the matched value. Otherwise, it will return an empty string.',
    useCase:
      '\n\nFunction.name is used in Javascript to retrieve a function\'s name as a string. It is useful for debugging purposes, or when writing code that needs to be able to determine the name of a given function. This is especially important when working with anonymous functions, as the Function.name property will return the assigned name of the function, instead of a generic string such as "anonymous".',
  },
  {
    code: "\n\nif (!Function.prototype.bind) {\n  Function.prototype.bind = function(oThis) {\n    if (typeof this !== 'function') {\n      // closest thing possible to the ECMAScript 5\n      // internal IsCallable function\n      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n    }\n \n    var aArgs   = Array.prototype.slice.call(arguments, 1),\n        fToBind = this,\n        fNOP    = function() {},\n        fBound  = function() {\n          return fToBind.apply(this instanceof fNOP\n                 ? this\n                 : oThis,\n                 aArgs.concat(Array.prototype.slice.call(arguments)));\n        };\n \n    // fNOP.prototype = this.prototype;\n    fBound.prototype = new fNOP();\n \n    return fBound;\n  };\n}",
    term: "Function.prototype.bind",
    explain:
      "\n\n1.  if (!Function.prototype.bind) { // The if statement checks if the bind method is not present in the Function prototype\n\n2.  Function.prototype.bind = function(oThis) { // If the bind method is not present, it is added to the Function prototype\n\n3.  if (typeof this !== 'function') { // Checks if the function is not a function\n\n4.  throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable'); // If the function is not a function, throw a TypeError\n\n5.  var aArgs   = Array.prototype.slice.call(arguments, 1), // Create a variable aArgs and assign it the arguments passed to the function\n\n6.  fToBind = this, // Create a variable fToBind and assign it to the current function\n\n7.  fNOP    = function() {}, // Create a variable fNOP and assign it an empty function\n\n8.  fBound  = function() { // Create a variable fBound and assign it a function\n\n9.    return fToBind.apply(this instanceof fNOP // The function will return the result of the function fToBind applied to the arguments\n\n10.      ? this // If the condition is true, this will be assigned to the fToBind function\n\n11.      : oThis, // If the condition is false, the argument oThis will be assigned to the fToBind function\n\n12.      aArgs.concat(Array.prototype.slice.call(arguments))); // Concatenate the aArgs variable to the arguments\n\n13.  fBound.prototype = new fNOP(); // Assign the prototype of fBound to a new instance of fNOP\n\n14.  return fBound; // Return the function fBound",
    useCase:
      "\n\nFunction.prototype.bind is used in JavaScript to create a new function that, when called, has its this keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function is called. This allows for a more concise way of specifying a function to be called with a certain context and set of arguments.",
  },
  {
    code: '\n\n// define function if not defined\nif (!Function.prototype.hasOwnProperty("name")) {\n    Object.defineProperty(Function.prototype, "name", {\n        get: function(){\n            if("name" in this){\n                return this.name;\n            }\n            var match = this.toString().match(/^\\s*function\\s*([^(]*)\\(/);\n            return match && match[1].length > 0 ? match[1] : "";\n        }\n    })\n}',
    term: "Function.prototype.name",
    explain:
      '\n\n// Line 1: This line checks to see if the Function.prototype already has a "name" property. \n// Line 2: If it does not, then a new property is defined on the Function.prototype. \n// Line 3: The "name" property is a getter, so when it is accessed, a function is called. \n// Line 4: This line checks to see if the "name" property has already been set on the function. \n// Line 5: If it has, then the value of the "name" property is returned. \n// Line 6: If not, then a regex is used to try to extract the name of the function from the definition. \n// Line 7: If a name was extracted, then that is returned, otherwise an empty string is returned.',
    useCase:
      "\n\nFunction.prototype.name is used in Javascript to provide a way to access the name of a function. This is especially useful for debugging or logging purposes, as it allows developers to easily see what function is being called or referenced. It can also be used to help ensure that functions have been named correctly, as a missing or incorrect name can be easily spotted and corrected.",
  },
  {
    code: "\n\nif (!HTMLCanvasElement.prototype.toBlob) {\n    Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {\n        value: function (callback, type, quality) {\n\n            var binStr = atob(this.toDataURL(type, quality).split(',')[1]);\n            var len = binStr.length;\n            var arr = new Uint8Array(len);\n\n            for (var i = 0; i < len; i++) {\n                arr[i] = binStr.charCodeAt(i);\n            }\n\n            callback(new Blob([arr], {type: type || 'image/png'}));\n        }\n    });\n}",
    term: "HTMLCanvasElement.prototype.toBlob",
    explain:
      "\n\n// Line 1: if (!HTMLCanvasElement.prototype.toBlob) \n// This line checks if the HTMLCanvasElement prototype already has a toBlob method defined. \n\n// Line 2: Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {\n// This line defines a new property to the HTMLCanvasElement prototype called 'toBlob'.\n\n// Line 3: value: function (callback, type, quality) {\n// This line defines the value of the toBlob property as a function.\n\n// Lines 4-7: var binStr = atob(this.toDataURL(type, quality).split(',')[1]);\n//             var len = binStr.length;\n//             var arr = new Uint8Array(len);\n\n//             for (var i = 0; i < len; i++) {\n//                 arr[i] = binStr.charCodeAt(i);\n//             }\n// These lines create a binary string from the dataURL of the HTMLCanvasElement, and then loop through the string, character by character, to create a Uint8Array.\n\n// Line 8: callback(new Blob([arr], {type: type || 'image/png'}));\n// This line creates a new Blob object from the Uint8Array and passes it to the callback function. The type of the Blob is either the type passed in as an argument or 'image/png' if no type is passed in.",
    useCase:
      "\n\nHTMLCanvasElement.prototype.toBlob is used to create a Blob object representing the image contained in the canvas. This can be used to easily save the canvas image as a file, or to upload the image data to a server. It can also be used to convert the canvas image data into a data URL, which can be used to embed the image into an HTML document.",
  },
  {
    code: '\n\nif(typeof HTMLDocument === "undefined") { \n    HTMLDocument = Document; \n}',
    term: "HTMLDocument",
    explain:
      "\n\n// This code checks to see if the HTMLDocument object is defined. If it is not defined, then it assigns the Document object to the HTMLDocument object. This is done so that the HTMLDocument object can be used in the code, even if it is not defined.",
    useCase:
      "\n\nHTMLDocument is used in JavaScript to provide an interface for interacting with HTML documents. It provides methods to access and manipulate elements of the page, such as retrieving elements by their ID, creating and appending elements to the DOM, and setting and getting attributes. HTMLDocument also provides a range of event handlers that can be used to respond to user interactions with the page, such as click events.",
  },
  {
    code: "\n\n// polyfill for HTMLInputElement.prototype.valueAsDate\n\nif (HTMLInputElement && !HTMLInputElement.prototype.valueAsDate) {\n    HTMLInputElement.prototype.valueAsDate = function() {\n        if (this.type !== 'date' || this.value == '') {\n            return null;\n        }\n        let dateString = this.value;\n        let parts = dateString.split('-');\n        let year = parseInt(parts[0], 10);\n        let month = parseInt(parts[1], 10) - 1;\n        let day = parseInt(parts[2], 10);\n        let date = new Date(year, month, day);\n        return date;\n    }\n}",
    term: "HTMLInputElement.prototype.valueAsDate",
    explain:
      "\n\n// Line 1:\n// This line declares a polyfill for the HTMLInputElement.prototype.valueAsDate function, which allows developers to get the value of an HTML date input element as a date object. \n\n// Line 2:\n// This line checks to see if the HTMLInputElement and HTMLInputElement.prototype.valueAsDate functions are defined. If they are not, then the code will execute. \n\n// Line 3:\n// This line creates a new function, which will act as the HTMLInputElement.prototype.valueAsDate function. \n\n// Line 4:\n// This line checks to see if the type of the input element is 'date' and if the value of the input element is not an empty string. \n\n// Line 5:\n// This line declares a variable that stores the value of the input element as a string.\n\n// Line 6:\n// This line splits the string into parts and stores the parts in an array. \n\n// Line 7:\n// This line parses the first element in the array as an integer. This is the year. \n\n// Line 8:\n// This line parses the second element in the array as an integer, subtracting 1 from the value. This is the month. \n\n// Line 9:\n// This line parses the third element in the array as an integer. This is the day. \n\n// Line 10:\n// This line creates a new Date object using the year, month, and day values. \n\n// Line 11:\n// This line returns the date object.",
    useCase:
      '\n\nHTMLInputElement.prototype.valueAsDate is used to get and set the value of an <input> element with type="date" as a Date object. This allows the user to select or enter a date in a consistent format, and the date can be easily manipulated and accessed in JavaScript. This feature is especially useful when working with form data, as it makes it easier to format the date and access it in a consistent way.',
  },
  {
    code: "\n\n/**\n * Polyfill HTMLPictureElement\n */\n\n(function() {\n  if (window.HTMLPictureElement) {\n    return;\n  }\n\n  let extend = function(src, dest) {\n    for (let key in src) {\n      if (src.hasOwnProperty(key)) {\n        dest[key] = src[key];\n      }\n    }\n  };\n\n  function HTMLPictureElement() {\n    this.__init();\n  }\n\n  HTMLPictureElement.prototype = {\n    __init: function() {\n      this.__imgList = [];\n    },\n    __addImg: function(el) {\n      this.__imgList.push(el);\n    },\n    __getBestImg: function() {\n      let bestImg;\n      let windowWidth = window.innerWidth;\n      for (let i = 0; i < this.__imgList.length; i++) {\n        let img = this.__imgList[i];\n        let breakpoint = img.getAttribute('data-breakpoint');\n        if (breakpoint) {\n          let minWidth = parseInt(breakpoint.split('-')[0]);\n          if (windowWidth > minWidth) {\n            bestImg = img;\n          }\n        }\n      }\n      return bestImg;\n    },\n    __updateSrc: function() {\n      let bestImg = this.__getBestImg();\n      if (bestImg) {\n        let src = bestImg.getAttribute('data-src');\n        this.__img.setAttribute('src', src);\n      }\n    },\n    setAttribute: function(name, value) {\n      if (name === 'src') {\n        this.__img = new Image();\n        this.__img.setAttribute('src', value);\n        this.appendChild(this.__img);\n      }\n    },\n    appendChild: function(el) {\n      if (el.nodeName === 'IMG') {\n        this.__addImg(el);\n        this.__updateSrc();\n      }\n    }\n  };\n\n  extend(HTMLElement.prototype, HTMLPictureElement.prototype);\n\n  window.HTMLPictureElement = HTMLPictureElement;\n  window.customElements.define('picture-element', HTMLPictureElement);\n})();",
    term: "HTMLPictureElement",
    explain:
      "\n\n//This code is a polyfill for the HTMLPictureElement, which allows developers to use the <picture> element in browsers that don't already support it.\n\n//Line 1: \n//This line declares a function that will polyfill HTMLPictureElement.\n\n//Line 2:\n//This line checks if the window object has a HTMLPictureElement property, and if it does, it returns. This is to make sure that the polyfill isn't executed if the browser already has support for HTMLPictureElement.\n\n//Line 3:\n//This line declares a function called extend that takes two parameters, src and dest. This function is used to extend the prototype of the HTMLPictureElement.\n\n//Line 4:\n//This line declares a function called HTMLPictureElement, which is the constructor for the polyfill.\n\n//Line 5:\n//This line assigns the prototype of HTMLPictureElement to an object literal containing functions for initialization, adding images, getting the best image, updating the source, setting attributes, and appending children.\n\n//Line 6-20:\n//These lines define the functions on the object literal. The __init function initializes the __imgList array. The __addImg function adds an element to the __imgList array. The __getBestImg function finds the best image based on the window's width. The __updateSrc function updates the source of the image. The setAttribute function sets the source attribute of the image. The appendChild function adds an image element to the __imgList array.\n\n//Line 21-23:\n//These lines extend the HTMLElement prototype with the functions defined on the HTMLPictureElement prototype.\n\n//Line 24-25:\n//These lines assign the HTMLPictureElement constructor to the window object and define the 'picture-element' custom HTML element.",
    useCase:
      "\n\nThe HTMLPictureElement is used in JavaScript to allow developers to create responsive images that can adjust to different screen sizes and resolution levels. It provides an easy way to create responsive images, allowing developers to define multiple sources for an image and having the browser choose the most appropriate source based on the available screen size and resolution. This helps reduce page loading times and allows images to be displayed more quickly and efficiently on different devices.",
  },
  {
    code: '\n\nif (HTMLSelectElement.prototype.selectedOptions === undefined) {\n\tHTMLSelectElement.prototype.selectedOptions = {\n\t\tget () {\n\t\t\treturn this.querySelectorAll("option:checked")\n\t\t}\n\t}\n}',
    term: "HTMLSelectElement.prototype.selectedOptions",
    explain:
      '\n\n//This line checks if the HTMLSelectElement.prototype.selectedOptions property is undefined. \nif (HTMLSelectElement.prototype.selectedOptions === undefined) {\n\n//If yes, it adds a getter function to the HTMLSelectElement.prototype.selectedOptions. \n\tHTMLSelectElement.prototype.selectedOptions = {\n\t\tget () {\n\n//The getter function returns a NodeList of all the checked options in the select element. \n\t\t\treturn this.querySelectorAll("option:checked")\n\t\t}\n\t}\n}',
    useCase:
      "\n\nHTMLSelectElement.prototype.selectedOptions is used in JavaScript to access the list of options in a select element that have been selected by the user. This is useful for reading user choices and providing feedback to the user about their selections.",
  },
  {
    code: "\n\nif(window.HTMLTemplateElement === undefined) {\n  window.HTMLTemplateElement = class HTMLTemplateElement {\n    constructor() {\n      this.content = document.createDocumentFragment();\n    }\n    get innerHTML() {\n      let container = document.createElement('div');\n      container.appendChild(this.content);\n      return container.innerHTML;\n    }\n    set innerHTML(htmlString) {\n      this.content.innerHTML = htmlString;\n    }\n  }\n}",
    term: "HTMLTemplateElement",
    explain:
      "\n\n// Line 1: This checks if the window object has a HTMLTemplateElement property. If it does not have one, the following code is executed. \n// Line 2: This creates a class called HTMLTemplateElement and assigns it to the window object.\n// Line 3: This is the constructor of the class, which creates a document fragment and assigns it to the content property of the class.\n// Line 4: This is a getter method, which returns the innerHTML of the document fragment.\n// Line 5: This creates a div element, appends the document fragment to it, and then returns the innerHTML of the div element.\n// Line 6: This is a setter method, which sets the innerHTML of the document fragment.",
    useCase:
      "\n\nHTMLTemplateElement is used in Javascript in order to provide a way to create an inert, easily-clonable DOM subtree. This allows developers to create a reusable template that can be used to quickly populate a portion of the DOM with structured data. This is helpful for creating and manipulating large amounts of HTML quickly, with minimal coding.",
  },
  {
    code: '\n\nif (typeof Int16Array === "undefined") {\n  window.Int16Array = function (length) {\n    let arr = [];\n\n    for (let i = 0; i < length; i++){\n      arr.push(0);\n    }\n\n    arr.BYTES_PER_ELEMENT = 2;\n    arr.buffer = new ArrayBuffer(length * arr.BYTES_PER_ELEMENT);\n\n    arr.set = function (array, offset) {\n      if (array instanceof Int16Array) {\n        offset = offset || 0;\n        for (let i = 0; i < array.length; i++) {\n          arr[i + offset] = array[i];\n        }\n      } else {\n        for (let i = 0; i < array.length; i++) {\n          arr[i] = array[i];\n        }\n      }\n    };\n\n    arr.get = function (index) {\n      if (index >= arr.length) {\n        throw `Index out of range: ${index}`;\n      }\n      return arr[index];\n    }\n\n    arr.subarray = function (begin, end) {\n      const start = Math.max(0, begin || 0);\n      const fin = Math.min(arr.length, end || arr.length);\n      const sub = [];\n      for (let i = start; i < fin; i++) {\n        sub.push(arr[i]);\n      }\n      return sub;\n    }\n\n    return arr;\n  }\n}',
    term: "Int16Array",
    explain:
      '\n\n// Line 1: This line checks if the type of Int16Array is "undefined". If so, it runs the code within the function.\n// Line 2: This line creates a function called Int16Array that takes in one parameter, length.\n// Line 3: This line creates an empty array called arr.\n// Line 4 - 8: This loop iterates through the length of the array and pushes a 0 value into each index of the array.\n// Line 9: This line assigns arr a BYTES_PER_ELEMENT property with a value of 2.\n// Line 10: This line assigns arr a buffer property with a value of an ArrayBuffer with a length of the array multiplied by the BYTES_PER_ELEMENT.\n// Line 11 - 16: This line creates a set method on the array, which takes in an array and an offset. If the array is an Int16Array, it sets the value of each index in the array to the value at the offset. If not, it sets each index of the array to the value of the corresponding index of the array.\n// Line 17 - 22: This line creates a get method on the array, which takes in an index. If the index is greater than or equal to the length of the array, it throws an error. Otherwise, it returns the value at the index.\n// Line 23 - 28: This line creates a subarray method on the array, which takes in a begin and end value. It creates a sub array with the values from the begin index to the end index and returns it.\n// Line 29: This line returns the array.',
    useCase:
      "\n\nInt16Array is used in Javascript because it is an array-like object which stores 16-bit signed integers and provides methods for manipulating the content of the array. This makes it ideal for storing and manipulating large amounts of data that require precise calculations and accuracy. It is also more efficient than other array types due to its smaller size, making it faster to access and process.",
  },
  {
    code: '\n\n//create a function for the Int32Array polyfill\nfunction Int32Array(length) {\n  //ensure the length is a valid number\n  if (Number.isInteger(length)) {\n    //create the array and set the length\n    this.array = new Array(length);\n    //loop through the array setting each element to 0\n    for (let i = 0; i < length; i++) {\n      this.array[i] = 0;\n    }\n  } else {\n    //if the length is not a valid number, throw an error\n    throw new Error("Length must be a valid number");\n  }\n}\n\n//create a method to get the length of the array\nInt32Array.prototype.getLength = function () {\n  return this.array.length;\n};\n\n//create a method to get the element at a given index\nInt32Array.prototype.getElementAtIndex = function (index) {\n  //ensure the index is a valid number\n  if (Number.isInteger(index)) {\n    //ensure the index is within the array\n    if (index >= 0 && index < this.array.length) {\n      return this.array[index];\n    } else {\n      //if the index is not within the array, throw an error\n      throw new Error("Index is out of bounds");\n    }\n  } else {\n    //if the index is not a valid number, throw an error\n    throw new Error("Index must be a valid number");\n  }\n};\n\n//create a method to set the element at a given index\nInt32Array.prototype.setElementAtIndex = function (index, val) {\n  //ensure the index is a valid number\n  if (Number.isInteger(index)) {\n    //ensure the index is within the array\n    if (index >= 0 && index < this.array.length) {\n      //ensure the value is a valid number\n      if (Number.isInteger(val)) {\n        //set the element at the given index to the given value\n        this.array[index] = val;\n      } else {\n        //if the value is not a valid number, throw an error\n        throw new Error("Value must be a valid number");\n      }\n    } else {\n      //if the index is not within the array, throw an error\n      throw new Error("Index is out of bounds");\n    }\n  } else {\n    //if the index is not a valid number, throw an error\n    throw new Error("Index must be a valid number");\n  }\n};',
    term: "Int32Array",
    explain:
      "\n\n//This code creates a function for a Int32Array polyfill. It ensures that the length is a valid number, creates an array with the given length, and sets each element to 0. It also creates methods to get the length of the array, get the element at a given index, and set the element at a given index. The functions ensure that the index and value are valid numbers, and that the index is within the array. If either of these conditions are not met, an error is thrown.",
    useCase:
      "\n\nInt32Array is used in Javascript to store 32-bit signed integers. It is useful for manipulating data in a more efficient way because it stores data in a fixed-length format, which reduces the amount of memory used and allows for faster access to data. It is also useful for performing mathematical operations on large sets of data, as the integers take up less space than other data types like strings.",
  },
  {
    code: "\n\n//creates a new Int8Array object\nconst Int8Array = function(length) {\n  let array = new Array(length);\n  for (let i = 0; i < length; i++) {\n    array[i] = 0;\n  }\n  array.BYTES_PER_ELEMENT = 1;\n  array.get = function(index) {\n    return this[index];\n  };\n  array.set = function(index, value) {\n    this[index] = value;\n  };\n  array.fill = function(value, start, end) {\n    let start_ = start || 0;\n    let end_ = end || this.length;\n    for (let i = start_; i < end_; i++) {\n      this[i] = value;\n    }\n  };\n  array.slice = function(start, end) {\n    let start_ = start || 0;\n    let end_ = end || this.length;\n    let result = new Int8Array(end_ - start_);\n    for (let i = start_; i < end_; i++) {\n      result[i - start_] = this[i];\n    }\n    return result;\n  };\n  return array;\n};",
    term: "Int8Array",
    explain:
      "\n\n// Line 1: \n// Creates a new Int8Array function which takes in an argument of length and returns an array. \n\n// Line 2: \n// Creates a new array of length specified by the argument. \n\n// Line 3: \n// Loops through the length of the array, setting the value of each index to 0. \n\n// Line 4: \n// Sets the BYTES_PER_ELEMENT property of the array to 1. \n\n// Line 5: \n// Creates a get method which takes in an index as an argument and returns the value stored at that index. \n\n// Line 6: \n// Creates a set method which takes in an index and a value as arguments and sets the value at the index to the value specified. \n\n// Line 7: \n// Creates a fill method which takes in a value, start, and end as arguments and sets the value of each index between the start and end arguments to the value specified. \n\n// Line 8: \n// Creates a slice method which takes in a start and end argument and returns a new Int8Array of the same length as the difference between the start and end arguments.",
    useCase:
      "\n\nInt8Array is used in Javascript because it is an array-like view of a typed array in which elements are stored in 8-bit signed integers. It is used for efficient storage, manipulation, and communication of typed arrays of data. Int8Array is a great choice for working with binary data, and it can be used to represent integers from -128 to 127. Additionally, Int8Array provides significant performance gains over other typed array types, as it requires less space than other types and can be more quickly processed by the JavaScript engine.",
  },
  {
    code: "\n\n// Create a class for the IntersectionObserver\nclass IntersectionObserver {\n  // Define constructor to set options\n  constructor(callback, options = {}) {\n    // Set observer options \n    this._callback = callback;\n    this._options = options;\n    // Add all the intersection targets to an array\n    this._targets = [];\n  }\n  \n  // Define add function to add targets\n  add(target) {\n    this._targets.push(target);\n  }\n  \n  // Define remove function to remove targets\n  remove(target) {\n    const index = this._targets.indexOf(target);\n    if (index > -1) {\n      this._targets.splice(index, 1);\n    }\n  }\n  \n  // Define observe function to observe targets\n  observe() {\n    // Get the intersection root\n    let root;\n    // If the option specifies a root\n    if (this._options.root) {\n      // Set the root\n      root = this._options.root;\n    } else {\n      // Set the root to the document\n      root = document;\n    }\n    \n    // For each of the targets\n    this._targets.forEach((target) => {\n      // Calculate the intersection of target and root\n      const intersection = this._calculateIntersection(target, root);\n      // Call the callback function\n      this._callback(target, intersection);\n    });\n  }\n  \n  // Define a function to calculate the intersection of two elements\n  _calculateIntersection(target, root) {\n    // Get the bounding box of target and root\n    const targetRect = target.getBoundingClientRect();\n    const rootRect = root.getBoundingClientRect();\n    // Set the intersection to false\n    let intersection = false;\n    // Calculate the intersection\n    if (targetRect.top <= rootRect.bottom &&\n      targetRect.right >= rootRect.left &&\n      targetRect.bottom >= rootRect.top &&\n      targetRect.left <= rootRect.right) {\n      intersection = true;\n    }\n    // Return the intersection\n    return intersection;\n  }\n}",
    term: "IntersectionObserver",
    explain:
      "\n\n// Line by Line Explanation:\n// 1. This line of code creates a class called IntersectionObserver.\n// 2. This line sets up a constructor for the class and sets the callback and options as parameters.\n// 3. This line creates an empty array for the targets.\n// 4. This line defines the add() function which adds a target to the array.\n// 5. This line defines the remove() function which removes a target from the array.\n// 6. This line defines the observe() function which calls the callback function with the target and intersection.\n// 7. This line checks if the option specifies a root, if so then sets the root to the root specified in the option. Otherwise, it sets the root to the document.\n// 8. This line loops over the targets and calls the _calculateIntersection() function with the target and root.\n// 9. This line gets the bounding boxes of the target and root.\n// 10. This line sets the intersection to false by default.\n// 11. This line checks if the target and root intersect and sets the intersection to true if they do.\n// 12. This line returns the intersection.",
    useCase:
      "\n\nIntersectionObserver is used in Javascript to detect when an element comes into or out of the viewport. This is useful for lazy loading images, infinite scrollers, tracking viewability, and more. It's a lightweight and efficient way to detect when an element is visible in the viewport, allowing developers to trigger actions based on the visibility of an element.",
  },
  {
    code: "\n\n(function() {\n  // Check if IntersectionObserver is supported\n  if ('IntersectionObserver' in window) {\n    return;\n  }\n\n  // Polyfill\n  function IntersectionObserverEntry(entry) {\n    this.time = Date.now();\n    this.boundingClientRect = entry.getBoundingClientRect();\n    this.intersectionRatio = entry.intersectionRatio;\n    this.intersectionRect = entry.intersectionRect;\n    this.isIntersecting = !!entry.intersectionRect;\n    this.rootBounds = entry.rootBounds;\n    this.target = entry.target;\n    this.name = '';\n  }\n\n  window.IntersectionObserverEntry = IntersectionObserverEntry;\n})();",
    term: "IntersectionObserverEntry",
    explain:
      "\n\n// Line 1: This creates an anonymous function which is immediately invoked\n// Line 2: This checks if the browser has native support for IntersectionObserver, if it does then it exits the function\n// Line 3: This creates a function called IntersectionObserverEntry which takes an entry parameter\n// Line 4-10: This sets all the properties of an IntersectionObserverEntry object\n// Line 11: This assigns the IntersectionObserverEntry function to window",
    useCase:
      "\n\nIntersectionObserverEntry is used in JavaScript to observe when an element or set of elements enter or exit the viewport of the browser. This can be used for tasks like lazy loading images or triggering animations when an element is visible on the page. It is an efficient way to detect when an element is visible in the viewport, without having to manually check for visibility on scroll or resize events.",
  },
  {
    code: "\n\n// Create a function that accepts two parameters:\n// - locale: which is the locale to use for formatting\n// - options: which is an object defining the options for the DateTimeFormat\nfunction polyfillIntlDateTimeFormat(locale, options) {\n  // Check if the locale parameter is a valid value\n  if (typeof locale !== 'string') {\n    throw new TypeError('locale must be a string');\n  }\n\n  // Check if the options parameter is a valid value\n  if (typeof options !== 'object' || options === null) {\n    throw new TypeError('options must be an object');\n  }\n\n  // Set the initial values for the variables\n  // that will be used in the function\n  let date = new Date();\n  let weekday = '';\n  let month = '';\n  let day = '';\n  let year = '';\n  let hour = '';\n  let minute = '';\n  let second = '';\n\n  // Get the weekday name, in the given locale\n  switch (locale) {\n    case 'en-US':\n      weekday = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][date.getDay()];\n      break;\n\n    case 'es-ES':\n      weekday = ['domingo', 'lunes', 'martes', 'miércoles', 'jueves', 'viernes', 'sábado'][date.getDay()];\n      break;\n\n    case 'fr-FR':\n      weekday = ['dimanche', 'lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi', 'samedi'][date.getDay()];\n      break;\n\n    // Add more locales here\n\n    default:\n      throw new TypeError('locale must be a valid value');\n  }\n\n  // Get the month name, in the given locale\n  switch (locale) {\n    case 'en-US':\n      month = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'][date.getMonth()];\n      break;\n\n    case 'es-ES':\n      month = ['enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio', 'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre'][date.getMonth()];\n      break;\n\n    case 'fr-FR':\n      month = ['janvier', 'février', 'mars', 'avril', 'mai', 'juin', 'juillet', 'août', 'septembre', 'octobre', 'novembre', 'décembre'][date.getMonth()];\n      break;\n\n    // Add more locales here\n\n    default:\n      throw new TypeError('locale must be a valid value');\n  }\n\n  // Get the day of the month\n  day = date.getDate();\n\n  // Get the year\n  year = date.getFullYear();\n\n  // Get the hour\n  hour = ('0' + date.getHours()).slice(-2);\n\n  // Get the minute\n  minute = ('0' + date.getMinutes()).slice(-2);\n\n  // Get the second\n  second = ('0' + date.getSeconds()).slice(-2);\n\n  // Construct the date string, using the options provided\n  let dateString = '';\n  if (options.weekday === 'short') {\n    dateString += weekday.slice(0, 3) + ', ';\n  } else if (options.weekday === 'long') {\n    dateString += weekday + ', ';\n  }\n\n  if (options.month === 'short') {\n    dateString += month.slice(0, 3) + ' ';\n  } else if (options.month === 'long') {\n    dateString += month + ' ';\n  }\n\n  if (options.day === 'numeric') {\n    dateString += day + ', ';\n  }\n\n  if (options.year === 'numeric') {\n    dateString += year + ' ';\n  }\n\n  if (options.hour === 'numeric') {\n    dateString += hour + ':';\n  }\n\n  if (options.minute === 'numeric') {\n    dateString += minute + ':';\n  }\n\n  if (options.second === 'numeric') {\n    dateString += second;\n  }\n\n  // Return the generated date string\n  return dateString;\n}",
    term: "Intl.DateTimeFormat",
    explain:
      "\n\n// This function creates a polyfill for the Intl.DateTimeFormat() function. It takes two parameters:\n// - locale: which is the locale to use for formatting\n// - options: which is an object defining the options for the DateTimeFormat.\n// It will then check if the locale and options parameters are valid values, before setting the initial values for the variables that will be used in the function. It will then use a switch statement to get the weekday and month names in the given locale. It will then get the day of the month, year, hour, minute and second, before constructing the date string using the options provided. Lastly, it will return the generated date string.",
    useCase:
      "\n\nIntl.DateTimeFormat is used in JavaScript to provide language-sensitive date and time formatting. It enables developers to format dates and times according to a user’s locale, allowing for more accurate and appropriate formatting of date and time values in web applications. It also allows for the formatting of date and time values according to a user’s preferred time zone and calendar, which can be particularly useful when dealing with international users.",
  },
  {
    code: "\n\n// Polyfill for Intl.DateTimeFormat.prototype.formatToParts\nIntl.DateTimeFormat.prototype.formatToParts = function(date) {\n\t// define the parts of a date\n\tconst parts = {\n\t\tyear: date.getFullYear(),\n\t\tmonth: date.getMonth(),\n\t\tday: date.getDate(),\n\t\thours: date.getHours(),\n\t\tminutes: date.getMinutes(),\n\t\tseconds: date.getSeconds(),\n\t\ttimezone: date.getTimezoneOffset()\n\t};\n\n\t// return the parts of the date\n\treturn parts; \n};",
    term: "Intl.DateTimeFormat.prototype.formatToParts",
    explain:
      "\n\n//This line of code is creating a polyfill for the Intl.DateTimeFormat.prototype.formatToParts function. This function will take in a date as an argument and will define the parts of the date (year, month, day, hours, minutes, seconds, and timezone). Finally, it will return the parts of the date.",
    useCase:
      "\n\nIntl.DateTimeFormat.prototype.formatToParts is used in Javascript to provide a way to format a Date object into a string that is organized into distinct parts. This is useful in situations where the individual parts of a date need to be accessed, such as when formatting a date for a specific locale or when displaying a date in a specific format. formatToParts can also be used to parse a string into its individual parts, which is useful when dealing with user input or data from an external source.",
  },
  {
    code: "\n\n// polyfill for Intl.DateTimeFormat.~timeZone.all\nif (!Intl.DateTimeFormat.prototype.timeZone) {\n  Intl.DateTimeFormat.prototype.timeZone = {\n    all: function(date) {\n      let tz = date.getTimezoneOffset() / 60;\n      let sign = tz > 0 ? '+' : '-';\n      let absTz = Math.abs(tz);\n      let hrs = Math.floor(absTz);\n      let min = ((absTz - hrs) * 60).toFixed(2).padStart(2, '0');\n      let timeZone = `UTC${sign}${hrs}:${min}`;\n      return timeZone;\n    }\n  };\n}",
    term: "Intl.DateTimeFormat.~timeZone.all",
    explain:
      "\n\n// Line 1:\n// This line is a polyfill (a code that replicates a feature found in some other browsers) for Intl.DateTimeFormat.~timeZone.all.\n\n// Line 2:\n// This line uses an if statement to check whether the Intl.DateTimeFormat.prototype.timeZone is already present. If it is not present, the code block below will be executed.\n\n// Line 3:\n// This line assigns an anonymous function to the Intl.DateTimeFormat.prototype.timeZone object. \n\n// Line 4:\n// This line declares a variable tz which is equal to the getTimezoneOffset() value divided by 60. It is used to get the timezone offset in hours.\n\n// Line 5:\n// This line declares a variable sign which is either '+' or '-' depending on the value of tz.\n\n// Line 6:\n// This line declares a variable absTz which is equal to the absolute value of tz.\n\n// Line 7:\n// This line declares a variable hrs which is equal to the floor value of absTz.\n\n// Line 8:\n// This line declares a variable min which is equal to the decimal part of absTz multiplied by 60 and it is padded with 0s to make it two digits.\n\n// Line 9:\n// This line declares a variable timeZone which is equal to the UTC timezone string with the sign and hrs and min variables.\n\n// Line 10:\n// This line returns the timeZone variable.",
    useCase:
      "\n\nIntl.DateTimeFormat.timeZone.all is used in Javascript to access the list of all available time zones in the International DateTimeFormat API. This list can be used to format and display dates and times in the desired time zone. This helps to ensure that dates and times are presented in a consistent manner across different time zones and locales.",
  },
  {
    code: "\n\nif (!Intl.DateTimeFormat || !Intl.DateTimeFormat.prototype.timeZone) {\n  Intl.DateTimeFormat.prototype.timeZone = {\n    golden: {\n      get longName() {\n        const offset = -25200;\n        const hours = Math.trunc(offset / 3600);\n        const minutes = Math.abs(offset % 3600);\n        return `GMT${hours < 0 ? '-' : '+'}${Math.abs(hours)}:${minutes < 10 ? '0' : ''}${minutes}`;\n      },\n      get shortName() { \n        return 'MST';\n      }\n    }\n  };\n}",
    term: "Intl.DateTimeFormat.~timeZone.golden",
    explain:
      "\n\n//Line 1: This line checks if the Intl.DateTimeFormat and Intl.DateTimeFormat.prototype.timeZone exist. If they don't it will go to the next line. \n\n//Line 2: This line adds the timeZone object to the DateTimeFormat prototype. \n\n//Line 3: This line creates a longName property to the timeZone object, which is a function. \n\n//Line 4: This line creates a variable called offset to store the time difference between the current time and the time in the golden time zone. \n\n//Line 5: This line creates a variable called hours which stores the number of hours in the offset variable. \n\n//Line 6: This line creates a variable called minutes which stores the number of minutes in the offset variable. \n\n//Line 7: This line returns a string with the GMT time for the golden time zone based on the offset variable. \n\n//Line 8: This line creates a shortName property to the timeZone object, which is a function. \n\n//Line 9: This line returns the short name for the golden time zone. \n\n//Line 10: This line closes the timeZone object. \n\n//Line 11: This line closes the if statement.",
    useCase:
      "\n\nIntl.DateTimeFormat.~timeZone.golden is used in JavaScript to format dates and times according to the user's time zone. This helps ensure that dates and times are displayed accurately for the user, regardless of where in the world they are located. This feature is especially useful for applications that are accessed by users from different parts of the world.",
  },
  {
    code: "\n\nif (!Intl.DisplayNames) {\n    Intl.DisplayNames = class {\n        constructor(locales, options) {\n            this.locale = locales;\n            this.type = options.type;\n            this.fallback = options.fallback;\n        }\n\n        of(code) {\n            //implementation\n            return code;\n        }\n    }\n}",
    term: "Intl.DisplayNames",
    explain:
      "\n\n// Line 1:\n// This line checks if the Intl.DisplayNames object already exists. If it does not, the code will run the rest of the code.\n\n// Line 2:\n// This line creates the Intl.DisplayNames object.\n\n// Line 3:\n// This line defines a constructor for the Intl.DisplayNames object. The constructor takes 2 parameters: 'locales' and 'options'.\n\n// Line 4:\n// This line sets the 'locale' property of the Intl.DisplayNames object to the 'locales' parameter.\n\n// Line 5:\n// This line sets the 'type' property of the Intl.DisplayNames object to the 'options.type' parameter.\n\n// Line 6:\n// This line sets the 'fallback' property of the Intl.DisplayNames object to the 'options.fallback' parameter.\n\n// Line 8:\n// This line defines a function for the Intl.DisplayNames object called 'of'. This function takes one parameter, 'code'. \n\n// Line 9:\n// This line defines the implementation of the 'of' function. It returns the 'code' parameter.",
    useCase:
      "\n\nIntl.DisplayNames is used in Javascript to provide an interface for accessing localized names for languages, scripts, regions, currencies, and timezones. It allows developers to access localized names of these elements in a user's locale, which is essential for creating a localized user experience.",
  },
  {
    code: '\n\nif (!Intl.ListFormat) {\n    Intl.ListFormat = class {\n        constructor(locales, options) {\n            this.locales = locales;\n            this.options = options;\n        }\n\n        format(list) {\n            let formattedString = "";\n            let lastItem = list.pop();\n            list.forEach(item => {\n                formattedString += `${item}, `;\n            });\n            if (list.length > 0) {\n                formattedString += `${this.options.conjuction} `;\n            }\n            formattedString += lastItem;\n            return formattedString;\n        }\n    }\n}',
    term: "Intl.ListFormat",
    explain:
      '\n\n1. "if (!Intl.ListFormat)" - This line is a conditional statement checking if the Intl.ListFormat property is not true. Intl.ListFormat is an internationalization API that formats lists according to the locale and options provided.\n\n2. "Intl.ListFormat = class" - This line creates a class for the Intl.ListFormat object.\n\n3. "constructor(locales, options)" - This is the constructor for the class. It takes two parameters, locales and options, which will be used to format the list according to the locale and options provided.\n\n4. "format(list)" - This is the method for formatting the list. It takes a list as a parameter, and returns a formatted string.\n\n5. "let formattedString = """ - This line defines a variable to store the formatted string.\n\n6. "let lastItem = list.pop()" - This line removes the last item from the list and stores it in a variable.\n\n7. "list.forEach(item => {" - This line iterates through the list and appends each item to the formatted string.\n\n8. "if (list.length > 0)" - This line checks if the list has more than one item, and if so, adds a conjunction to the formatted string.\n\n9. "formattedString += lastItem" - This line adds the last item to the formatted string.\n\n10. "return formattedString" - This line returns the formatted string.',
    useCase:
      "\n\nIntl.ListFormat is used in Javascript to format lists of items in a language-sensitive way. It takes an array of items and returns a localized string that can be used to display the list of items. It also allows developers to customize the output string in a variety of ways, including specifying the delimiter, the style of the output string, and the order of the items. Intl.ListFormat is especially useful when dealing with multilingual applications that need to display lists of items in different languages.",
  },
  {
    code: '\n\nif(!Intl.Locale){\n  Intl.Locale = function(locale) {\n    this.localeString = locale;\n  }\n  \n  Intl.Locale.prototype.getLanguage = function () {\n    return this.localeString.substring(0,2);\n  };\n  \n  Intl.Locale.prototype.getScript = function () {\n    if(this.localeString.length > 2 && this.localeString[2] === "-"){\n      return this.localeString.substr(3,4); \n    }\n    return "";\n  };\n  \n  Intl.Locale.prototype.getRegion = function () {\n    if(this.localeString.length > 5 && this.localeString[5] === "-"){\n      return this.localeString.substr(6,2); \n    }\n    return "";\n  };\n  \n  Intl.Locale.prototype.getVariant = function () {\n    if(this.localeString.length > 8 && this.localeString[8] === "-"){\n      return this.localeString.substr(9); \n    }\n    return "";\n  };\n  \n  Intl.Locale.prototype.toString = function () {\n    return this.localeString;\n  };\n}',
    term: "Intl.Locale",
    explain:
      "\n\n// This code creates an Intl.Locale constructor, which is used to create a Locale object that can be used to get the language, script, region and variant of a locale string. \n// Line 1: checks if Intl.Locale is defined. \n// Line 2: defines Intl.Locale constructor, which takes a locale string as a parameter. \n// Line 3: defines a getLanguage() method which returns the first two letters of the locale string.\n// Line 4: defines a getScript() method which returns the 4 letters after the second dash in the locale string.\n// Line 5: defines a getRegion() method which returns the 2 letters after the fifth dash in the locale string. \n// Line 6: defines a getVariant() method which returns the letters after the eighth dash in the locale string. \n// Line 7: defines a toString() method which returns the locale string.",
    useCase:
      "\n\nIntl.Locale is used in Javascript to provide language-sensitive functions for formatting data such as dates, numbers, and currencies. It is a powerful tool for developers to create applications that can be used in multiple languages. It also allows developers to manage different regional settings and formatting conventions. By using Intl.Locale, developers can ensure that their applications are compliant with international standards and can be used in any language.",
  },
  {
    code: "\n\nconst IntlNumberFormat = (locales, options) => {\n  const isObject = (obj) => {\n    return Object.prototype.toString.call(obj) === '[object Object]';\n  };\n  const isString = (str) => {\n    return typeof str === 'string';\n  };\n\n  // Get locale data\n  const localeData = (locale) => {\n    const {\n      decimal,\n      group,\n      negative,\n      percent,\n    } = options;\n\n    // Define currency format\n    const currencyFormat = {\n      style: 'currency',\n      currency: options.currency || 'USD',\n    };\n\n    // If no locale is provided, set default one\n    const defaultLocale = 'en-US';\n    const defaultData = {\n      decimal: '.',\n      group: ',',\n      negative: '-',\n      percent: '%',\n    };\n\n    // Set up locale data\n    let data = {};\n    if (isObject(locale)) {\n      data = locale;\n    } else if (isString(locale)) {\n      data = {\n        decimal,\n        group,\n        negative,\n        percent,\n      }\n      data.locale = locale;\n    } else if (!locales) {\n      data = defaultData;\n      data.locale = defaultLocale;\n    }\n\n    // Set up currency format\n    if (options.style === 'currency') {\n      data = { ...data, ...currencyFormat };\n    }\n\n    return data;\n  };\n\n  // Get formatting options\n  const getOptions = (localeData) => {\n    const {\n      decimal,\n      group,\n      negative,\n      style,\n    } = localeData;\n\n    let {\n      currency,\n    } = localeData;\n\n    const formatOptions = {\n      minimumFractionDigits: 0,\n      maximumFractionDigits: 0,\n      minimumIntegerDigits: 1,\n      useGrouping: true,\n      style: style || 'decimal',\n    };\n\n    if (style === 'currency') {\n      currency = currency || 'USD';\n    }\n\n    return {\n      decimal,\n      group,\n      negative,\n      currency,\n      formatOptions,\n    };\n  };\n\n  // Format number\n  const formatNumber = (number, options) => {\n    const {\n      decimal,\n      group,\n      negative,\n      currency,\n      formatOptions,\n    } = options;\n\n    let formattedNumber = '';\n\n    // Set up options\n    const numberOptions = {\n      ...formatOptions,\n      useGrouping: true,\n    };\n\n    // Handle negative number\n    if (number < 0) {\n      numberOptions.signDisplay = 'always';\n      formattedNumber = negative;\n    }\n\n    // Format number\n    if (style === 'currency') {\n      numberOptions.currencyDisplay = 'symbol';\n      numberOptions.currency = currency;\n      formattedNumber += new Intl.NumberFormat(locales, numberOptions).format(number);\n    } else {\n      numberOptions.minimumFractionDigits = 0;\n      numberOptions.maximumFractionDigits = 0;\n      formattedNumber += new Intl.NumberFormat(locales, numberOptions).format(number);\n    }\n\n    return formattedNumber;\n  };\n\n  // Format number\n  const numberFormat = (number) => {\n    const localeData = localeData(locales);\n    const options = getOptions(localeData);\n\n    return formatNumber(number, options);\n  };\n\n  return numberFormat;\n};",
    term: "Intl.NumberFormat",
    explain:
      "\n\n// This code defines a function, IntlNumberFormat, that takes two parameters, locales and options. \n// The function first declares two helper functions, isObject and isString, to check the type of the parameters. \n// It then defines the function localeData, which takes one parameter, locale, and sets up the locale data. \n// Next, the getOptions function is defined, which takes the locale data as its parameter and sets up the formatting options. \n// Finally, the formatNumber function is defined, which takes two parameters, number and options, and formats the number according to the specified options. \n// The function then returns the numberFormat function, which uses the localeData and getOptions functions to format the number.",
    useCase:
      "\n\nIntl.NumberFormat is used in JavaScript to format numbers according to the locale of the user. It allows developers to display numbers in a localized format, which can be useful for displaying prices, percentages, and other numerical data. Intl.NumberFormat can also be used to format numbers with the correct currency symbols and other formatting options like decimal places.",
  },
  {
    code: "\n\n// This polyfill is based on the Unicode CLDR Plural Rules (v35)\n\nconst IntlPluralRules = {\n    supportedLocalesOf: (locales) => {\n        // Validate the locales argument\n        if (typeof locales === 'string') {\n            locales = [locales];\n        } else if (!Array.isArray(locales)) {\n            throw new TypeError('invalid argument');\n        }\n\n        const supportedLocales = [];\n\n        // Check each locale against the supported plural rules\n        locales.forEach((locale) => {\n            if (IntlPluralRules.pluralRules[locale]) {\n                supportedLocales.push(locale);\n            }\n        });\n\n        return supportedLocales;\n    },\n\n    // Plural rules for each locale in the Unicode CLDR\n    pluralRules: {\n        \"en\": (n) => {\n            return n === 1 ? 'one' : 'other';\n        },\n        \"fr\": (n) => {\n            return (n >= 0 && n < 2) ? 'one' : 'other';\n        },\n        \"de\": (n) => {\n            return n !== 1 ? 'other' : 'one';\n        },\n        \"es\": (n) => {\n            return n !== 1 ? 'other' : 'one';\n        },\n        // Add more locale rules here\n    }\n};",
    term: "Intl.PluralRules",
    explain:
      "\n\n// This line of code is defining a polyfill for the Intl.PluralRules API which is used to determine the plural form of a given number in a particular language. \n\n// Line 1: \n// This line declares the constant IntlPluralRules which will hold the polyfill for the Intl.PluralRules API. \n\n// Line 2: \n// This line declares a supportedLocalesOf method which takes a single argument, locales, and returns an array of supported locales based on the plural rules provided.\n\n// Line 3:\n// This line checks to see if the argument passed to the supportedLocalesOf method is a string or an array. If it is neither, an error is thrown.\n\n// Line 4: \n// This line declares an empty array, supportedLocales, which will hold the supported locales.\n\n// Line 5-11: \n// This block of code iterates through each locale in the argument and checks it against the pluralRules object. If the locale is supported, it is pushed to the supportedLocales array.\n\n// Line 12: \n// This line returns the array of supported locales.\n\n// Line 13-20: \n// This block of code declares an object, pluralRules, which holds the plural rules for each supported locale. Each entry in the object contains a function which takes a single argument, n, and returns the appropriate plural form for that number in that language.",
    useCase:
      "\n\nIntl.PluralRules is used in JavaScript to provide language-sensitive plural formatting for numbers. This provides a way for users to format numbers according to the rules of any language, so that an application can display numbers in the way that is most appropriate for the language the user speaks. This is important for international applications, as different languages have different rules for how numbers should be formatted.",
  },
  {
    code: "\n\n//create a new prototype called RelativeTimeFormat\nRelativeTimeFormat.prototype = {\n  constructor: RelativeTimeFormat,\n\n  //define language-sensitive relative time format function\n  format: function (date, unit) {\n    //determine the difference in time between the current time and the given date\n    var diff = Math.abs(new Date() - date),\n      //determine the years passed since the given date\n      years = Math.floor(diff / 31536000000),\n      //determine the months passed since the given date\n      months = Math.floor((diff % 31536000000) / 2592000000),\n      //determine the days passed since the given date\n      days = Math.floor((diff % 2592000000) / 86400000),\n      //determine the hours passed since the given date\n      hours = Math.floor((diff % 86400000) / 3600000),\n      //determine the minutes passed since the given date\n      minutes = Math.floor((diff % 3600000) / 60000);\n\n    //declare a variable to store the returned relative time string\n    var relativeTimeString;\n\n    //determine the relative time string by the given unit\n    switch (unit) {\n      case 'year':\n        relativeTimeString = years + ' year' + (years > 1 ? 's' : '') + ' ago';\n        break;\n\n      case 'month':\n        relativeTimeString = months + ' month' + (months > 1 ? 's' : '') + ' ago';\n        break;\n\n      case 'day':\n        relativeTimeString = days + ' day' + (days > 1 ? 's' : '') + ' ago';\n        break;\n\n      case 'hour':\n        relativeTimeString = hours + ' hour' + (hours > 1 ? 's' : '') + ' ago';\n        break;\n\n      case 'minute':\n        relativeTimeString = minutes + ' minute' + (minutes > 1 ? 's' : '') + ' ago';\n        break;\n    }\n\n    //return the relative time string\n    return relativeTimeString;\n  },\n};",
    term: "Intl.RelativeTimeFormat",
    explain:
      "\n\n//This code creates a new prototype called RelativeTimeFormat. This will allow an object to access and use the properties and methods of the prototype. It then defines a language-sensitive relative time format function which determines the relative time string of a given date and unit. This is done by calculating the difference in time between the current time and the given date in years, months, days, hours, and minutes, and then returning the relative time string based on the given unit.",
    useCase:
      '\n\nIntl.RelativeTimeFormat is used in JavaScript to provide language-sensitive relative time formatting. It allows developers to format relative dates and times such as "yesterday" or "in 5 minutes" in a way that is tailored to the user\'s locale. This helps to ensure that the time formatting is appropriate and understandable by users in different languages and cultures.',
  },
  {
    code: "\n\n// polyfill for Intl.getCanonicalLocales\n\nconst getCanonicalLocales = (locales) => {\n   const canonicalLocales = [];\n   const seen = new Set();\n\n   locales.forEach((locale) => {\n      const normalizedLocale = locale.replace(/[-_]/, '-').toLowerCase();\n      const [baseLocale] = normalizedLocale.split('-');\n\n      if (!seen.has(normalizedLocale)) {\n        seen.add(normalizedLocale);\n        canonicalLocales.push(normalizedLocale);\n      }\n\n      if (baseLocale !== normalizedLocale && !seen.has(baseLocale)) {\n        seen.add(baseLocale);\n        canonicalLocales.push(baseLocale);\n      }\n   });\n \n   return canonicalLocales;\n};",
    term: "Intl.getCanonicalLocales",
    explain:
      '\n\n// Line 1\n// This line of code declares a function called "getCanonicalLocales" which takes a parameter of "locales".\n\n// Line 2\n// This line of code declares a variable called "canonicalLocales" and sets it to an empty array.\n\n// Line 3\n// This line of code declares a variable called "seen" and sets it to an instance of the Set data structure.\n\n// Line 4\n// This line of code calls the "forEach" method on the "locales" parameter, which executes the provided function once for each element in the array.\n\n// Line 5\n// This line of code declares a variable called "normalizedLocale" and sets it to the result of the "locale" parameter\'s "replace" method, which replaces all instances of either "_" or "-" with "-". It then converts the result to lowercase.\n\n// Line 6\n// This line of code declares a variable called "baseLocale" and sets it to the first element of the "normalizedLocale" variable, which was returned by the "split" method.\n\n// Line 7\n// This line of code checks if the "seen" variable (which is a Set data structure) does not have the "normalizedLocale" variable. If it doesn\'t, it adds it to the "seen" variable and pushes it to the "canonicalLocales" array.\n\n// Line 8\n// This line of code checks if the "baseLocale" variable is not the same as the "normalizedLocale" variable and if the "seen" variable (which is a Set data structure) does not have the "baseLocale" variable. If it doesn\'t, it adds it to the "seen" variable and pushes it to the "canonicalLocales" array.\n\n// Line 9\n// This line of code returns the "canonicalLocales" array.',
    useCase:
      "\n\nIntl.getCanonicalLocales is used in JavaScript to ensure consistency in the language or locale codes used across different JavaScript engines. For example, it can be used to convert a locale code that is not valid or accepted in the ECMAScript Internationalization API into an equivalent, valid one. It can also be used to convert different dialects of a language into a single, canonical language code. Intl.getCanonicalLocales is an important part of the Internationalization API and helps to ensure accurate and consistent results across different JavaScript engines.",
  },
  {
    code: "\n\n// define a function to act as a polyfill of JSON\nconst JSON = {\n  parse: function(text, reviver) {\n    let j;\n    function walk(holder, key) {\n      const k;\n      const v;\n      const value = holder[key];\n      if (value && typeof value === 'object') {\n        for (k in value) {\n          if (Object.hasOwnProperty.call(value, k)) {\n            v = walk(value, k);\n            if (v !== undefined) {\n              value[k] = v;\n            } else {\n              delete value[k];\n            }\n          }\n        }\n      }\n      return reviver.call(holder, key, value);\n    }\n    text = String(text);\n    rx_dangerous.lastIndex = 0;\n    if (rx_dangerous.test(text)) {\n      text = text.replace(rx_dangerous, function(a) {\n        return '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n      });\n    }\n    if (rx_one.test(text.replace(rx_two, '@').replace(rx_three, ']').replace(rx_four, ''))) {\n      j = eval('(' + text + ')');\n      return typeof reviver === 'function' ? walk({ '': j }, '') : j;\n    }\n    throw new SyntaxError('JSON.parse');\n  },\n  stringify: function(value, replacer, space) {\n    let i;\n    let gap = '';\n    let indent = '';\n    let rep;\n    let k;\n    let v;\n    let length;\n    if (typeof replacer === 'function') {\n      rep = replacer;\n    } else if (Array.isArray(replacer)) {\n      length = replacer.length;\n      rep = function(key, value) {\n        let i = 0;\n        if (Object.prototype.toString.apply(replacer) === '[object Array]') {\n          for (; i < length; i += 1) {\n            if (replacer[i] === key) {\n              return value;\n            }\n          }\n        }\n        return key;\n      };\n    }\n    if (space) {\n      if (typeof space === 'number') {\n        for (i = 0; i < space; i += 1) {\n          indent += ' ';\n        }\n      } else if (typeof space === 'string') {\n        indent = space;\n      }\n    }\n    if (typeof rep === 'function') {\n      value = rep.call(holder, key, value);\n    }\n    switch (typeof value) {\n      case 'string':\n        return quote(value);\n      case 'number':\n        return isFinite(value) ? String(value) : 'null';\n      case 'boolean':\n      case 'null':\n        return String(value);\n      case 'object':\n        if (!value) {\n          return 'null';\n        }\n        if (typeof value.toJSON === 'function') {\n          return stringify(value.toJSON());\n        }\n        gap += indent;\n        partial = [];\n        if (Array.isArray(value)) {\n          length = value.length;\n          for (i = 0; i < length; i += 1) {\n            partial[i] = str(i, value) || 'null';\n          }\n          v = partial.length === 0 ? '[]' : gap ? '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' : '[' + partial.join(',') + ']';\n          gap = mind;\n          return v;\n        }\n        if (rep && typeof rep === 'object') {\n          length = rep.length;\n          for (i = 0; i < length; i += 1) {\n            if (typeof rep[i] === 'string') {\n              k = rep[i];\n              v = str(k, value);\n              if (v) {\n                partial.push(quote(k) + (gap ? ': ' : ':') + v);\n              }\n            }\n          }\n        } else {\n          for (k in value) {\n            if (Object.prototype.hasOwnProperty.call(value, k)) {\n              v = str(k, value);\n              if (v) {\n                partial.push(quote(k) + (gap ? ': ' : ':') + v);\n              }\n            }\n          }\n        }\n        v = partial.length === 0 ? '{}' : gap ? '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' : '{' + partial.join(',') + '}';\n        gap = mind;\n        return v;\n    }\n  }\n};\n\n// define constants to use in the polyfill\nconst rx_one = /^[\\],:{}\\s]*$/;\nconst rx_two = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g;\nconst rx_three = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;\nconst rx_four = /(?:^|:|,)(?:\\s*\\[)+/g;\nconst rx_dangerous = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n\n// define helper functions\nfunction quote(string) {\n  const rx_escapable = /[\\\\\"\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n  rx_escapable.lastIndex = 0;\n  return rx_escapable.test(string) ? '\"' + string.replace(rx_escapable, function(a) {\n    const c = meta[a];\n    return typeof c === 'string' ? c : '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n  }) + '\"' : '\"' + string + '\"';\n}\nfunction str(key, holder) {\n  let i;\n  let k;\n  const v;\n  const length;\n  const mind = gap;\n  const partial;\n  if (typeof value === 'object' && value !== null) {\n    if (typeof value.toJSON === 'function') {\n      value = value.toJSON(key);\n    } else if (Array.isArray(value)) {\n      partial = [];\n      length = value.length;\n      for (i = 0; i < length; i += 1) {\n        partial[i] = str(i, value) || 'null';\n      }\n      v = partial.length === 0 ? '[]' : gap ? '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' : '[' + partial.join(',') + ']';\n      gap = mind;\n      return v;\n    }\n    if (rep && typeof rep === 'object') {\n      length = rep.length;\n      for (i = 0; i < length; i += 1) {\n        if (typeof rep[i] === 'string') {\n          k = rep[i];\n          v = str(k, value);\n          if (v) {\n            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n          }\n        }\n      }\n    } else {\n      for (k in value) {\n        if (Object.prototype.hasOwnProperty.call(value, k)) {\n          v = str(k, value);\n          if (v) {\n            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n          }\n        }",
    term: "JSON",
    explain:
      "\n      }\n    }\n    v = partial.length === 0 ? '{}' : gap ? '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' : '{' + partial.join(',') + '}';\n    gap = mind;\n    return v;\n  }\n}\n\n// Line 1: Define a function to act as a polyfill of JSON\n// This line defines a function to act as a polyfill of the JavaScript Object Notation (JSON) which is used to store and exchange data. \n\n// Line 2: Constants to use in the polyfill\n// This line defines four constants (rx_one, rx_two, rx_three, rx_four) which will be used in the polyfill.\n\n// Line 3: Define helper functions\n// This line defines helper functions (quote, str) which will be used in the polyfill.\n\n// Line 4: Define a constant to use in the polyfill\n// This line defines a constant (rx_dangerous) which will be used in the polyfill.",
    useCase:
      "\n\nJSON (JavaScript Object Notation) is often used in JavaScript because it is a lightweight data-interchange format that is easy to read and write for humans, and easy for machines to parse and generate. It is also language independent, so it can be used in any language, including JavaScript. JSON can be used to store and transfer data between a server and a web application, making it a great choice for data-driven web applications.",
  },
  {
    code: "\n\n// Polyfill for Map\nif (!window.Map) {\n  window.Map = function Map() {\n    let items = {};\n\n    this.set = function (key, value) {\n      items[key] = value;\n    };\n    this.delete = function (key) {\n      if (items.hasOwnProperty(key)) {\n        delete items[key];\n        return true;\n      }\n      return false;\n    };\n    this.has = function (key) {\n      return items.hasOwnProperty(key);\n    };\n    this.get = function (key) {\n      return items[key];\n    };\n    this.clear = function () {\n      items = {};\n    };\n    this.size = function () {\n      return Object.keys(items).length;\n    };\n  };\n}",
    term: "Map",
    explain:
      "\n//Line 1:\n//This line checks if the window object already has a Map property. If it doesn't, it will execute the code in the subsequent block.\n\n//Line 2:\n//This line sets a Map property on the window object and assigns it a function.\n\n//Line 3:\n//This line declares a variable items and assigns it an empty object.\n\n//Line 4-7:\n//These lines create the set() method on the Map object which takes a key and a value as arguments and assigns the value to the items object using the key.\n\n//Line 8-12:\n//These lines create the delete() method which takes a key as an argument and deletes it from the items object if it exists.\n\n//Line 13-16:\n//These lines create the has() method which checks if a given key is present in the items object.\n\n//Line 17-20:\n//These lines create the get() method which returns the value associated with the given key in the items object.\n\n//Line 21-24:\n//These lines create the clear() method which sets the items object to an empty object.\n\n//Line 25-28:\n//These lines create the size() method which returns the number of keys present in the items object.",
    useCase:
      "\n\nMap is used in Javascript because it provides an efficient way to store key-value pairs and look up values quickly. The Map object can be used as a simple data structure to store key-value pairs, or as a sophisticated data structure to perform complex lookups. Maps also provide a better alternative to objects when keys are unknown until run time, or when there is a need to store a collection of unique values.",
  },
  {
    code: "\n\nif (!Math.acosh) {\n  Math.acosh = function(x) {\n    if (x < 1) {\n      return NaN;\n    }\n    return Math.log(x + Math.sqrt(x * x - 1));\n  };\n}",
    term: "Math.acosh",
    explain:
      "\n\n//Line 1: This line checks if the function Math.acosh already exists. If it does not exist, it will execute the code in the following block.\n\n//Line 2: This line starts the function Math.acosh which takes one parameter, x.\n\n//Line 3: This line checks if the value of x is less than 1. If it is, it will return NaN, which stands for Not a Number.\n\n//Line 4: This line returns the logarithm of x plus the square root of x squared minus 1.",
    useCase:
      "\n\nMath.acosh is used in Javascript to calculate the inverse hyperbolic cosine of a number. It is useful in situations where an angle or a trigonometric ratio needs to be determined from a given value of the hyperbolic cosine. It is also used in scientific and engineering applications, such as finding the force of gravity at a certain height, or calculating the angle of refraction of a beam of light.",
  },
  {
    code: "\n\nif (!Math.asinh) {\n    Math.asinh = function(x) {\n        if (x === -Infinity) {\n            return x;\n        } else {\n            return Math.log(x + Math.sqrt(x * x + 1));\n        }\n    }\n}",
    term: "Math.asinh",
    explain:
      "\n\n// Line 1: if (!Math.asinh) {\n// This line checks whether Math.asinh already exists or not. If it already exists, the code inside the if statement will not be executed. \n\n// Line 2: Math.asinh = function(x) {\n// This line defines a function that takes the parameter x and assigns it to Math.asinh. \n\n// Line 3: if (x === -Infinity) {\n// This line checks whether the value of x is equal to negative infinity. \n\n// Line 4: return x;\n// This line returns the value of x if the condition in line 3 is true. \n\n// Line 5:} else {\n// This line will only execute if the condition in line 3 is false.\n\n// Line 6: return Math.log(x + Math.sqrt(x * x + 1));\n// This line returns the logarithm of x plus the square root of x squared plus 1.",
    useCase:
      "\n\nMath.asinh is used in Javascript to calculate the inverse hyperbolic sine of a given number. It is useful for a variety of mathematical operations, such as calculating angles and trigonometric functions. It is also commonly used in physics calculations to determine the velocity and acceleration of objects in motion.",
  },
  {
    code: "\n\nif (!Math.atanh) {\n  Math.atanh = function(x) {\n    if (x === -1) {\n      return -Infinity;\n    } else if (x === 1) {\n      return Infinity;\n    } else if (x < -1 || x > 1) {\n      return NaN;\n    }\n\n    return 0.5 * Math.log((1 + x) / (1 - x));\n  }\n}",
    term: "Math.atanh",
    explain:
      "\n\nLine 1: This line checks whether atanh function exists in the Math object. If it doesn't exist, the code moves to the next line.\n\nLine 2: This line creates a function called atanh and assigns it to Math object.\n\nLine 3: This line checks whether the parameter passed to the function is -1. If it is, the function returns -Infinity.\n\nLine 4: This line checks whether the parameter passed to the function is 1. If it is, the function returns Infinity.\n\nLine 5: This line checks whether the parameter passed to the function is less than -1 or greater than 1. If it is, the function returns NaN.\n\nLine 6: This line returns the result of 0.5 multiplied by the natural log of (1 + x) divided by (1 - x).",
    useCase:
      "\n\nMath.atanh is used in Javascript to calculate the inverse hyperbolic tangent of a number. This is useful when you need to calculate the angle of a triangle given the length of its sides, or when you need to calculate the angle at which a projectile will reach its highest point given its initial velocity. It is also useful when you need to determine the angle of a line given its slope.",
  },
  {
    code: "\n\nMath.cbrt=function(x){\n  let y = Math.pow(Math.abs(x), 1/3);\n  return x < 0 ? -y : y;\n};",
    term: "Math.cbrt",
    explain:
      "\n\n// Math.cbrt is a function that takes in one parameter, x.\n// The next line calculates the value of y using the absolute value of x and the cube root formula.\n// The last line returns the value of y if x is greater than 0 and returns the negative of y if x is less than 0.",
    useCase:
      "\n\nMath.cbrt is used in Javascript to calculate the cube root of a number. Cube roots are used in many mathematical equations and calculations, such as polynomials and other equations that involve exponents or radicals. It is also used in some computer graphics and animation programs to calculate the size and shape of 3D objects.",
  },
  {
    code: "\n\nif (!Math.clz32) {\n  Math.clz32 = function(x) {\n    var value = Number(x) >>> 0;\n    if (value === 0) return 32;\n    var result = 0;\n    if (value >= 0xFFFFFFFF) { result += 32; value >>>= 32; }\n    if (value >= 0xFFFF) { result += 16; value >>>= 16; }\n    if (value >= 0xFF) { result += 8; value >>>= 8; }\n    if (value >= 0xF) { result += 4; value >>>= 4; }\n    if (value >= 0x3) { result += 2; value >>>= 2; }\n    return result + (value >>> 1);\n  }\n}",
    term: "Math.clz32",
    explain:
      '\n\n// Line 1: \n// If Math.clz32 is not defined, \n\n// Line 2: \n// define a Math.clz32 function that takes in a parameter x \n\n// Line 3: \n// Set a variable "value" to the parameter x converted to a number and shifted right by 0 bits\n\n// Line 4: \n// If the value of the variable is 0, return 32 \n\n// Line 5: \n// Set a variable "result" to 0\n\n// Line 6: \n// If the value of the variable is greater than or equal to 0xFFFFFFFF (4294967295 in decimal), add 32 to the result and shift the value of the variable right by 32 bits\n\n// Line 7: \n// If the value of the variable is greater than or equal to 0xFFFF (65535 in decimal), add 16 to the result and shift the value of the variable right by 16 bits\n\n// Line 8: \n// If the value of the variable is greater than or equal to 0xFF (255 in decimal), add 8 to the result and shift the value of the variable right by 8 bits\n\n// Line 9: \n// If the value of the variable is greater than or equal to 0xF (15 in decimal), add 4 to the result and shift the value of the variable right by 4 bits\n\n// Line 10:\n// If the value of the variable is greater than or equal to 0x3 (3 in decimal), add 2 to the result and shift the value of the variable right by 2 bits\n\n// Line 11: \n// Return the result plus the value of the variable shifted right by 1 bit',
    useCase:
      "\n\nMath.clz32 is used in Javascript to count the number of leading zero bits in a 32-bit integer. This is useful for a variety of tasks such as determining the number of leading zeros in a binary representation of a number, or for determining the position of the highest set bit in a number. This can be used for efficient arithmetic operations or for optimizing code.",
  },
  {
    code: "\n\nif (!Math.cosh) {\n  Math.cosh = function (x) {\n    return  (Math.exp(x) + Math.exp(-x)) / 2;\n  }\n}",
    term: "Math.cosh",
    explain:
      "\n\n// Line 1: This line checks whether the Math object has a cosh method, and if not, it creates one.\n// Line 2: This line defines the cosh method for the Math object. It uses the exponential function (exp) to calculate the hyperbolic cosine of a given number.",
    useCase:
      "\n\nMath.cosh is used in Javascript to calculate the hyperbolic cosine of a number. It is useful for applications such as calculating angles in trigonometry and complex numbers.",
  },
  {
    code: "\n\nif (!Math.expm1) {\n    Math.expm1 = function (x) {\n        let y = 1;\n        let n = 50;\n        let factorial = 1;\n        for (let i = 1; i <= n; i++) {\n            factorial *= i;\n            y += Math.pow(x, i) / factorial;\n        }\n        return Math.round(y * 10000000) / 10000000;\n    }\n}",
    term: "Math.expm1",
    explain:
      "\n\n// Line 1: This line checks if the Math.expm1 function already exists. If it does not exist, the code will go into the if statement.\n\n// Line 2: This line declares the Math.expm1 function.\n\n// Line 3: This line declares a variable called y and sets it equal to 1.\n\n// Line 4: This line declares a variable called n and sets it equal to 50.\n\n// Line 5: This line declares a variable called factorial and sets it equal to 1.\n\n// Line 6: This line creates a for loop that will iterate from 1 to n.\n\n// Line 7: This line multiplies the factorial variable by the current iteration of the loop.\n\n// Line 8: This line adds the result of the Math.pow() function divided by the factorial variable to the y variable.\n\n// Line 9: This line returns the value of y multiplied by 10000000 and rounded to the nearest integer.",
    useCase:
      "\n\nMath.expm1 is used in Javascript to calculate the value of e^x - 1, where e is Euler's number (approximately equal to 2.718281828459045). This is useful for calculations that require precision and accuracy, such as calculating the natural logarithm of a number.",
  },
  {
    code: "\n\nif (!Math.fround) {\n  Math.fround = function(x) {\n    if (x === 0) {\n      return x;\n    }\n    \n    if (!Number.isFinite(x)) {\n      return x;\n    }\n\n    var e = Math.floor(Math.log2(Math.abs(x)));\n    var m = Math.pow(2, e - 23);\n    var n = (1 + m) * x;\n    var r = Math.floor(n) & 0x7FFFFF;\n    return (r / m) * Math.pow(2, e - 24);\n  };\n}",
    term: "Math.fround",
    explain:
      "\n\n// Line 1: if (!Math.fround) {\n// This line checks to see if the Math.fround function already exists. If it does not, the code within the if statement will be executed. \n\n// Line 2: Math.fround = function(x) {\n// This line assigns a function to the Math.fround property. The function will take one parameter, x.\n\n// Line 3: if (x === 0) {\n// This line checks to see if the parameter x is equal to 0. If it is, the code within this if statement will be executed.\n\n// Line 4: return x;\n// This line returns the parameter x if it is equal to 0.\n\n// Line 5: if (!Number.isFinite(x)) {\n// This line checks to see if the parameter x is a finite number. If it is not, the code within this if statement will be executed.\n\n// Line 6: return x;\n// This line returns the parameter x if it is not a finite number.\n\n// Line 7: var e = Math.floor(Math.log2(Math.abs(x)));\n// This line declares a variable e and assigns it the value of the Math.floor function applied to the Math.log2 function applied to the Math.abs function applied to the parameter x.\n\n// Line 8: var m = Math.pow(2, e - 23);\n// This line declares a variable m and assigns it the value of the Math.pow function applied to 2 and the result of subtracting 23 from the variable e.\n\n// Line 9: var n = (1 + m) * x;\n// This line declares a variable n and assigns it the value of adding 1 to the variable m and multiplying it by the parameter x.\n\n// Line 10: var r = Math.floor(n) & 0x7FFFFF;\n// This line declares a variable r and assigns it the value of the Math.floor function applied to the variable n and a bitwise AND operation with the hexadecimal number 0x7FFFFF.\n\n// Line 11: return (r / m) * Math.pow(2, e - 24);\n// This line returns the result of dividing the variable r by the variable m and multiplying it by the Math.pow function applied to 2 and subtracting 24 from the variable e.",
    useCase:
      "\n\nMath.fround is used in Javascript to round a number to its nearest 32-bit single precision float representation. This is important because it ensures that the number is accurately represented in the system and is useful when working with certain types of calculations. Additionally, it allows for a more efficient use of memory since single precision numbers take up less space than double precision numbers.",
  },
  {
    code: "\n\nMath.hypot = function() {\n  let y = 0;\n  for (let i=0; i < arguments.length; i++) {\n    if (arguments[i] === Infinity || arguments[i] === -Infinity) {\n      return Infinity;\n    }\n    y += arguments[i] * arguments[i];\n  }\n  return Math.sqrt(y);\n}",
    term: "Math.hypot",
    explain:
      "\n\n// Math.hypot is a function that finds the Euclidean norm of a set of numbers.\n\n// Line 1: This defines a function called Math.hypot, which is assigned to the Math object.\n\n// Line 2: This declares a variable y and sets it to 0.\n\n// Line 3: This loop iterates over all the given arguments.\n\n// Line 4: This checks if any of the given arguments is either Infinity or -Infinity. If so, it returns Infinity.\n\n// Line 5: This line adds the square of the current argument to the y variable.\n\n// Line 6: This returns the square root of y.",
    useCase:
      "\n\nMath.hypot is used in Javascript to calculate the length of the hypotenuse of a right triangle using the Pythagorean theorem. This can be used to calculate the distance between two points, the size of a triangle, or any other calculation that requires the hypotenuse of a right triangle.",
  },
  {
    code: "\n\nfunction imul(a, b) {\n  var ah = (a >>> 16) & 0xffff;\n  var al = a & 0xffff;\n  var bh = (b >>> 16) & 0xffff;\n  var bl = b & 0xffff;\n  // the shift by 0 fixes the sign on the high part\n  // the final |0 converts the unsigned value into a signed value\n  return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);\n}",
    term: "Math.imul",
    explain:
      "\n\n// function imul(a, b): Declares a function named imul that takes two integer arguments, a and b.\n\n// var ah = (a >>> 16) & 0xffff: Declares a variable named ah and assigns it the value of a right-shifted by 16 bits and then bitwise ANDed with 0xffff. This results in the high 16 bits of the 32-bit a.\n\n// var al = a & 0xffff: Declares a variable named al and assigns it the value of a bitwise ANDed with 0xffff. This results in the low 16 bits of the 32-bit a.\n\n// var bh = (b >>> 16) & 0xffff: Declares a variable named bh and assigns it the value of b right-shifted by 16 bits and then bitwise ANDed with 0xffff. This results in the high 16 bits of the 32-bit b.\n\n// var bl = b & 0xffff: Declares a variable named bl and assigns it the value of b bitwise ANDed with 0xffff. This results in the low 16 bits of the 32-bit b.\n\n// return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0): Returns the result of multiplying al, the low 16 bits of a, and bl, the low 16 bits of b, and adding it to the result of multiplying ah, the high 16 bits of a, and bl, the low 16 bits of b, and then adding that to the result of multiplying al, the low 16 bits of a, and bh, the high 16 bits of b and then left-shifting that result by 16 bits and then right-shifting it by 0 bits before bitwise ORing it with 0. This calculation results in a 32-bit value.",
    useCase:
      "\n\nMath.imul is used in Javascript to efficiently multiply two integers and return the result as an integer. This is important, as it allows for faster calculations when working with large values, as well as providing better accuracy when working with small values. It also helps to reduce overflow errors, since the result is automatically rounded to the nearest integer.",
  },
  {
    code: "\n\nif (!Math.log10) {\n  Math.log10 = function (x) {\n    return Math.log(x) * Math.LOG10E;\n  };\n}",
    term: "Math.log10",
    explain:
      "\n\n// This code checks if a log10 function is defined in Math. \n// If it is not, a new log10 function is defined that returns the natural log of x multiplied by the base 10 logarithm of E.",
    useCase:
      "\n\nMath.log10 is used in Javascript to calculate the logarithmic value to the base 10 of a number. It is typically used in engineering and scientific calculations where logarithmic values are essential. This function is also useful for finding the number of digits in a number.",
  },
  {
    code: "\n\nMath.log1p = function(x) {\n  if (x <= -1) {\n    return NaN;\n  } else if (Math.abs(x) > 1e-4) {\n    return Math.log(1 + x);\n  } else {\n    var y = x, sum = x;\n    var i = 1;\n    while (Math.abs(y) > 1e-4) {\n      y *= x / ++i;\n      sum += y;\n    }\n    return sum;\n  }\n};",
    term: "Math.log1p",
    explain:
      "\n\n// Math.log1p = function(x) \n// This line is creating the function log1p and assigning it to the Math object.\n\n// if (x <= -1) {\n// This line is checking to see if the argument passed in is less than or equal to -1.\n\n// return NaN;\n// This line is returning the value NaN (Not a Number) if the argument is less than or equal to -1.\n\n// else if (Math.abs(x) > 1e-4) {\n// This line is checking to see if the absolute value of the argument is greater than 1e-4 (0.0001).\n\n// return Math.log(1 + x);\n// This line is returning the value of the natural logarithm of 1 plus the argument passed in.\n\n// var y = x, sum = x;\n// This line is declaring two variables, y and sum, and assigning the argument passed in to both.\n\n// var i = 1;\n// This line is declaring a variable, i, and assigning it a value of 1.\n\n// while (Math.abs(y) > 1e-4) {\n// This line is creating a while loop that will continue while the absolute value of the variable y is greater than 1e-4 (0.0001).\n\n// y *= x / ++i;\n// This line is multiplying the variable y by the argument passed in, divided by the incremented value of the variable i.\n\n// sum += y;\n// This line is adding the value of the variable y to the variable sum.\n\n// return sum;\n// This line is returning the value of the variable sum once the while loop has finished.\n\n// };\n// This line is ending the function.",
    useCase:
      "\n\nMath.log1p is used in Javascript to calculate the natural logarithm of a number plus one. This is useful because it allows for the calculation of the natural logarithm of a number that is very close to zero without having to deal with the numerical issues that come with taking the logarithm of a number that is very close to zero. This makes it a useful tool for dealing with values that may otherwise be difficult to work with.",
  },
  {
    code: "\n\nif (!Math.log2) {\n  Math.log2 = function(x) {\n    return Math.log(x) * Math.LOG2E;\n  };\n}",
    term: "Math.log2",
    explain:
      "\n\n//Line 1: \n//This line checks to see if there is a Math.log2 function already defined. \n\n//Line 2: \n//If Math.log2 is not defined, this line creates a new function that takes one argument, x.\n\n//Line 3:\n//This line returns the natural logarithm of x times the constant Math.LOG2E.",
    useCase:
      "\n\nMath.log2 is used in Javascript to calculate the base 2 logarithm of a number. This is useful for algorithms that require the use of logarithms in order to work more efficiently and accurately. For example, binary search algorithms are based on logarithmic calculations, and Math.log2 can be used to perform these calculations quickly and accurately.",
  },
  {
    code: "\n\nfunction mathSign(value) {\n   if (value === 0) {\n      return 0\n   } else if (value > 0) {\n      return 1\n   } else {\n      return -1\n   }\n}",
    term: "Math.sign",
    explain:
      '\n\n// Line 1: This line declares a function called "mathSign" with one parameter called "value".\n// Line 2: This line evaluates if the value of the parameter "value" is equal to 0. If the condition is true, then the function returns the value 0. \n// Line 3: This line evaluates if the value of the parameter "value" is greater than 0. If the condition is true, then the function returns the value 1. \n// Line 4: This line evaluates if the value of the parameter "value" is not equal to 0 and not greater than 0. If the condition is true, then the function returns the value -1.',
    useCase:
      "\n\nMath.sign is used in Javascript to determine the sign of a number. It will return a number indicating whether the value is positive, negative, or zero. This is a useful function for determining the direction of a number and for making decisions based on the sign of a number. It is also useful for setting up mathematical equations that involve the sign of a number.",
  },
  {
    code: "\n\nMath.sinh = Math.sinh || function(x) {\n    var y = Math.exp(x);\n    return (y - 1 / y) / 2;\n};",
    term: "Math.sinh",
    explain:
      "\n\n//Line 1: This line assigns the Math.sinh function to the Math object, or if Math.sinh already exists, it is not changed.\n//Line 2: This line creates a variable y and assigns it to the value of e to the power of x.\n//Line 3: This line returns the result of (y - 1 / y) / 2, which is the hyperbolic sine of x.",
    useCase:
      "\n\nMath.sinh is used in JavaScript to calculate the hyperbolic sine of a given number. The hyperbolic sine function is an important mathematical function that is used in many areas of mathematics, such as calculus and trigonometry. It is also used in many real-world applications, such as astronomy, engineering, and physics. By using Math.sinh, developers can quickly and easily calculate the hyperbolic sine of a given number without having to manually calculate the result.",
  },
  {
    code: "\n\nMath.tanh = function(x) {\n    var y = Math.exp(2 * x);\n    return (y - 1) / (y + 1);\n};",
    term: "Math.tanh",
    explain:
      '\n\n// line 1: This line defines a new function called "Math.tanh" with one parameter called "x".\n// line 2: This line creates a new variable called "y" and assigns it the value of Math.exp(2 * x). Math.exp() is a built-in JavaScript function that returns the exponential of a number. In this case, it is the exponential of 2 times the parameter "x".\n// line 3: This line returns the value of (y - 1) / (y + 1) which is the result of the tanh function.',
    useCase:
      "\n\nMath.tanh is used in Javascript to calculate the hyperbolic tangent of a number. It is often used in machine learning applications such as neural networks and deep learning, as well as in signal processing applications such as audio and image processing. The hyperbolic tangent is an important mathematical function that is used to map a real number to a value between -1 and 1. This range makes it useful for representing a wide variety of data, from binary values (on/off, true/false) to weighted values (such as ratings), and is especially useful for representing probabilities.",
  },
  {
    code: "\n\nif (!Math.trunc) {\n\tMath.trunc = function (value) {\n\t\treturn value < 0 ? Math.ceil(value) : Math.floor(value);\n\t};\n}",
    term: "Math.trunc",
    explain:
      '\n\n// This line checks to see if a Math.trunc function already exists. If it does not, one is created.\nif (!Math.trunc) {\n\n// This line defines the Math.trunc function. It takes one argument, "value", which will be rounded either up or down depending on whether it is positive or negative.\n\tMath.trunc = function (value) {\n\t\treturn value < 0 ? Math.ceil(value) : Math.floor(value);\n\t};\n}',
    useCase:
      "\n\nMath.trunc is used in Javascript to remove the decimal part of a number and return the integer part. This is useful when you need to perform calculations with only whole numbers, or when you want to round a number down to its nearest integer.",
  },
  {
    code: "\n\nif (!MediaQueryList.prototype.addEventListener) {\n  MediaQueryList.prototype.addEventListener = function (eventName, callback) {\n    if (eventName === 'change') {\n      var that = this;\n      this.listener = function () {\n        callback.call(that);\n      }\n      this._setListener();\n    }\n  }\n}",
    term: "MediaQueryList.prototype.addEventListener",
    explain:
      '\n\n// Line 1: This line checks if the prototype of MediaQueryList has an "addEventListener" property. If it does not have it, the code inside the if statement will be executed.\n// Line 2: This line creates an "addEventListener" property for the MediaQueryList prototype with a function as value. The function takes two parameters, eventName and callback.\n// Line 3: This line checks if the eventName is equal to "change". If it is, then the code inside the if statement will be executed.\n// Line 4: This line creates a variable called "that" that references the MediaQueryList object.\n// Line 5: This line creates a "listener" property for the MediaQueryList object and sets it to a function that calls the callback function with the MediaQueryList object as the context.\n// Line 6: This line calls the "_setListener" method which is responsible for setting up the listener.',
    useCase:
      "\n\nMediaQueryList.prototype.addEventListener is used in Javascript to allow developers to easily respond to changes in a media query. This allows developers to detect when the size of the viewport has changed, so they can adjust the layout of their application accordingly. This is especially useful for responsive websites, as it allows the website to respond to the user's viewport size and adjust accordingly.",
  },
  {
    code: "\n\nif(!window.MediaQueryList.prototype.removeEventListener){\n\twindow.MediaQueryList.prototype.removeEventListener = function(type, listener){\n\t\tif (this.listeners[type] && this.listeners[type].length > 0){\n\t\t\tlet newListeners = this.listeners[type].filter(f => f !== listener);\n\t\t\tthis.listeners[type] = newListeners;\n\t\t}\n\t}\n}",
    term: "MediaQueryList.prototype.removeEventListener",
    explain:
      "\n\n//This line is checking to see if the MediaQueryList.prototype object has a removeEventListener method. If it does not, then the following code will be executed.\nif(!window.MediaQueryList.prototype.removeEventListener){\n\n// This line adds the removeEventListener method to the MediaQueryList.prototype object\n\twindow.MediaQueryList.prototype.removeEventListener = function(type, listener){\n\n// This line checks to see if the listeners object has a type property, and if it does, if the length of that property is greater than 0.\n\t\tif (this.listeners[type] && this.listeners[type].length > 0){\n\n// This line creates a new array of listeners that excludes the listener that is being removed. \n\t\t\tlet newListeners = this.listeners[type].filter(f => f !== listener);\n\n// This line sets the value of the type property of the listeners object to the new array of listeners.\n\t\t\tthis.listeners[type] = newListeners;\n\t\t}\n\t}\n}",
    useCase:
      "\n\nMediaQueryList.prototype.removeEventListener is used in Javascript to remove an event listener from a MediaQueryList. This allows for the removal of the media query listener from the specified MediaQueryList instance so that it will no longer be triggered when the media query matches. This is useful for cleaning up after using a media query listener and preventing any unnecessary updates or triggers.",
  },
  {
    code: "\n\n// Polyfill for MutationObserver\n\n(function (global) {\n  \n  // MutationObserver Polyfill\n  // ***\n  // \n  // This is a polyfill for the MutationObserver interface. It is based on the \n  // implementation in the [Mutation Summary library](https://github.com/rafaelw/mutation-summary). \n  //\n  // The interface is based on the [WebKit MutationObserver](https://www.w3.org/TR/dom/#mutation-observers) \n  // interface. The main difference is that the native implementation supports \n  // both childList and attributes mutations whereas this polyfill only supports \n  // childList mutations.\n\n  // The MutationSummary constructor\n  function MutationSummary(opts) {\n    this.connected = false;\n    this.options = opts; \n    this.observerOptions = opts.observerOptions || {\n      childList: true, \n      subtree: true\n    };\n    this.rootNode = opts.rootNode;\n    this.callback = opts.callback;\n    this.elementFilter = Array.prototype.concat.apply([], opts.queries).map(normalizeElementString);\n    this.calcReordered = opts.queries.some(function(query) {\n      return query.characterDataOnly;\n    });\n\n    // This object stores the observers\n    this.observerSummaries = [];\n\n    // This flag is used to track whether a node's children have already been\n    // tracked by the observers\n    this.alreadyTracked = false;\n\n    // This flags keep track of changes tracked by the observers\n    this.changesToReport = {\n      added: [],\n      removed: []\n    };\n\n    // This flag allows us to detect any changes made from the callback\n    this.pendingChanges = false;\n\n    this.connected = true;\n    this.observeChanges();\n  }\n\n  // Static function for resetting the status property of the MutationSummary\n  MutationSummary.resetStatus = function() {\n    this.connected = false;\n    this.observerSummaries.forEach(function(summary) {\n      if (summary.observer) {\n        summary.observer.disconnect();\n      }\n    });\n    this.observerSummaries = [];\n    this.alreadyTracked = false;\n    this.changesToReport = {\n      added: [],\n      removed: []\n    };\n    this.pendingChanges = false;\n  };\n\n  // Static function for disconnecting from the MutationSummary\n  MutationSummary.disconnect = function() {\n    this.resetStatus();\n    this.connected = false;\n  };\n\n  // Connect to the MutationSummary and begin observing for changes\n  MutationSummary.prototype.observeChanges = function() {\n    // Check if the MutationSummary is already connected\n    if (!this.connected) {\n      return;\n    }\n\n    // Create the observers\n    this.createSummaries();\n\n    // Connect the observers\n    this.observerSummaries.forEach(function(summary) {\n      summary.observer.observe(summary.target, summary.options);\n    });\n  };\n\n  // Disconnect from the MutationSummary and stop observing for changes\n  MutationSummary.prototype.disconnect = function() {\n    MutationSummary.disconnect.call(this);\n  };\n\n  // Create observer summaries\n  MutationSummary.prototype.createSummaries = function() {\n    // Check if the MutationSummary is already connected\n    if (!this.connected) {\n      return;\n    }\n\n    // Create the observer summaries\n    if (this.observerSummaries.length) {\n      // If the summaries already exist, disconnect them\n      this.observerSummaries.forEach(function(summary) {\n        summary.observer.disconnect();\n      });\n      this.observerSummaries = [];\n    }\n\n    // Go through each query and create an observer for each one\n    this.options.queries.forEach(function(query) {\n      var target = this.rootNode;\n      var options = this.observerOptions;\n      if (query.elementFilter) {\n        target = this.rootNode.querySelectorAll(query.elementFilter);\n        options.attributeFilter = query.attributeFilter;\n      }\n      this.observerSummaries.push({\n        target: target, \n        options: options\n      });\n    }, this);\n  };\n\n  // Callback to be called on mutations\n  MutationSummary.prototype.onMutations = function(summaries) {\n    // Check if the MutationSummary is still connected\n    if (!this.connected) {\n      return;\n    }\n    // If the callback is being called as a result of changes made from the\n    // callback, then we don't want to process those changes\n    if (this.pendingChanges) {\n      this.pendingChanges = false;\n      return;\n    }\n    // Get the mutations for each summary\n    summaries.forEach(function(summary) {\n      this.getMutations(summary);\n    }, this);\n    // If the changes are for a single element, then we can just pass the\n    // single element in the callback. Otherwise, we need to pass the entire\n    // set of changes\n    var changes = this.changesToReport.added.length ? \n      this.changesToReport.added : \n      this.changesToReport;\n    this.callback(changes);\n    // Reset the changes\n    this.resetChanges();\n  };\n\n  // Get the mutations for the given summary\n  MutationSummary.prototype.getMutations = function(summary) {\n    summary.takeRecords().forEach(function(record) {\n      if (this.alreadyTracked) {\n        // If we've already tracked the changes, then we just need to check\n        // to see if any elements were added or removed\n        this.checkElementFilter(record);\n      } else {\n        // Otherwise, we need to check each element in the record to see if\n        // it matches the filter\n        this.checkElementList(record.addedNodes, 'added');\n        this.checkElementList(record.removedNodes, 'removed');\n      }\n    }, this);\n  };\n\n  // Check the element list for any elements that match the filter\n  MutationSummary.prototype.checkElementList = function(elementList, type) {\n    for (var i = 0, len = elementList.length; i < len; i++) {\n      this.checkElementFilter(elementList[i], type);\n    }\n  };\n\n  // Check if the given element matches the filter\n  MutationSummary.prototype.checkElementFilter = function(node, type) {\n    if (!node.nodeType === 1) {\n      return;\n    }\n    type = type || 'added';\n    var elementId = node.id || node.getAttribute('id');\n    var matchesFilter = this.elementFilter.indexOf(elementId) > -1;\n    if (matchesFilter) {\n      if (this.calcReordered && type === 'added') {\n        // If we need to track reordered elements, then we should check to \n        // see if the element has been moved\n        this.checkReordered(node);\n      } else {\n        // Otherwise, just add it to the changes\n        this.addChange(node, type);\n      }\n    }\n  };\n\n  // Check to see if the element has been reordered\n  MutationSummary.prototype.checkReordered = function(node) {\n    // If the element has no previous element, then it's definitely been \n    // added\n    if (!node.previousElementSibling) {\n      this.addChange(node, 'added');\n    } else {\n      // Otherwise, check to see if it's in the same position as it was\n      // before\n      var previousIndex = this.getNodeIndex(node.previousElementSibling);\n      var currentIndex = this.getNodeIndex(node);\n      if (previousIndex !== currentIndex) {\n        this.addChange(node, 'added');\n      }\n    }\n  };\n\n  // Get the index of the given node relative to its siblings\n  MutationSummary.prototype.getNodeIndex = function(node) {\n    var index = 0;\n    while (node = node.previousElementSibling) {\n      index++;\n    }\n    return index;\n  };\n\n  // Add the given node to the changes to be reported\n  MutationSummary.prototype.addChange = function(node, type) {\n    this.changesToReport[type].push(",
    term: "MutationObserver",
    explain:
      "node);\n  };\n\n  // Reset the changes to be reported\n  MutationSummary.prototype.resetChanges = function() {\n    this.changesToReport = {\n      added: [],\n      removed: []\n    };\n  };\n\n  // Normalize an element string\n  function normalizeElementString(str) {\n    return str.replace(/^#/, '');\n  }\n\n  global.MutationSummary = MutationSummary;\n\n})(this);\n\n// This code is a polyfill for the MutationObserver interface. It creates a MutationSummary constructor which takes in a set of options and creates a new MutationSummary instance. The options include a rootNode, a callback, and queries. The rootNode is the root node which the MutationSummary will observe for changes. The callback is the function which will be called every time a mutation is observed. The queries are used to specify which elements the MutationSummary should observe and which attributes it should listen for changes on. \n\n// The code then sets up some default values, such as connected set to false, and an observerOptions property set to {childList: true, subtree: true}. It then creates a new MutationSummary and sets the connected property to true. \n\n// The code then defines two static functions, resetStatus and disconnect, which are used to reset and disconnect from the MutationSummary. \n\n// Finally, the code defines the observeChanges and disconnect functions, which are used to connect and disconnect from the MutationSummary, as well as the onMutations and getMutations functions, which are used to get the mutations for the given summary. It also defines some helper functions, such as checkElementFilter, checkElementList, checkReordered, and getNodeIndex, which are used to check if the given element matches the filter and to get the index of the given node relative to its siblings.",
    useCase:
      "\n\nMutationObserver is used in JavaScript to detect and react to changes in the DOM (Document Object Model). It allows developers to observe and respond to changes in the DOM, such as when elements are added, removed, or modified. This provides a powerful way to create dynamic and interactive websites and applications. It also allows developers to write code that reacts to changes in the DOM in an efficient and performant manner.",
  },
  {
    code: "\n\nif (Navigator.prototype.geolocation === undefined) { \n  Navigator.prototype.geolocation = { \n    getCurrentPosition: function(successHandler, errorHandler, options) { \n      //Create a dummy position object \n      let position = { \n        coords: { \n          latitude: 0, \n          longitude: 0 \n        } \n      };\n      successHandler(position);\n    }\n  };\n}",
    term: "Navigator.prototype.geolocation",
    explain:
      "\n\n// This line checks if the geolocation property is undefined on the Navigator prototype\nif (Navigator.prototype.geolocation === undefined) { \n\n// This line adds a geolocation property to the Navigator prototype with a getCurrentPosition method\n  Navigator.prototype.geolocation = { \n    getCurrentPosition: function(successHandler, errorHandler, options) { \n\n// This line creates a dummy position object with a latitude and longitude value of 0\n      let position = { \n        coords: { \n          latitude: 0, \n          longitude: 0 \n        } \n      };\n\n// This line calls the successHandler and passes the dummy position object as an argument \n      successHandler(position);\n    }\n  };\n}",
    useCase:
      "\n\nNavigator.prototype.geolocation is used in Javascript to access the Geolocation API, which allows web applications to access a user's location information. This information can then be used to display relevant content or provide services tailored to the user's location. It can also be used to help track user activity or analyze user behavior.",
  },
  {
    code: "\n\n// Check if the browser supports Node.prototype.contains\nif (!Node.prototype.contains) {\n  // Define contains method\n  Node.prototype.contains = function (node) {\n    // While node given is not the one we are looking for\n    while (node !== null) {\n      // If given node matches the node we are looking for\n      if (node === this) {\n        // Return true\n        return true;\n      }\n      // Check the parent node\n      node = node.parentNode;\n    }\n    // Return false if a match is not found\n    return false;\n  };\n}",
    term: "Node.prototype.contains",
    explain:
      "\n\n// This code checks if the browser supports Node.prototype.contains. \n// If not, it defines the contains method which enables the browser to check if a given node matches the node it is looking for. \n// The contains method loops through the parent node until a match is found or until it reaches the top of the node tree. \n// If a match is found, it returns true, otherwise it returns false.",
    useCase:
      "\n\nNode.prototype.contains is used in Javascript to determine if a given node is a descendant of another node. This method can be used to check if a child node is contained within its parent node, or if a node contains a particular element. It is useful for traversing a DOM tree and can be used to check if a node is a descendant of a parent node, or if a node is a sibling.",
  },
  {
    code: "\n\nif (!Node.prototype.isSameNode) {\n  Node.prototype.isSameNode = function(node) {\n    return this === node;\n  }\n}",
    term: "Node.prototype.isSameNode",
    explain:
      "\n\n// Line 1: This line checks if the Node prototype object has the isSameNode method. \n// If it does not, then the following code is executed.\n\n// Line 2: This line adds the isSameNode method to the Node prototype object. \n// The method takes in a node as a parameter and returns true if the two nodes are the same.",
    useCase:
      "\n\nNode.prototype.isSameNode is used in Javascript to compare two nodes to determine if they are the same. This method returns a boolean value, true if the nodes are the same, and false if they are not. This helps developers to quickly and easily determine if two nodes are equal.",
  },
  {
    code: "\n\nif(NodeList.prototype.@@iterator === undefined){\n  NodeList.prototype[Symbol.iterator] = function(){\n    let _this = this;\n    let _index = 0;\n    return {\n      next(){\n        if(_index < _this.length){\n          return {\n            value: _this[_index++],\n            done: false\n          };\n        }\n        else{\n          return {\n            done: true\n          };\n        }\n      }\n    };\n  };\n}",
    term: "NodeList.prototype.@@iterator",
    explain:
      "\n\n// if NodeList.prototype.@@iterator is equal to undefined \n// then assign a function to NodeList.prototype[Symbol.iterator]\n// this function takes no arguments\n// it creates a variable called _this and assigns it to this\n// it creates a variable called _index and assigns it to 0\n// it then returns an object\n// this object has a next function which takes no arguments\n// if _index is less than the length of _this, return an object\n// this object has a value property which is the value of _this at the index of _index and increment _index\n// the object has a done property which is set to false\n// else return an object with done set to true",
    useCase:
      "\n\nNodeList.prototype.@@iterator is used in Javascript to provide an iterator for NodeList objects. This allows developers to easily loop through NodeList objects and access their contents using the for...of syntax. It also helps improve the performance of NodeList operations, as the iterator will only traverse the list once instead of multiple times.",
  },
  {
    code: "\n\nif (window.NodeList && !NodeList.prototype.forEach) {\n  NodeList.prototype.forEach = function(callback, thisArg) {\n    thisArg = thisArg || window;\n    for (var i = 0; i < this.length; i++) {\n      callback.call(thisArg, this[i], i, this);\n    }\n  };\n}",
    term: "NodeList.prototype.forEach",
    explain:
      "\n\n//line 1: \n//This line checks if the window object has a NodeList property and if there is no forEach method in the NodeList prototype. \n\n//line 2: \n//This line adds a forEach method to the NodeList prototype. \n\n//line 3: \n//This line sets the thisArg variable to either the window object or the argument passed in. \n\n//line 4: \n//This line creates a for loop that iterates over the NodeList and passes each element, the index of the element, and the NodeList itself to the callback function. \n\n//line 5: \n//This line calls the callback function with the thisArg variable as the context, the current element, the index of the element, and the NodeList itself. ",
    useCase:
      "\n\nNodeList.prototype.forEach is used in Javascript because it provides the ability to iterate over all the elements in a NodeList, which is a collection of nodes returned from a DOM query. It allows developers to execute a function on each of the elements in the NodeList, making it easier to apply certain changes or logic to multiple elements quickly and easily.",
  },
  {
    code: "\n\nif(Number.EPSILON === undefined) {\n    Number.EPSILON = Math.pow(2, -52);\n}",
    term: "Number.EPSILON",
    explain:
      "\n\n// This line of code checks if Number.EPSILON is undefined. If it is, it assigns Number.EPSILON to the value of Math.pow(2, -52). This is done to define the smallest value possible for a number in JavaScript.",
    useCase:
      "\n\nNumber.EPSILON is used in JavaScript to represent the smallest possible number that can be represented in the language. This is important for accurately comparing two numbers, especially when precise calculations are required. It helps to ensure that any comparison between two numbers is as precise as possible, and that any calculations involving fractions are handled accurately.",
  },
  {
    code: "\n\nif (!Number.Epsilon) {\n  Number.Epsilon = Math.pow(2, -52);\n}",
    term: "Number.Epsilon",
    explain:
      "\n\n// Line 1: This line is a conditional statement that checks if the constant Number.Epsilon has been defined.\n// Line 2: If the constant Number.Epsilon is not defined, this line will define it as the result of the Math.pow() function, which takes a base and an exponent and returns the result of raising the base to the power of the exponent. In this case, 2 is the base and -52 is the exponent, so the result is a very small number (2^-52).",
    useCase:
      "\n\nNumber.Epsilon is used in JavaScript to represent the difference between the largest possible number that can be represented in the JavaScript Number type and the number that is one greater. It is a very small number (approximately 2.220446049250313e-16) and is used in calculations to ensure that the result is accurate to the smallest degree possible. It is also used to determine if two numbers are equal, as adding or subtracting Number.Epsilon to either number will not change the result.",
  },
  {
    code: "\n\nif (Number.MAX_SAFE_INTEGER === undefined) {\n    Number.MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n}",
    term: "Number.MAX_SAFE_INTEGER",
    explain:
      "\n\n// Line 1: This line checks if the constant Number.MAX_SAFE_INTEGER has been defined. If it has not been defined then the code moves to line 2. \n// Line 2: This line sets the constant Number.MAX_SAFE_INTEGER to the value of Math.pow(2, 53) - 1. This is the highest value that can be represented accurately in JavaScript.",
    useCase:
      "\n\nNumber.MAX_SAFE_INTEGER is used in Javascript to ensure that arithmetic operations performed with numbers within the range of this constant are accurate. It defines the maximum safe integer in JavaScript which is (2^53 - 1). This number is the maximum safe integer that can be reliably used in mathematical operations in JavaScript, as numbers larger than this may lose precision when being operated on.",
  },
  {
    code: "\n\nif (!Number.MIN_SAFE_INTEGER) {\n\tNumber.MIN_SAFE_INTEGER = -Math.pow(2, 53) - 1;\n}",
    term: "Number.MIN_SAFE_INTEGER",
    explain:
      "\n\nLine 1: This line performs a logical check to see if the Number.MIN_SAFE_INTEGER variable has been previously declared. If it has not been declared, the code will proceed to line 2.\n\nLine 2: If the Number.MIN_SAFE_INTEGER variable has not been declared, then this line sets its value to the maximum safe integer value that can be represented in JavaScript. This value is calculated by subtracting 1 from the result of 2 raised to the power of 53. The result is the lowest safe integer that can be represented in JavaScript.",
    useCase:
      "\n\nNumber.MIN_SAFE_INTEGER is used in Javascript as it provides a consistent lower bound for safe integer operations. This is important as the native Number type in Javascript can only represent numbers up to a certain precision, which can lead to unexpected results when dealing with very large or very small numbers. By providing a consistent lower bound, Number.MIN_SAFE_INTEGER helps ensure that any operations involving numbers outside of the safe range will be properly handled.",
  },
  {
    code: "\n//\nfunction isFinite(value) {\n  if (value === Infinity || value === -Infinity || typeof value !== 'number') {\n    return false;\n  }\n  return !Number.isNaN(value);\n}",
    term: "Number.isFinite",
    explain:
      "\n\n//This function will check if the given value is finite or not.\n//Line 1: The function is named isFinite and takes a value as a parameter.\n//Line 2: If the value is equal to Infinity, negative Infinity, or not a number, it will return false.\n//Line 3: If the value is not one of the above, it will check to see if it is not NaN (not a number) and return the result.",
    useCase:
      "\n\nNumber.isFinite is used in JavaScript to determine whether a given value is a finite number. It is a convenient method for validating user input and ensuring that the values are within the valid range. It is also useful for preventing overflows and underflows by checking if a number is too small or too large.",
  },
  {
    code: "\n\nNumber.isInteger = Number.isInteger || function(value) {\n  return typeof value === 'number' && \n         isFinite(value) && \n         Math.floor(value) === value;\n};",
    term: "Number.isInteger",
    explain:
      '\n\n// 1. Number.isInteger = Number.isInteger || \n// This line creates a function called isInteger and assigns it to the Number object. This line also uses the logical OR operator (||) to check if the function already exists and if it does, it assigns it to the Number object.\n\n// 2. function(value) {\n// This line defines a function that takes in a single argument, which is referred to as "value".\n\n// 3. return typeof value === \'number\' && \n// This line returns the type of the "value" argument and checks whether it is a number.\n\n// 4. isFinite(value) && \n// This line checks if the argument "value" is a finite number.\n\n// 5. Math.floor(value) === value;\n// This line uses the Math.floor() method to round down the "value" argument to the nearest integer and then checks if it is equal to the original argument.',
    useCase:
      "\n\nNumber.isInteger is used in JavaScript to determine whether a value is an integer or not. This is helpful when validating user input, as it can quickly determine if a value is an integer or not without having to manually check for a decimal point. It is also useful for ensuring that mathematical operations are being performed on integer values, as it can prevent errors from occurring due to working with non-integer values.",
  },
  {
    code: "\n\nif (Number.isNaN === undefined) {\n  Number.isNaN = function (value) {\n    return typeof value === 'number' && isNaN(value);\n  };\n}",
    term: "Number.isNaN",
    explain:
      "\n\n// line 1: This line checks if the Number.isNaN function is defined or not.\n// line 2: If Number.isNaN is undefined, then this line defines the function.\n// line 3: This line is the body of the Number.isNaN function. It checks if the value given as an argument is a number and is NaN (not a number).",
    useCase:
      "\n\nNumber.isNaN is used in JavaScript to determine whether a value is NaN (Not-a-Number). It is important to know that JavaScript's typeof operator considers NaN to be a number, so this method can be used to differentiate between a number and NaN.",
  },
  {
    code: "\n\nif(Number.isSafeInteger === undefined){\n  Number.isSafeInteger = function(n){\n    return typeof n === 'number' && \n      Math.round(n) === n && \n      n >= Number.MIN_SAFE_INTEGER &&\n      n <= Number.MAX_SAFE_INTEGER;\n  };\n}",
    term: "Number.isSafeInteger",
    explain:
      "\n\n// Line 1: This line is checking if the Number.isSafeInteger function is already defined. \n// If it is not, the code will proceed to the next line. \n\n// Line 2: This line is defining the Number.isSafeInteger function. It will be used to check if a number is a safe integer.\n\n// Line 3: This line is checking if the input number is of type number.\n\n// Line 4: This line is checking if the input number is equal to itself after rounding.\n\n// Line 5: This line is checking if the input number is greater than or equal to the minimum safe integer.\n\n// Line 6: This line is checking if the input number is less than or equal to the maximum safe integer.",
    useCase:
      "\n\nNumber.isSafeInteger is used in Javascript to determine whether a given value is a safe Integer. This is important because some numbers, when represented as floating point numbers, can produce inaccurate results due to rounding errors. By using Number.isSafeInteger, developers can ensure that they are working with a number that can be accurately represented and is not susceptible to these errors.",
  },
  {
    code: "\n\nif (!Number.parseFloat) {\n  Number.parseFloat = function(n) {\n    return parseFloat(n);\n  };\n}",
    term: "Number.parseFloat",
    explain:
      "\n\n// Line 1: This checks to see if the parseFloat() function is available on the Number object. If it is not available, \n// then it will proceed to the next line.\n\n// Line 2: This creates the parseFloat() function on the Number object, if it was not previously available. It is a \n// function that takes in a number as a parameter and returns the parsed float value.",
    useCase:
      "\n\nNumber.parseFloat is used in JavaScript to convert a string into a floating-point number. This function is useful for ensuring that a value entered by a user is a valid number, as it will return NaN if the string provided is not a valid number. It is also useful when dealing with decimal numbers, as it can convert the string into a decimal number, rather than an integer.",
  },
  {
    code: "\n\nif (!Number.parseInt) {\n    Number.parseInt = function(value, radix) {\n        if (radix == null) {\n            radix = 10;\n        }\n        var string = \"\" + value;\n        var result = +string.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n        if ((!isFinite(result) || result < -90 || result > 90) ||\n            (radix < 2 || radix > 36)) {\n            return NaN;\n        }\n        return parseInt(result, radix);\n    }\n}",
    term: "Number.parseInt",
    explain:
      "\n\n// Line 1:\n// This line checks if the Number.parseInt function is already defined. If it isn't, then the code in the code block will be executed. \n\n// Line 2:\n// This line defines the Number.parseInt function. The value and radix parameters are passed as arguments.\n\n// Line 3:\n// This line assigns the radix parameter a default value of 10, if it is not provided.\n\n// Line 4:\n// This line assigns the string variable the value of the argument passed to the function.\n\n// Line 5:\n// This line uses the replace() method to remove any whitespace characters from the start and end of the string. It then assigns the resulting string to the result variable.\n\n// Line 6:\n// This line checks if the result is a valid number, if it is less than -90 or greater than 90, or if the radix is less than 2 or greater than 36. If any of these conditions are true, the function returns NaN.\n\n// Line 8:\n// This line calls the built-in parseInt() function, passing it the result and the radix as arguments. The result of this function call is then returned.",
    useCase:
      "\n\nNumber.parseInt is used in Javascript to convert a string or a number represented as a string into an integer. This is useful for ensuring that numbers are properly formatted before they are used in calculations or other operations.",
  },
  {
    code: "\n\nif (typeof Object.assign != 'function') {\n    Object.assign = function(target) {\n        'use strict';\n        if (target == null) {\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        target = Object(target);\n        for (var index = 1; index < arguments.length; index++) {\n            var source = arguments[index];\n            if (source != null) {\n                for (var key in source) {\n                    if (Object.prototype.hasOwnProperty.call(source, key)) {\n                        target[key] = source[key];\n                    }\n                }\n            }\n        }\n        return target;\n    };\n}",
    term: "Object.assign",
    explain:
      "\n\n// Line 1: Check if Object.assign is a function.\n// Reason: Object.assign is a function to copy the values of all enumerable own properties from one or more source objects to a target object. \n\n// Line 2-17: If Object.assign is not a function, then define a new function.\n// Reason: Define a new function for Object.assign if it is not a function.\n\n// Line 3: Declare a target variable.\n// Reason: Declare a target variable which will be an object.\n\n// Line 4: Use strict mode.\n// Reason: Use strict mode so that variables must be declared before use.\n\n// Line 5: Check if the target is undefined or null.\n// Reason: Check if the target is undefined or null.\n\n// Line 6: Make sure the target is an object.\n// Reason: Make sure the target is an object.\n\n// Line 7: Create a loop to iterate through the arguments.\n// Reason: Create a loop to iterate through the arguments.\n\n// Line 8: Declare a source variable.\n// Reason: Declare a source variable which will be an object.\n\n// Line 9: Check if the source is undefined or null.\n// Reason: Check if the source is undefined or null.\n\n// Line 10-15: Loop through the source object and copy the properties and values to the target object.\n// Reason: Loop through the source object and copy the properties and values to the target object.\n\n// Line 16: Return the target object.\n// Reason: Return the target object.",
    useCase:
      "\n\nObject.assign is used in JavaScript to merge the contents of two or more objects together into a single object. This can be useful for copying the values of one object to another, or for combining multiple objects into a single object to be used. It can also be useful when you need to create a new object based on the properties of existing objects.",
  },
  {
    code: "\n\nif (!Object.create) {\n  Object.create = function(o) {\n    if (arguments.length > 1) {\n      throw new Error ('Object.create implementation only accepts the first parameter.');\n    }\n    function F() {}\n    F.prototype = o;\n    return new F();\n  };\n}",
    term: "Object.create",
    explain:
      "\n\n//This line checks if the Object.create method has already been defined. If it hasn't, the subsequent code block will be executed. \nif (!Object.create) {\n\n//This line creates a function called Object.create that takes one parameter, o.\nObject.create = function(o) {\n\n//This line checks if the number of arguments passed to Object.create is greater than 1. If it is, an error will be thrown.\nif (arguments.length > 1) {\n  throw new Error ('Object.create implementation only accepts the first parameter.');\n}\n\n//This line creates a function called F.\nfunction F() {}\n\n//This line sets the prototype of F to o.\nF.prototype = o;\n\n//This line returns a new instance of F. \nreturn new F();\n};\n}",
    useCase:
      "\n\nObject.create is used to create an object with the prototype of a given object. It allows for more precise control over how an object is created and what its prototype will be. This is especially useful in inheritance-based programming, as it allows for the creation of objects that have the same properties and behaviors of another object. This is useful for implementing inheritance-based design patterns, such as the prototype pattern, or creating objects with shared functionality.",
  },
  {
    code: "\n\nObject.defineProperties = Object.defineProperties || function(obj, props) {\n  for (var prop in props) {\n    Object.defineProperty(obj, prop, props[prop]);\n  }\n  return obj;\n};",
    term: "Object.defineProperties",
    explain:
      "\n\n//Line 1: This line is checking whether the Object.defineProperties function is already defined. If it is not, it assigns the function definition on the right side of the operator to Object.defineProperties. \n//Line 2: This is the start of the function definition. The function takes two arguments: obj and props.\n//Line 3: This line is a for loop that iterates through each property in the props object.\n//Line 4: This line calls the Object.defineProperty function to define a new property on the obj object. The property's name is taken from the prop variable and its value is taken from the props object.\n//Line 5: This line returns the obj object.",
    useCase:
      "\n\nObject.defineProperties is used in JavaScript to add new or modify existing properties directly on an object. It allows for the addition of getters and setters to an object, which can be used to control how the property is accessed and set. It also allows for the addition of new properties to an object, and can be used to define multiple properties at once on an object. This makes it a useful tool for creating custom objects with specific properties and behaviors.",
  },
  {
    code: "\n\nif (!Object.defineProperty) {\n    Object.defineProperty = function (obj, prop, descriptor) {\n        if (descriptor.get) {\n            obj.__defineGetter__(prop, descriptor.get);\n        }\n        if (descriptor.set) {\n            obj.__defineSetter__(prop, descriptor.set);\n        }\n        if (!descriptor.configurable) {\n            obj[prop] = descriptor.value;\n        }\n    }\n}",
    term: "Object.defineProperty",
    explain:
      "\n\n//Line 1\n//This line checks if the Object.defineProperty function is available in the current environment. If it is not available, the code within the if statement will be executed.\n\n//Line 2\n//This line creates a function called Object.defineProperty and assigns it to the Object object.\n\n//Line 3\n//This line checks if the descriptor passed to the function has a get property. If it does, the code within the if statement will be executed.\n\n//Line 4\n//This line assigns the descriptor's get property to the obj's __defineGetter__ property.\n\n//Line 5\n//This line checks if the descriptor passed to the function has a set property. If it does, the code within the if statement will be executed.\n\n//Line 6\n//This line assigns the descriptor's set property to the obj's __defineSetter__ property.\n\n//Line 7\n//This line checks if the descriptor passed to the function has a configurable property set to false. If it does, the code within the if statement will be executed.\n\n//Line 8\n//This line assigns the descriptor's value to the obj's property.",
    useCase:
      "\n\nObject.defineProperty is used in Javascript to define a new property on an object, or modify an existing property on an object. It allows for precise control over how the property is defined, including its enumerability, configurability, and writability. Additionally, it allows for the use of accessor properties, which are properties that don't actually store a value but instead execute a getter and setter function when accessed.",
  },
  {
    code: "\n\nif (!Object.entries) {\n  Object.entries = function(obj) {\n    var ownProps = Object.keys(obj),\n        i = ownProps.length,\n        resArray = new Array(i); // preallocate the Array\n    while (i--)\n      resArray[i] = [ownProps[i], obj[ownProps[i]]];\n  \n    return resArray;\n  };\n}",
    term: "Object.entries",
    explain:
      "\n\n// Line 1: \n// This is a conditional statement that checks if a function called Object.entries() exists. \n\n// Line 2:\n// If Object.entries does not exist, then this line of code creates a new function called Object.entries which takes in one parameter called obj.\n\n// Line 3:\n// This line creates a variable called ownProps which stores an array of strings that represent the keys of the object.\n\n// Line 4:\n// This line creates a variable called i and sets its value to the length of the array stored in ownProps.\n\n// Line 5:\n// This line creates a new array called resArray and sets its length to the value of the variable i.\n\n// Line 6-8:\n// This loop iterates through the array stored in ownProps, and assigns the key and the value of the obj to an element in the resArray. \n\n// Line 9:\n// This line returns the resArray.",
    useCase:
      "\n\nObject.entries is used in Javascript to convert an object into an array of key-value pairs. It allows developers to quickly and easily access the keys and values of an object. This is especially useful for looping through objects to access their properties or for performing tasks on each item in an object.",
  },
  {
    code: "\n\nif (!Object.freeze) {\n\tObject.freeze = function (obj) {\n\t\t// Retrieve the property names defined on obj\n\t\tvar propNames = Object.getOwnPropertyNames(obj);\n\n\t\t// Freeze properties before freezing self\n\t\tpropNames.forEach(function (name) {\n\t\t\tvar prop = obj[name];\n\n\t\t\t// Freeze prop if it is an object\n\t\t\tif (typeof prop == 'object' && prop !== null) {\n\t\t\t\tObject.freeze(prop);\n\t\t\t}\n\t\t});\n\n\t\t// Freeze self (no-op if already frozen)\n\t\treturn Object.seal(obj);\n\t};\n}",
    term: "Object.freeze",
    explain:
      "\n\n//This code checks to see if the `Object.freeze` method exists, and if it doesn't then it creates a new function that will freeze an object.\n\n//Line 1:\n//Checks if the `Object.freeze` method already exists. If it doesn't then the code inside the `if` statement will be executed.\n\n//Line 2:\n//Creates a new function called `Object.freeze` that takes in a parameter called `obj`.\n\n//Line 3:\n//Retrieves the property names of the object passed in as the parameter within the `Object.freeze` function.\n\n//Line 4-8:\n//Iterates through each of the property names and checks if the type of the property is an object and if it isn't `null`. If it is, then it calls the `Object.freeze` method on the property.\n\n//Line 9:\n//Seal the object passed in as the parameter within the `Object.freeze` function. This will freeze the object so that its properties cannot be changed.",
    useCase:
      "\n\nObject.freeze is used in JavaScript to prevent any existing properties from being changed or removed from an object. This prevents the object from being modified and helps keep data secure and consistent. This method is useful for preventing accidental or malicious changes to an object, and is often used for configuration objects or objects that are shared between multiple users or applications.",
  },
  {
    code: "\n\n\nconst fromEntries = (arr) => \n  arr.reduce((acc, [key, val]) => (acc[key] = val, acc), {})",
    term: "Object.fromEntries",
    explain:
      "\n\n//1. const fromEntries = (arr) => \n// This line declares a constant called fromEntries and sets it equal to a function that takes one parameter called arr.\n\n//2. arr.reduce((acc, [key, val]) => \n//This line calls the reduce method on the arr parameter. The reduce method takes two arguments, an accumulator (acc) and an array containing two elements, the first of which is the key and the second of which is the value.\n\n//3. (acc[key] = val, acc)\n// This line sets the value of the key in the accumulator to the value passed in, and then returns the accumulator.\n\n//4. {}\n// This line is the initial value for the accumulator. It is an empty object.",
    useCase:
      "\n\nObject.fromEntries is used in JavaScript to convert an iterable (such as an Array or Map) of key-value pairs into an object. This can be useful when you need to convert existing data into an object, or when you are working with an API that returns an array of data and you need to parse it into an object.",
  },
  {
    code: "\n\nif (!Object.getOwnPropertyDescriptor) {\n  Object.getOwnPropertyDescriptor = function(obj, prop) {\n    const descriptor = {\n      enumerable: Object.prototype.propertyIsEnumerable.call(obj, prop),\n      configurable: true\n    };\n    let getter = obj.__lookupGetter__(prop);\n    let setter = obj.__lookupSetter__(prop);\n\n    if (getter || setter) {\n      if (getter) {\n        descriptor.get = getter;\n      }\n\n      if (setter) {\n        descriptor.set = setter;\n      }\n    } else {\n      descriptor.value = obj[prop];\n    }\n\n    return descriptor;\n  };\n}",
    term: "Object.getOwnPropertyDescriptor",
    explain:
      "\n\n// Line 1: \n// If the browser does not have the Object.getOwnPropertyDescriptor method, then create the function.\n\n// Line 2: \n// Create an object descriptor, which will be returned by the function. The descriptor will have two properties, enumerable and configurable, both of which will be set to true.\n\n// Line 3:\n// Get the getter and setter for the specified property if they exist.\n\n// Line 4-7:\n// If the getter or setter exist, then create an object descriptor with the get and set properties set to the getter and setter.\n\n// Line 8-10:\n// If the getter or setter don't exist, then the value of the property will be used.",
    useCase:
      "\n\nObject.getOwnPropertyDescriptor is used to retrieve the property descriptor of an object for a given property. It provides information about the property such as whether it is writable, enumerable, configurable and its value. This method is useful for inspecting an object's properties, or for creating a duplicate of an existing object with the same property descriptors. It can also be used to modify the behavior of existing objects by changing their property descriptors.",
  },
];
