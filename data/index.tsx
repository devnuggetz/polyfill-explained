export const DATA = [
  {
    code: "\n\nclass AbortController {\n  constructor() {\n    this.signal = new AbortSignal();\n  }\n \n  abort() {\n    this.signal.abort();\n  }\n}\nclass AbortSignal {\n  constructor(){\n    this.aborted = false;\n    this.onabort = null;\n  }\n \n  get aborted(){\n    return this.aborted;\n  }\n \n  set onabort(handler){\n    if (this.onabort) {\n      throw new DOMException('AbortSignal is already sending a signal', 'InvalidStateError');\n    }\n    this.onabort = handler;\n  }\n \n  toString(){\n    return '[object AbortSignal]';\n  }\n \n  abort(){\n    if (this.onabort) {\n      this.onabort();\n    }\n    this.aborted = true;\n  }\n}",
    term: "AbortController",
    explain:
      "\n\n// 1. class AbortController { - This line creates the AbortController class, which is used to handle the aborting of a network request. \n// 2. constructor() { - This line is the constructor method for this class, which is used to initialize an instance of AbortController.\n// 3. this.signal = new AbortSignal(); - This line creates a new instance of the AbortSignal class and assigns it to the signal property of the AbortController instance.\n// 4. abort() { - This line creates a method on the AbortController class that allows for aborting the network request.\n// 5. class AbortSignal { - This line creates the AbortSignal class, which is used to handle the aborting of a network request.\n// 6. constructor(){ - This line is the constructor method for this class, which is used to initialize an instance of AbortSignal.\n// 7. this.aborted = false; - This line sets the aborted property of the AbortSignal instance to false.\n// 8. this.onabort = null; - This line sets the onabort property of the AbortSignal instance to null.\n// 9. get aborted(){ - This line creates a method on the AbortSignal class that allows for getting the aborted state of the instance.\n// 10. set onabort(handler){ - This line creates a method on the AbortSignal class that allows for setting the onabort handler.\n// 11. toString(){ - This line creates a method on the AbortSignal class that allows for getting the string representation of the instance.\n// 12. abort(){ - This line creates a method on the AbortSignal class that allows for aborting the network request.",
    useCase:
      "\n\nAbortController is used in JavaScript to allow for the cancellation of a request. This is useful for requests that take a long time to complete, such as lengthy API calls. The AbortController provides developers with a way to cancel the request before it completes, freeing up resources and preventing potential errors. Additionally, AbortController can be used to abort any fetch request, even if the API endpoint does not natively support aborting requests.",
  },
  {
    code: "\n\nclass AggregateError extends Error { \n\n  constructor(errors) {\n    if (Array.isArray(errors)) {\n      const message = errors.length > 1 ?\n        `${errors.length} errors occurred` :\n        `An error occurred`;\n      super(message);\n      this.name = 'AggregateError';\n      this.errors = errors;\n    } else {\n      throw new TypeError(`Argument 1 of AggregateError must be an Array`);\n    }\n  }\n}",
    term: "AggregateError",
    explain:
      '\n\n// Line 1: This line creates a class called AggregateError that extends the Error class. This allows us to create objects which inherit the properties and methods of the Error class. \n// Line 2: This line creates a constructor function for the AggregateError class which takes in an array of errors as an argument. \n// Line 3: This line checks if the argument passed into the constructor is an array. \n// Line 4: This line creates a message which will be displayed when the AggregateError object is created. The message will either say "An error occurred" if there is one error, or "X errors occurred" if there are multiple errors.\n// Line 5: This line calls the super() method and passes the created message as an argument. This will set the message property of the AggregateError object to the created message. \n// Line 6: This line sets the name property of the AggregateError object to "AggregateError".\n// Line 7: This line sets the errors property of the AggregateError object to the array of errors passed into the constructor. \n// Line 8: This line throws an error if the argument passed into the constructor is not an array.',
    useCase:
      "\n\nAggregateError is used in JavaScript to provide a single unified type for a variety of errors that may occur in a program. This allows developers to have a consistent way of dealing with errors, regardless of the type of error that occurs. It also allows for a more organized approach to error handling, as developers can catch a single error type and act accordingly, rather than having to consider each type of error separately.",
  },
  {
    code: "\n\nif (!Array.from) {\n  Array.from = function(object) {\n    return [].slice.call(object);\n  };\n}",
    term: "Array.from",
    explain:
      "\n\n// This code checks if the Array.from method is not defined, meaning that the current environment does not support it.\n// If Array.from is not defined, then this code defines it as a function that takes in one parameter, 'object'.\n// The Array.from function will then call the slice method on the array prototype and pass in the 'object' parameter as an argument. \n// This will return a new array with the elements from the passed in 'object' parameter.",
    useCase:
      "\n\nArray.from is used in JavaScript to create a new, shallow-copied Array instance from an array-like or iterable object. It allows you to convert array-like objects, such as arguments objects, NodeList, and other array-like objects into true JavaScript arrays. This is useful when you want to use array methods, such as map, reduce, filter, etc., on an array-like object.",
  },
  {
    code: '\n\nconst ArrayisArray = (arg) => {\n  if (Object.prototype.toString.call(arg) === "[object Array]") {\n    return true;\n  } else {\n    return false;\n  }\n};',
    term: "Array.isArray",
    explain:
      "\n\n// Line 1: This line is declaring a constant variable named 'ArrayisArray' and assigning it with an anonymous function. This function takes one argument named 'arg'. \n// Line 2: This line is using the 'Object.prototype.toString.call' method to convert the 'arg' argument to a string and comparing it to the string value '[object Array]'. \n// Line 3: This line is returning the boolean value 'true' if the comparison in line 2 is true.\n// Line 4: This line is returning the boolean value 'false' if the comparison in line 2 is false.",
    useCase:
      "\n\nArray.isArray is used in JavaScript to determine whether a given value is an array or not. This is useful for checking the data type of a variable before performing operations on it. It is a reliable way to ensure that the data type of a variable is an array and that operations such as iteration and mapping can be performed on it.",
  },
  {
    code: "\n\nif (!Array.of) {\n  Array.of = function() {\n    return Array.prototype.slice.call(arguments);\n  };\n}",
    term: "Array.of",
    explain:
      "\n\n/*\nLine 1: If the Array.of method does not exist,\nReason: This checks to see if the Array.of method already exists, and if not, it will proceed to create it.\n\nLine 2: Array.of = function() {\nReason: This creates the function that will be assigned to the Array.of method.\n\nLine 3: return Array.prototype.slice.call(arguments);\nReason: This returns the arguments passed into the function as an array using the Array.prototype.slice.call method. This allows the Array.of method to take any number of arguments and returns them as an array.",
    useCase:
      "\n\nArray.of is used in JavaScript to create a new Array instance from a variable number of arguments. It allows developers to create an Array instance with a single argument, or with multiple arguments. It also provides an easy way to create an array from a non-array type, such as a string or number.",
  },
  {
    code: "\n\nif (!Array.prototype.hasOwnProperty('@@iterator')) {\n    Object.defineProperty(Array.prototype, '@@iterator', {\n        value: function() {\n            let index = 0;\n\n            return {\n                next: () => {\n                    if (index < this.length) {\n                        return {\n                            value: this[index++],\n                            done: false\n                        };\n                    } else {\n                        return {\n                            value: undefined,\n                            done: true\n                        };\n                    }\n                }\n            }\n        }\n    });\n}",
    term: "Array.prototype.@@iterator",
    explain:
      '\n\n//Line 1:\n//This line checks if the Array prototype does not have a property named "@@iterator".\n\n//Line 2:\n//If the condition is true, then this line uses Object.defineProperty() to define a new property with the specified name and value on the Array prototype.\n\n//Line 3:\n//This line creates a variable called "index" and sets its value to 0.\n\n//Line 4-11:\n//This block defines an iterator which returns the next item in the array when called. It returns an object with two properties: "value" which is the value of the next item in the array and "done" which is a boolean value which is true if the end of the array has been reached. \n\n//Line 12:\n//This line closes the if block from line 2.',
    useCase:
      "\n\nArray.prototype.@@iterator is used in Javascript to create an iterable object for the array. This allows developers to use the iterator protocol to easily loop through the array and access each element in the array. The iterator protocol is a standard way of providing a way to iterate through a collection of data, such as an array. This makes it simple to loop through the array and access each element without having to write custom code.",
  },
  {
    code: "\n\nif (!Array.prototype.at) {\n  Array.prototype.at = function (index) {\n    const length = this.length;\n    if (index >= length || index < 0) {\n      return undefined;\n    }\n\n    return this[index];\n  };\n}",
    term: "Array.prototype.at",
    explain:
      "\n\n// Line 1: This line checks if the array prototype at() method exists. If not, it will proceed to the next line.\n// Line 2: This line adds a at() method to the array prototype, taking an index parameter. \n// Line 3: This line saves the length of the array in a variable.\n// Line 4: This line checks if the index provided is greater than or equal to the length of the array or less than 0. If so, it will return undefined. \n// Line 5: This line returns the value of the array at the specified index.",
    useCase:
      "\n\nArray.prototype.at is used in Javascript to quickly retrieve a specific element from an array without having to iterate through the entire array. This method is especially useful when the index of the element is known, as it is much faster than looping through the array.",
  },
  {
    code: "\n\nif (!Array.prototype.copyWithin) {\n  Array.prototype.copyWithin = function(target, start, end = this.length) {\n    if (start < 0) {\n      start = this.length + start;\n    }\n    if (end < 0) {\n      end = this.length + end;\n    }\n    let last = this.length - 1;\n    for (let i = end - 1; i >= start; i--) {\n      let from = i;\n      let to = target + i - start;\n      if (to > last) {\n        to = last;\n      }\n      if (from in this) {\n        this[to] = this[from];\n      } else {\n        delete this[to];\n      }\n    }\n    return this;\n  };\n}",
    term: "Array.prototype.copyWithin",
    explain:
      "\n\n// Line 1: \n// This is a conditional statement that checks if the Array.prototype.copyWithin method is available.\n\n// Line 2: \n// This line initializes the Array.prototype.copyWithin method and passes in 3 arguments: the target index, the start index, and the end index.\n\n// Line 3: \n// This line checks if the start index is less than 0. If so, it sets the start index to the length of the array plus the start index.\n\n// Line 4: \n// This line checks if the end index is less than 0. If so, it sets the end index to the length of the array plus the end index.\n\n// Line 5: \n// This line sets the last index of the array to the length of the array minus 1.\n\n// Line 6: \n// This line creates a for loop that iterates backwards through the array starting at the end index minus 1 and ending at the start index.\n\n// Line 7: \n// This line sets the from index equal to the current iteration index of the loop.\n\n// Line 8: \n// This line sets the to index equal to the target index plus the iteration index minus the start index.\n\n// Line 9: \n// This line checks if the to index is greater than the last index of the array. If so, it sets the to index to the last index of the array.\n\n// Line 10: \n// This line checks if the from index exists in the array. If so, it sets the to index of the array equal to the from index of the array.\n\n// Line 11: \n// This line executes if the from index does not exist in the array. In this case, it deletes the to index of the array.\n\n// Line 12: \n// This line returns the modified array.",
    useCase:
      "\n\nArray.prototype.copyWithin is used in Javascript to copy a sequence of array elements within the same array. This method allows for elements to be copied from one part of the array to another part of the same array, without changing the length of the array. This method is useful for creating new arrays from existing ones in an efficient manner. It can also be used to move elements in an array around, making it easier to rearrange and manipulate data.",
  },
  {
    code: "\n\nif (!Array.prototype.entries) {\n  Array.prototype.entries = function() {\n    let index = 0;\n    let arr = this;\n    const length = arr.length;\n    return {\n      next() {\n        if (index < length) {\n          return {\n            value: [index, arr[index++]],\n            done: false\n          };\n        } else {\n          return {\n            done: true\n          };\n        }\n      }\n    };\n  };\n}",
    term: "Array.prototype.entries",
    explain:
      "\n\n// line 1: \n// This line checks if the entries method has not been added to the Array prototype.\n\n// line 2: \n// This line adds an entries method to the Array prototype.\n\n// line 3: \n// This line declares a local variable named index and sets it to 0.\n\n// line 4: \n// This line declares a local variable named arr and sets it to the array object that the entries method is being called on.\n\n// line 5: \n// This line declares a constant variable named length and sets it to the length of the array object.\n\n// line 6: \n// This line returns an object with a next method.\n\n// lines 7-14: \n// This code defines the next method. It checks if the index is less than the length of the array. If it is, it returns an object with a value property containing an array with the index and the element at that index, and a done property set to false. If the index is not less than the length, it returns an object with the done property set to true.",
    useCase:
      "\n\nArray.prototype.entries is used to return a new Array Iterator object that contains the key/value pairs for each index in the array. This can be useful when looping through an array and needing to access both the index and value of each element. This can also be used in conjunction with other methods like find() or filter() to quickly iterate through an array and perform specific operations on each element.",
  },
  {
    code: "\n\nif (!Array.prototype.every) {\n  Array.prototype.every = function(callbackfn, thisArg) {\n    let T, k;\n    if (this == null) {\n      throw new TypeError('this is null or not defined');\n    }\n    let O = Object(this);\n    let len = O.length >>> 0;\n    if (typeof callbackfn !== 'function') {\n      throw new TypeError();\n    }\n    if (arguments.length > 1) {\n      T = thisArg;\n    }\n    k = 0;\n    while (k < len) {\n      let kValue;\n      if (k in O) {\n        kValue = O[k];\n        let testResult = callbackfn.call(T, kValue, k, O);\n        if (!testResult) {\n          return false;\n        }\n      }\n      k++;\n    }\n    return true;\n  };\n}",
    term: "Array.prototype.every",
    explain:
      "\n\n// if (!Array.prototype.every) { \n// This checks to see if the every method is already added to the Array prototype. If not, it will add it.\n\n// Array.prototype.every = function(callbackfn, thisArg) { \n// This is the function definition for the every method. It takes in two parameters, a callback function, and a this argument.\n\n// let T, k; \n// This declares and initializes two variables, T and k.\n\n// if (this == null) { \n// This checks if the this argument is null.\n\n// throw new TypeError('this is null or not defined');\n// If the this argument is null, a TypeError is thrown.\n\n// let O = Object(this); \n// This creates an object out of the this argument.\n\n// let len = O.length >>> 0; \n// This sets the variable len to the length of the object created from the this argument.\n\n// if (typeof callbackfn !== 'function') { \n// This checks if the callback function is a function.\n\n// throw new TypeError(); \n// If the callback function is not a function, a TypeError is thrown.\n\n// if (arguments.length > 1) { \n// This checks if there is more than one argument.\n\n// T = thisArg; \n// If there is more than one argument, the variable T is set to the thisArg parameter.\n\n// k = 0; \n// This sets the variable k to 0.\n\n// while (k < len) { \n// This sets up a while loop that runs until k is less than the length of the object O.\n\n// let kValue; \n// This declares the variable kValue.\n\n// if (k in O) { \n// This checks if the value of k is in the object O.\n\n// kValue = O[k]; \n// If the value of k is in the object O, kValue is set to the value of O at the index of k.\n\n// let testResult = callbackfn.call(T, kValue, k, O); \n// This calls the callback function with the parameters kValue, k, and O.\n\n// if (!testResult) { \n// This checks the result of the callback function.\n\n// return false; \n// If the result of the callback function is false, false is returned.\n\n// k++; \n// This increments the value of k.\n\n// return true; \n// This returns true if the callback function returns true for every value in the object.",
    useCase:
      "\n\nArray.prototype.every is used in Javascript to test whether all elements in an array pass a certain test. It can be used to check if all elements in an array satisfy a certain condition, such as being less than a certain number or being of a certain type. It is a useful tool for testing the contents of an array and ensuring that they meet certain criteria.",
  },
  {
    code: "\n\nif (!Array.prototype.fill) {\n  Object.defineProperty(Array.prototype, 'fill', {\n    value: function(value) {\n      if (this == null) {\n        throw new TypeError('this is null or not defined');\n      }\n      let O = Object(this);\n      let len = O.length >>> 0;\n      let start = arguments[1];\n      let relativeStart = start >> 0;\n      let k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);\n      let end = arguments[2];\n      let relativeEnd = end === undefined ? len : end >> 0;\n      let final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);\n      while (k < final) {\n        O[k] = value;\n        k++;\n      }\n      return O;\n    }\n  });\n}",
    term: "Array.prototype.fill",
    explain:
      "\n\n// Line 1: This is an if statement, checking to see if the fill method has been defined for the Array prototype. If not, Object.defineProperty is used to define the method. \n// Line 2: This sets the value of the Array.prototype.fill method to a function which is defined below. \n// Line 3: This checks to make sure that the array is not null or undefined. If it is, a TypeError is thrown. \n// Line 4: This creates a new object from the array. \n// Line 5: This sets the length of the array to a number with no decimal places (>>> operator). \n// Line 6: This sets the start argument to the second argument of the function. \n// Line 7: This sets the relativeStart argument (start argument shifted by 0 bits) to the start argument. \n// Line 8: This sets the k argument to the larger of the two numbers (relativeStart and 0) or the smaller of the two numbers (relativeStart and the length of the array). \n// Line 9: This sets the end argument to the third argument of the function. \n// Line 10: This sets the relativeEnd argument (end argument shifted by 0 bits) to the end argument, or if it is undefined, the length of the array. \n// Line 11: This sets the final argument to the larger of the two numbers (relativeEnd and 0) or the smaller of the two numbers (relativeEnd and length of the array). \n// Line 12-14: This is a while loop, which loops through the array from start to end, setting each element to the value argument. \n// Line 15: This returns the array with the elements set to the value argument.",
    useCase:
      "\n\nArray.prototype.fill is used in Javascript to fill all the elements of an array with a static value, from a start index to an end index. This is useful for quickly populating an array with a set value, or for quickly resetting an array to a given value. It is also a useful tool for creating new arrays based on existing arrays with modified values.",
  },
  {
    code: "\n\nif (!Array.prototype.filter) {\n  Array.prototype.filter = function(callback, thisArg) {\n    let arr = [];\n    if (this == null) throw new TypeError('this is null or not defined');\n    let o = Object(this);\n    let len = o.length >>> 0;\n    if (typeof callback !== 'function') throw new TypeError(callback + ' is not a function');\n    for (let i = 0; i < len; i++) {\n      if (i in o) {\n        let val = o[i];\n        if (callback.call(thisArg, val, i, o)) {\n          arr.push(val);\n        }\n      }\n    }\n    return arr;\n  };\n}",
    term: "Array.prototype.filter",
    explain:
      "\n\n//1. This line checks if the filter function already exists in the Array prototype. \nif (!Array.prototype.filter) {\n\n//2. If it doesn't, then the following function is added to the Array prototype.\n  Array.prototype.filter = function(callback, thisArg) {\n\n//3. A new array is initialized to store the results.\n    let arr = [];\n\n//4. This line checks if the array being used is null or undefined.\n    if (this == null) throw new TypeError('this is null or not defined');\n\n//5. This line converts the array to an object for use.\n    let o = Object(this);\n\n//6. This line stores the length of the array as a 32-bit unsigned integer.\n    let len = o.length >>> 0;\n\n//7. This line checks to make sure the callback being used is actually a function.\n    if (typeof callback !== 'function') throw new TypeError(callback + ' is not a function');\n\n//8. This loop iterates over the array and runs the callback function on each item. \n    for (let i = 0; i < len; i++) {\n\n//9. This line checks if the item is part of the array.\n      if (i in o) {\n\n//10. This line stores the current item in the array.\n        let val = o[i];\n\n//11. This line calls the callback on the current item in the array and checks if it returns true. \n        if (callback.call(thisArg, val, i, o)) {\n\n//12. If it does, then the item is added to the new array. \n          arr.push(val);\n        }\n      }\n    }\n\n//13. This line returns the new array with the filtered items. \n    return arr;\n  };\n}",
    useCase:
      "\n\nArray.prototype.filter is used to create a new array with all elements that pass the test implemented by the provided function. It is a useful tool for filtering out elements from an array that don't meet certain criteria. It is a great way to reduce the amount of data that needs to be processed.",
  },
  {
    code: "\n\nif (!Array.prototype.find) {\n  Object.defineProperty(Array.prototype, 'find', {\n    value: function(predicate) {\n      if (this == null) {\n        throw new TypeError('\"this\" is null or not defined');\n      }\n      var o = Object(this);\n      var len = o.length >>> 0;\n      if (typeof predicate !== 'function') {\n        throw new TypeError('predicate must be a function');\n      }\n      var thisArg = arguments[1];\n      var k = 0;\n      while (k < len) {\n        var kValue = o[k];\n        if (predicate.call(thisArg, kValue, k, o)) {\n          return kValue;\n        }\n        k++;\n      }\n      return undefined;\n    }\n  });\n}",
    term: "Array.prototype.find",
    explain:
      '\n\n1. if (!Array.prototype.find) { // checks if the Array.prototype object has a property called find\n\n2. Object.defineProperty(Array.prototype, \'find\', { // adds a new property to the Array.prototype object\n\n3. value: function(predicate) { // assigns the value of the new property to a function\n\n4. if (this == null) { // checks if the value of "this" is null or not defined\n\n5. throw new TypeError(\'"this" is null or not defined\'); // throws an error if the value of "this" is null or not defined\n\n6. var o = Object(this); // assigns the value of "this" to a variable\n\n7. var len = o.length >>> 0; // assigns the length of the variable "o" to a variable\n\n8. if (typeof predicate !== \'function\') { // checks that the type of the variable "predicate" is a function\n\n9. throw new TypeError(\'predicate must be a function\'); // throws an error if the type of the variable "predicate" is not a function\n\n10. var thisArg = arguments[1]; // assigns the second argument to a variable\n\n11. var k = 0; // sets a counter variable to 0\n\n12. while (k < len) { // loops while the counter variable is less than the length of the variable "o"\n\n13. var kValue = o[k]; // assigns the value of the kth item in the variable "o" to a variable\n\n14. if (predicate.call(thisArg, kValue, k, o)) { // checks if the function "predicate" returns true when passed the variables "thisArg", "kValue", and "o"\n\n15. return kValue; // returns the value of the variable "kValue" if the function "predicate" returns true\n\n16. k++; // increments the counter variable\n\n17. } // ends the loop\n\n18. return undefined; // returns undefined if the function "predicate" does not return true\n\n19. } // ends the value of the new property\n\n20. }); // ends the Object.defineProperty method\n\n21. } // ends the if statement',
    useCase:
      "\n\nArray.prototype.find is used in Javascript to find the first element in an array that satisfies a given condition. It is a useful way to quickly search through an array and return a value that matches the condition. It is much simpler and faster than using a for loop to loop through the array and manually check each element.",
  },
  {
    code: "\n\nif (!Array.prototype.findIndex) {\n  Array.prototype.findIndex = function(predicate) {\n    if (this === null) {\n      throw new TypeError('Array.prototype.findIndex called on null or undefined');\n    }\n    if (typeof predicate !== 'function') {\n      throw new TypeError('predicate must be a function');\n    }\n    var list = Object(this);\n    var length = list.length >>> 0;\n    var thisArg = arguments[1];\n    var value;\n\n    for (var i = 0; i < length; i++) {\n      value = list[i];\n      if (predicate.call(thisArg, value, i, list)) {\n        return i;\n      }\n    }\n    return -1;\n  };\n}",
    term: "Array.prototype.findIndex",
    explain:
      "\n\n// Line 1: \n// Checks to see if the Array.prototype.findIndex is already defined. \n\n// Line 2: \n// If the Array.prototype.findIndex is not already defined, define it using a function that takes a predicate as an argument. \n\n// Line 3: \n// If the this value passed in to the function is null or undefined, throw a TypeError. \n\n// Line 4: \n// If the predicate argument is not a function, throw a TypeError.\n\n// Line 5: \n// Declare a variable called list set to the object passed in to the function.\n\n// Line 6: \n// Declare a variable called length set to the length of the list variable.\n\n// Line 7:\n// Declare a variable called thisArg set to the argument at index 1.\n\n// Line 8: \n// Declare a variable called value.\n\n// Lines 9-14: \n// Iterate through the list variable, setting the value variable to the current element in the list. \n// If the predicate function returns true when called on the value, the index of the current element is returned. \n\n// Line 15: \n// If the predicate function never returns true, return -1.",
    useCase:
      "\n\nArray.prototype.findIndex is used to find the index of the first element in an array that satisfies the provided testing function. It returns the index of the found element, or -1 if no element is found. This method can be used to quickly search an array for a specific element and return its index, or to find the index of the first element that meets certain criteria.",
  },
  {
    code: "\n\nif (!Array.prototype.flat) {\n  Array.prototype.flat = function() {\n    let res = [];\n    for (let i = 0; i < this.length; i++) {\n      if (Array.isArray(this[i])) {\n        res = res.concat(this[i].flat());\n      } else {\n        res.push(this[i]);\n      }\n    }\n    return res;\n  };\n}",
    term: "Array.prototype.flat",
    explain:
      "\n\n//Line 1: \n//This line checks if the flat method is not present in the Array prototype.\n\n//Line 2: \n//This line adds a flat method to the Array prototype.\n\n//Line 3: \n//This line creates an empty array named 'res' to store the flattened array.\n\n//Line 4: \n//This line is a for loop that iterates over the array.\n\n//Line 5: \n//This line checks if the current element is an array and calls the flat method on it.\n\n//Line 6: \n//This line concats the flattened array with the res array.\n\n//Line 7: \n//This line pushes the element to the res array if it is not an array.\n\n//Line 8: \n//This line returns the flattened array.",
    useCase:
      "\n\nArray.prototype.flat is used to flatten an array of sub-arrays into a single, flat array. It is a useful method for reducing the number of nested levels in an array, allowing easier access to elements in the array. It is also useful for manipulating data, such as when combining multiple arrays into a single array.",
  },
  {
    code: "\n\nif (!Array.prototype.flatMap) {\n    Array.prototype.flatMap = function(callback) {\n        return this.reduce((acc, x) => {\n            return acc.concat(callback(x));\n        }, []);\n    };\n}",
    term: "Array.prototype.flatMap",
    explain:
      "\n\n// Line 1: This line checks if the Array.prototype does not have a flatmap method.\n// Line 2: This line is the beginning of the flatmap function definition. The function takes in a callback function as a parameter.\n// Line 3: This line uses the reduce() method to reduce the array to a single value. The callback function takes in two parameters, the accumulator and the current value, and returns a concatenated array.\n// Line 4: This line is the return statement, which returns the concatenated array.\n// Line 5: This line is the end of the function definition.",
    useCase:
      "\n\nArray.prototype.flatMap is used in Javascript to map each element using a mapping function, then flatten the resulting arrays into a single array. This is useful when you need to apply a mapping function to each element of an array, and then flatten all the resulting arrays into a single array. For example, it can be used to take an array of strings and map each string to an array of characters, and then flatten the resulting arrays of characters into a single array of characters.",
  },
  {
    code: "\n\nif (!Array.prototype.forEach) {\n  Array.prototype.forEach = function(callback/*, thisArg*/) {\n    let array = this;\n    let thisArg = arguments[1];\n    for (let i = 0; i < array.length; i++) {\n      callback.call(thisArg, array[i], i, array);\n    }\n  };\n}",
    term: "Array.prototype.forEach",
    explain:
      "\n\n// Line 1:\n// This line checks to see if the forEach method has already been added to the Array prototype. If it has not been added, the code inside the if statement will be run.\n\n// Line 2:\n// This line adds a forEach method to the Array prototype. It takes a callback function and a thisArg argument as parameters.\n\n// Line 3:\n// This line stores the array that the forEach method is called on in a variable called array.\n\n// Line 4:\n// This line stores the second argument of the forEach method in a variable called thisArg.\n\n// Line 5:\n// This line is a for loop that loops through each element in the array.\n\n// Line 6:\n// This line calls the callback function that was passed into the forEach method. It passes in the current element in the array, the index of the element, and the array itself as arguments. It also sets the context of the callback function to the thisArg argument.",
    useCase:
      "\n\nArray.prototype.forEach is used in Javascript to loop through each element in an array and execute a function for each element. It is a useful tool for iterating over each element of an array and performing some action on it, such as manipulating the element or adding it to a new array. It is more efficient than manually looping through each element of an array.",
  },
  {
    code: "\n\nif (!Array.prototype.includes) {\n  Array.prototype.includes = function(element, startIndex) {\n    if (startIndex === undefined) {\n      startIndex = 0\n    }\n    for (var i = startIndex; i < this.length; i++) {\n      if (this[i] === element) {\n        return true\n      }\n    }\n    return false\n  }\n}",
    term: "Array.prototype.includes",
    explain:
      "\n\n// Line 1: \n// This line checks whether the 'includes' method is already defined in the Array prototype. If not, then the following code is executed.\n\n// Line 2: \n// This line defines the 'includes' method in the Array prototype.\n\n// Line 3: \n// This line checks whether the startIndex argument is undefined. If so, it assigns it the value 0.\n\n// Line 4: \n// This line initializes a loop with the variable i as the iterator, starting at the value of startIndex and ending at the last element of the array.\n\n// Line 5: \n// This line checks if the element at the current index is equal to the element passed as an argument. If so, it returns true.\n\n// Line 6: \n// This line is executed when the loop ends, and it returns false if no element in the array was equal to the argument.",
    useCase:
      "\n\nArray.prototype.includes is used in Javascript to determine whether an array includes a certain element, returning true or false as appropriate. It is an efficient way to check if a specific element is present in an array, without needing to loop through the array and manually check each element.",
  },
  {
    code: "\n\nif (!Array.prototype.indexOf) {\n  Array.prototype.indexOf = function(searchElement, fromIndex) {\n    if (this == null) {\n      throw new TypeError('\"this\" is null or not defined');\n    }\n    var o = Object(this);\n    var len = o.length >>> 0;\n    if (len === 0) {\n      return -1;\n    }\n    var n = fromIndex | 0;\n    if (n >= len) {\n      return -1;\n    }\n    var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\n    while (k < len) {\n      if (k in o && o[k] === searchElement) {\n        return k;\n      }\n      k++;\n    }\n    return -1;\n  };\n}",
    term: "Array.prototype.indexOf",
    explain:
      "\n\n// if (!Array.prototype.indexOf) {\n// This line checks to see if the 'indexOf' method already exists on the Array object.\n\n// Array.prototype.indexOf = function(searchElement, fromIndex) {\n// This line adds the 'indexOf' method to the Array object if it doesn't already exist.\n\n// if (this == null) {\n// This line checks to see if the 'this' keyword is null or undefined.\n\n// var o = Object(this);\n// This line creates an object from the current array.\n\n// var len = o.length >>> 0;\n// This line gets the length of the object and converts it to an unsigned 32-bit integer.\n\n// if (len === 0) {\n// This line checks to see if the array is empty.\n\n// return -1;\n// This line returns -1 if the array is empty.\n\n// var n = fromIndex | 0;\n// This line creates an integer from the 'fromIndex' parameter.\n\n// if (n >= len) {\n// This line checks to see if the 'fromIndex' is greater than or equal to the array length.\n\n// return -1;\n// This line returns -1 if the 'fromIndex' is greater than or equal to the array length.\n\n// var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\n// This line creates a variable 'k' that is equal to the maximum value of either the 'fromIndex' or the array length - the absolute value of the 'fromIndex'.\n\n// while (k < len) {\n// This line creates a loop that runs until 'k' is equal to the array length.\n\n// if (k in o && o[k] === searchElement) {\n// This line checks to see if the current element in the array is equal to the 'searchElement' parameter.\n\n// return k;\n// This line returns the index of the element if it is found.\n\n// k++;\n// This line increments 'k' by 1 at the end of each loop.\n\n// return -1;\n// This line returns -1 if the element is not found.",
    useCase:
      "\n\nArray.prototype.indexOf is used in Javascript to find the index of an element in an array. It takes the element as an argument and returns the index of the first occurrence of the element in the array, or -1 if the element is not present. This method is useful for quickly finding the position of an element in an array and for checking if an element exists in an array.",
  },
  {
    code: "\n\nif (!Array.prototype.keys) {\n  Array.prototype.keys = function() {\n    let index = 0;\n    let array = this;\n    return {\n      next: () => {\n        if (index < array.length) {\n          return {\n            value: index++, \n            done: false\n          };\n        }\n        return {\n          done: true\n        };\n      }\n    };\n  };\n}",
    term: "Array.prototype.keys",
    explain:
      "\n\n// Line 1: This line checks to see if the Array.prototype object has a property of 'keys' and if not, it proceeds to the next line of code. \n// Line 2: This line adds a 'keys' property to the Array.prototype object that is a function. \n// Line 3: This line declares a variable called 'index' and sets its value to 0. \n// Line 4: This line declares a variable called 'array' and sets its value to the array calling the function. \n// Line 5: This line returns an object with a 'next' property, which is a function. \n// Line 6: This line checks to see if the 'index' is less than the length of the array and if it is, it returns an object with a 'value' property set to the 'index' and a 'done' property set to false. \n// Line 7: This line is executed if the 'index' is not less than the length of the array and it returns an object with a 'done' property set to true. \n// Line 8: This line closes the 'next' function. \n// Line 9: This line closes the 'keys' function.",
    useCase:
      "\n\nArray.prototype.keys is used in Javascript to return a new Array Iterator object that contains the keys for each index in the array. This allows developers to iterate over the array and access the keys of each index, which can then be used to access the corresponding value. This method is useful for accessing and manipulating the data stored in an array.",
  },
  {
    code: "\n\nif (!Array.prototype.lastIndexOf) {\n    Array.prototype.lastIndexOf = function (searchElement, fromIndex) {\n        let k;\n        if (fromIndex === undefined) {\n            k = this.length - 1;\n        } else {\n            k = fromIndex >= 0 ? fromIndex : this.length + fromIndex;\n        }\n        for (let i = k; i >= 0; i--) {\n            if (this[i] === searchElement) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}",
    term: "Array.prototype.lastIndexOf",
    explain:
      "\n\n// This code is checking to see if the lastIndexOf function is already present on the Array.prototype object.\n// If it is not, it is adding the function to the Array.prototype object.\n\n// Line 1: \n// This is a check to see if the lastIndexOf function is already present on the Array.prototype object. \n// If it is, the code does not need to be run.\n\n// Line 2: \n// This line is defining the lastIndexOf function and adding it to the Array.prototype object if it is not already present.\n\n// Line 3:\n// This line is setting up the k variable. If the fromIndex parameter is not specified, it sets k to the length of the array minus 1. \n// Otherwise, it sets k to the value of fromIndex if it is greater than or equal to 0, or the length of the array plus the value of fromIndex if it is less than 0.\n\n// Line 4:\n// This line is starting a for loop that runs from k to 0.\n\n// Line 5:\n// This line is checking to see if the element at the current index of the array is equal to the searchElement parameter. \n// If it is, it returns the index of the element.\n\n// Line 6: \n// This line is run if the element at the current index of the array is not equal to the searchElement parameter. \n// It returns -1, indicating that the searchElement was not found in the array.",
    useCase:
      "\n\nArray.prototype.lastIndexOf is used in JavaScript to find the last index of an element in an array. It is useful for finding the last occurrence of an element in an array and can be used to determine whether an element exists in the array or not. It is also useful for identifying the index of the last item in an array that meets a certain criteria.",
  },
  {
    code: "\n\n//polyfill of Array.prototype.map function\nif(!Array.prototype.map){\n    Array.prototype.map = function(callback, thisArg){\n        let resultArray = [];\n        for(let i = 0; i < this.length; i++){\n            resultArray.push(callback.call(thisArg, this[i], i, this));\n        }\n        return resultArray;\n    }\n}",
    term: "Array.prototype.map",
    explain:
      "\n\n//This code creates a polyfill of the Array.prototype.map function. This is a function that allows the user to traverse through each element of an array and apply a callback function on each element.\n\n//Line 1:\n//This line checks to see if the Array.prototype.map function already exists.\n\n//Line 2:\n//If the function does not already exist, this line creates the Array.prototype.map function.\n\n//Line 3:\n//This line creates an empty resultArray that will contain the result of the map function.\n\n//Line 4:\n//This line creates a for loop that iterates through each element of the array and applies the callback function. \n\n//Line 5:\n//This line pushes the result of the callback function to the resultArray.\n\n//Line 6:\n//This line returns the resultArray.",
    useCase:
      "\n\nArray.prototype.map is used in Javascript to create a new array of values by mapping each element in an existing array through a function. This can be used to transform each element in the existing array into a different value or format. It is useful for performing operations on all elements in an array in a concise manner.",
  },
  {
    code: "\n\nif (!Array.prototype.reduce) {\n  Array.prototype.reduce = function(callback /*, initialValue*/) {\n    if (this === null) {\n      throw new TypeError('Array.prototype.reduce ' +\n        'called on null or undefined');\n    }\n    if (typeof callback !== 'function') {\n      throw new TypeError(callback +\n        ' is not a function');\n    }\n\n    // 1. Let O be ? ToObject(this value).\n    var o = Object(this);\n\n    // 2. Let len be ? ToLength(? Get(O, \"length\")).\n    var len = o.length >>> 0;\n\n    // Steps 3, 4, 5, 6, 7\n    var k = 0;\n    var value;\n\n    if (arguments.length >= 2) {\n      value = arguments[1];\n    } else {\n      while (k < len && !(k in o)) {\n        k++;\n      }\n\n      // 3. If len is 0 and initialValue is not present,\n      //    throw a TypeError exception.\n      if (k >= len) {\n        throw new TypeError('Reduce of empty array ' +\n          'with no initial value');\n      }\n      value = o[k++];\n    }\n\n    // 8. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      // b. Let kPresent be ? HasProperty(O, Pk).\n      // c. If kPresent is true, then\n      //    i. Let kValue be ? Get(O, Pk).\n      //    ii. Let accumulator be ? Call(\n      //          callbackfn, undefined,\n      //          « accumulator, kValue, k, O »).\n      if (k in o) {\n        value = callback(value, o[k], k, o);\n      }\n\n      // d. Increase k by 1.\n      k++;\n    }\n\n    // 9. Return accumulator.\n    return value;\n  };\n}",
    term: "Array.prototype.reduce",
    explain:
      "\n\n// Line 1: This line is a check to make sure the reduce function is not already present in the Array.prototype. If the reduce function is not present, the code will continue.\n\n// Line 2: This line is the beginning of the reduce function that will be added to the Array.prototype. It takes in a callback as its argument.\n\n// Line 3-6: This block of code is a check to make sure that the object passed in is an Array. If it is not an Array, it will throw an error.\n\n// Line 7-11: This block of code is a check to make sure the initial value is passed in. If an initial value is not passed in, the first value of the array will be used.\n\n// Line 12-21: This block of code is a loop that will iterate over the array and call the callback function with the accumulator, current value, index, and array as arguments.\n\n// Line 22-25: This block of code returns the accumulator after the loop is finished.",
    useCase:
      "\n\nArray.prototype.reduce is used in JavaScript to iterate through an array and reduce it down to a single value. It can be used to perform a variety of tasks such as summing up values, calculating the average, joining elements together in a string, and more. It is a powerful method that allows developers to quickly and efficiently work with data in an array.",
  },
  {
    code: "\n\nif (!Array.prototype.reduceRight) {\n  Array.prototype.reduceRight = function(callback, initialValue) {\n    let arr = Object(this); \n    let len = arr.length >>> 0; \n    let k = len - 1;\n    let accumulator;\n\n    if (arguments.length >= 2) {\n      accumulator = initialValue;\n    } else {\n      while (k >= 0 && !(k in arr)) {\n        k--;\n      }\n      if (k < 0)\n        throw new TypeError('Reduce of empty array with no initial value');\n      accumulator = arr[k--];\n    }\n    \n    for (; k >= 0; k--) {\n      if (k in arr) {\n       accumulator = callback(accumulator, arr[k], k, arr);\n      }\n    }\n    return accumulator; \n  }\n}",
    term: "Array.prototype.reduceRight",
    explain:
      '\n\n// Line 1: \n// This line checks if the Array.prototype.reduceRight function already exists. If it does not, it will create the function.\n\n// Line 2: \n// This line creates the Array.prototype.reduceRight function, with two parameters, callback and initialValue.\n\n// Line 3: \n// This line creates a variable called "arr" which is an object version of the array.\n\n// Line 4: \n// This line creates a variable called "len" which stores the length of the array.\n\n// Line 5: \n// This line creates a variable called "k" which is equal to the length of the array minus 1.\n\n// Line 6: \n// This line creates a variable called "accumulator" which will store the result of the reduceRight operation.\n\n// Line 7: \n// This line checks if there are two arguments (callback and initialValue). If there are two arguments, the accumulator variable is set to the initialValue argument.\n\n// Line 8: \n// This line checks if the k variable is greater than or equal to 0 and if the kth element of the array exists. If it does not, the k variable is decremented by 1.\n\n// Line 9: \n// This line checks if the k variable is less than 0. If it is, it throws an error because there is no initial value. \n\n// Line 10: \n// This line sets the accumulator variable to the kth element of the array and decrements k by 1.\n\n// Line 11: \n// This line runs a for loop from k to 0.\n\n// Line 12: \n// This line checks if the kth element of the array exists. If it does, the accumulator variable is set to the result of the callback function.\n\n// Line 13: \n// This line returns the accumulator variable which holds the result of the reduceRight operation.',
    useCase:
      "\n\nArray.prototype.reduceRight is used to iterate through an array from right to left, applying a callback function to each element. This can be useful for performing a certain operation on an array, such as adding up all the numbers in an array or finding the maximum value. It also allows developers to apply their own custom logic to each element, enabling them to create more complex applications.",
  },
  {
    code: "\n\nif (!Array.prototype.some) {\n    Array.prototype.some = function(callback, thisArg) {\n        let T, k;\n        if (this == null) {\n            throw new TypeError('this is null or not defined');\n        }\n        let O = Object(this);\n        let len = O.length >>> 0;\n        if (typeof callback !== 'function') {\n            throw new TypeError(callback + ' is not a function');\n        }\n        if (arguments.length > 1) {\n            T = thisArg;\n        }\n        k = 0;\n        while (k < len) {\n            let kValue;\n            if (k in O) {\n                kValue = O[k];\n                let testResult = callback.call(T, kValue, k, O);\n                if (testResult) {\n                    return true;\n                }\n            }\n            k++;\n        }\n        return false;\n    };\n}",
    term: "Array.prototype.some",
    explain:
      "\n\n//Line 1: This line checks if the .some() method exists on the Array prototype.\n//Line 2: If it does not exist, the function creates a .some() method on the Array prototype.\n//Line 3: This line creates a variable T and k to store temporary values.\n//Line 4: This line checks if the array is null or undefined.\n//Line 5: This line creates an Object from the array.\n//Line 6: This line creates a variable len to store the length of the array.\n//Line 7: This line checks if the callback argument is a function.\n//Line 8: This line checks if the thisArg argument is present.\n//Line 9: This line sets the value of k to 0.\n//Line 10: This line creates a while loop that runs until k is equal to the length of the array.\n//Line 11: This line creates a variable kValue to store the value of the array at the given index.\n//Line 12: This line checks if the index exists in the array.\n//Line 13: This line sets kValue to the value of the array at the given index.\n//Line 14: This line calls the callback function with the current value, index, and array as arguments.\n//Line 15: This line checks if the callback returns true, and if so, returns true.\n//Line 16: This line increments k.\n//Line 17: This line returns false if the callback function never returns true.",
    useCase:
      "\n\nArray.prototype.some is used in JavaScript to check if at least one element in the array passes a certain condition. It is useful for quickly testing if any elements in an array meet a certain criteria. It can be used to check if any elements in an array match a certain value, or if any elements in an array satisfy a certain condition.",
  },
  {
    code: "\n\nif (!Array.prototype.sort) {\n  Array.prototype.sort = function(compareFn) {\n\n    const length = this.length;\n\n    for (let i = 0; i < length; i++) {\n      for (let j = 0; j < length - 1; j++) {\n        if (compareFn ? compareFn(this[j], this[j + 1]) > 0 : this[j] > this[j + 1]) {\n          let temp = this[j];\n          this[j] = this[j + 1];\n          this[j + 1] = temp;\n        }\n      }\n    }\n    return this;\n  }\n}",
    term: "Array.prototype.sort",
    explain:
      "\n\n// Line 1: This line is a conditional statement that checks to see if the Array.prototype has a sort method.\n// Line 2: If the Array.prototype does not have a sort method, this line defines a sort method for the Array.prototype.\n// Line 3: This line declares a variable length that is set to the length of the array.\n// Line 4: This line is a for loop that iterates through the array starting at the first element.\n// Line 5: This line is a nested for loop that iterates through the array starting at the second element.\n// Line 6: This line is a conditional statement that checks if the compareFn parameter is passed in and compares the two elements. If the compareFn parameter is not passed in, then it compares the two elements with the greater than operator.\n// Line 7: This line declares a temporary variable and sets it to the first element.\n// Line 8: This line sets the first element to the second element.\n// Line 9: This line sets the second element to the temporary variable which is the first element.\n// Line 10: This line closes the nested for loop.\n// Line 11: This line closes the for loop.\n// Line 12: This line returns the array after it has been sorted.\n// Line 13: This line closes the conditional statement.",
    useCase:
      "\n\nArray.prototype.sort is used in Javascript to sort an array in ascending or descending order. This method is used to sort elements of an array alphabetically, numerically, or by any other custom sorting criteria. This method is useful for sorting data in a more efficient way than manually looping through the array and comparing each element.",
  },
  {
    code: "\n\nif (!Array.prototype.values) {\n    Array.prototype.values = function () {\n        let i = 0;\n        let current = this[i];\n        const iterator = {\n            next: function () {\n                const value = {\n                    done: i >= this.length,\n                    value: current\n                }\n                i++;\n                current = this[i];\n                return value;\n            }\n        };\n        return iterator;\n    };\n}",
    term: "Array.prototype.values",
    explain:
      "\n\n// Line 1: \n// This line checks to see if there is already an existing 'values' prototype method for the Array object. \n\n// Line 2: \n// If the 'values' prototype method does not exist, this line adds it as a function on the Array prototype.\n\n// Line 3: \n// This line initializes a counter variable i and sets it to 0.\n\n// Line 4: \n// This line initializes a variable called current and sets it to the first element in the array.\n\n// Line 5: \n// This line creates an iterator object and assigns it to the variable iterator.\n\n// Line 6: \n// This line creates a function called next which returns an object with two properties, done and value. The done property is set to true if the counter is greater than or equal to the length of the array, and the value property is set to the current element in the array.\n\n// Line 7: \n// This line increments the counter variable.\n\n// Line 8: \n// This line sets the current variable to the next element in the array.\n\n// Line 9: \n// This line returns the iterator object.\n\n// Line 10: \n// This line returns the values function.",
    useCase:
      "\n\nArray.prototype.values is used in Javascript to return a new Array Iterator object that contains the values for each index in the array. It provides a way to access all the elements of an array without having to loop through them individually. This is helpful when dealing with large arrays, as it can speed up the process of iterating over them.",
  },
  {
    code: "\n\nif (!ArrayBuffer.prototype.slice) {\n    ArrayBuffer.prototype.slice = function(start, end) {\n        let that = new Uint8Array(this);\n        if (end === undefined) end = that.length;\n        let result = new ArrayBuffer(end - start);\n        let resultArray = new Uint8Array(result);\n        for (let i = 0; i < resultArray.length; i++) {\n            resultArray[i] = that[i + start];\n        }\n        return result;\n    };\n}",
    term: "ArrayBuffer",
    explain:
      "\n\n// Line 1: \n// This line checks if the ArrayBuffer.prototype object does not have a slice method. If it does not, it will proceed to the next line. Otherwise, it will skip the rest of the code. \n\n// Line 2: \n// This line adds a slice method to the ArrayBuffer.prototype object. This method takes two arguments, start and end.\n\n// Line 3: \n// This line creates a new Uint8Array from the ArrayBuffer. If the end argument is not given, it will set end equal to the length of the Uint8Array.\n\n// Line 4:\n// This line creates a new ArrayBuffer with the length of end minus start.\n\n// Line 5:\n// This line creates a new Uint8Array from the new ArrayBuffer. \n\n// Line 6: \n// This line iterates through the resultArray and sets each element to the corresponding element in the that array, which is the original Uint8Array.\n\n// Line 7: \n// This line returns the result ArrayBuffer.",
    useCase:
      "\n\nArrayBuffer is used in JavaScript to store binary data, such as the contents of an image file or a video. It can be used to create a typed array, which is an array of a specific type of data, such as integers or floating-point numbers. ArrayBuffers are also used to create ArrayBufferViews, which are views into an ArrayBuffer that can represent the data as an array of a specific type. ArrayBuffers are a low-level primitive for storing binary data, and are used by many of the higher-level APIs for handling binary data, such as the File and Blob APIs.",
  },
  {
    code: "\n\nif (!ArrayBuffer.isView) {\n  ArrayBuffer.isView = function(arg) {\n    return arg !== null && typeof arg === 'object' && arg.buffer instanceof ArrayBuffer;\n  };\n}",
    term: "ArrayBuffer.isView",
    explain:
      "\n\nLine 1: if (!ArrayBuffer.isView) {\n\nThis line checks whether the isView method already exists on the ArrayBuffer object.\n\nLine 2: ArrayBuffer.isView = function(arg) {\n\nThis line creates a new method on the ArrayBuffer object called isView which takes in a single argument. \n\nLine 3: return arg !== null && typeof arg === 'object' && arg.buffer instanceof ArrayBuffer;\n\nThis line returns a boolean value based on the argument passed to the isView function. It returns true if the argument is not null, is an object, and has a buffer property which is an instance of an ArrayBuffer.",
    useCase:
      "\n\nArrayBuffer.isView is used in Javascript to check if a given value is a view on an ArrayBuffer. This is useful when working with binary data, as it allows us to determine whether a given value is a view of the underlying array buffer. This can be used to ensure that the data is being accessed and manipulated correctly, as well as to detect incorrect uses of views.",
  },
  {
    code: "\n\n(function() {\n  var lastTime = 0;\n  var vendors = ['ms', 'moz', 'webkit', 'o'];\n  for(var x = 0; x < vendors.length && !window.AudioContext; ++x) {\n    window.AudioContext = window[vendors[x]+'AudioContext'];\n  }\n\n  if (!window.AudioContext) {\n    window.AudioContext = function() {\n      this.sampleRate = 44100;\n      this.currentTime = 0;\n      this.listener = {\n        setPosition: function () {},\n        setOrientation: function () {},\n        setVelocity: function () {}\n      };\n      this.createGainNode = function () {\n          return new GainNode();\n      };\n      this.createScriptProcessor = function () {\n          return new ScriptProcessor();\n      };\n      this.createBufferSource = function () {\n          return new BufferSourceNode();\n      };\n      this.createDelayNode = function () {\n          return new DelayNode();\n      };\n      this.createPanner = function () {\n          return new Panner();\n      };\n      this.createAnalyser = function () {\n          return new Analyser();\n      };\n      this.createWaveShaper = function () {\n          return new WaveShaper();\n      };\n      this.createBiquadFilter = function () {\n          return new BiquadFilter();\n      };\n      this.createIIRFilter = function () {\n          return new IIRFilter();\n      };\n      this.createConvolver = function () {\n          return new Convolver();\n      };\n      this.createChannelSplitter = function () {\n          return new ChannelSplitter();\n      };\n      this.createChannelMerger = function () {\n          return new ChannelMerger();\n      };\n      this.createOscillator = function () {\n          return new OscillatorNode();\n      };\n      this.createPeriodicWave = function () {\n          return new PeriodicWave();\n      };\n      this.createMediaElementSource = function () {\n          return new MediaElementSource();\n      };\n      this.createMediaStreamSource = function () {\n          return new MediaStreamSource();\n      };\n      this.createMediaStreamDestination = function () {\n          return new MediaStreamDestination();\n      };\n      this.close = function () {};\n      this.suspend = function () {};\n      this.resume = function () {};\n      this.createBuffer = function () {\n          return new AudioBuffer();\n      };\n      this.decodeAudioData = function () {};\n      this.getOutputTimestamp = function () {\n          return {\n              contextTime: 0,\n              performanceTime: 0\n           }; \n      };\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n    }\n  }\n\n  function GainNode() {\n      this.gain = {\n          value: 1,\n      };\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function ScriptProcessor() {\n      this.onaudioprocess = undefined;\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function BufferSourceNode() {\n      this.buffer = null;\n      this.loop = false;\n      this.loopStart = 0;\n      this.loopEnd = 0;\n      this.onended = null;\n      this.start = function () {};\n      this.stop = function () {};\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function DelayNode() {\n      this.delayTime = {\n          value: 0\n      };\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function Panner() {\n      this.panningModel = 'equalpower';\n      this.setPosition = function () {};\n      this.setOrientation = function () {};\n      this.setVelocity = function () {};\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function Analyser() {\n      this.fftSize = 2048;\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function WaveShaper() {\n      this.oversample = '4x';\n      this.curve = null;\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function BiquadFilter() {\n      this.type = 'lowpass';\n      this.frequency = {\n          value: 440\n      };\n      this.Q = {\n          value: 1\n      };\n      this.detune = {\n          value: 0\n      };\n      this.gain = {\n          value: 0\n      };\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function IIRFilter() {\n      this.type = 'lowpass';\n      this.frequency = {\n          value: 440\n      };\n      this.Q = {\n          value: 1\n      };\n      this.detune = {\n          value: 0\n      };\n      this.gain = {\n          value: 0\n      };\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function Convolver() {\n      this.normalize = true;\n      this.buffer = null;\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function ChannelSplitter() {\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function ChannelMerger() {\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function OscillatorNode() {\n      this.type = 'sine';\n      this.frequency = {\n          value: 440\n      };\n      this.detune = {\n          value: 0\n      };\n      this.start = function () {};\n      this.stop = function () {};\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function PeriodicWave() {\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function MediaElementSource() {\n      this.mediaElement = null;\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function MediaStreamSource() {\n      this.mediaStream = null;\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function MediaStreamDestination() {\n      this.mediaStream = null;\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener =",
    term: "AudioContext",
    explain:
      " function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function AudioBuffer() {\n      this.length = 0;\n      this.sampleRate = 0;\n      this.duration = 0;\n      this.numberOfChannels = 0;\n      this.getChannelData = function () {};\n      this.copyFromChannel = function () {};\n      this.copyToChannel = function () {};\n  }\n\n})();\n\n// Line 1: (function() {\n// This line creates a self-executing anonymous function to contain all of the code in the script. This creates a new scope, where variables can be declared without affecting the global scope. \n\n// Line 2: var lastTime = 0;\n// This line declares a variable called 'lastTime' and initializes it to 0.\n\n// Line 3: var vendors = ['ms', 'moz', 'webkit', 'o'];\n// This line declares a variable called 'vendors' and initializes it to an array of vendor prefixed strings.\n\n// Line 4: for(var x = 0; x < vendors.length && !window.AudioContext; ++x) {\n// This line creates a for loop that runs while 'x' is less than the length of the 'vendors' array and 'window.AudioContext' is not true.\n\n// Line 5: window.AudioContext = window[vendors[x]+'AudioContext'];\n// This line sets 'window.AudioContext' to the 'window' object property that corresponds to the current 'vendors' array item.\n\n// Line 6: if (!window.AudioContext) {\n// This line checks to see if 'window.AudioContext' is not true.\n\n// Line 7-54: This block of code creates a new 'AudioContext' constructor.\n\n// Line 55-82: This block of code creates the 'GainNode' constructor.\n\n// Line 83-110: This block of code creates the 'ScriptProcessor' constructor.\n\n// Line 111-138: This block of code creates the 'BufferSourceNode' constructor.\n\n// Line 139-166: This block of code creates the 'DelayNode' constructor.\n\n// Line 167-194: This block of code creates the 'Panner' constructor.\n\n// Line 195-222: This block of code creates the 'Analyser' constructor.\n\n// Line 223-250: This block of code creates the 'WaveShaper' constructor.\n\n// Line 251-278: This block of code creates the 'BiquadFilter' constructor.\n\n// Line 279-306: This block of code creates the 'IIRFilter' constructor.\n\n// Line 307-334: This block of code creates the 'Convolver' constructor.\n\n// Line 335-362: This block of code creates the 'ChannelSplitter' constructor.\n\n// Line 363-390: This block of code creates the 'ChannelMerger' constructor.\n\n// Line 391-418: This block of code creates the 'OscillatorNode' constructor.\n\n// Line 419-446: This block of code creates the 'PeriodicWave' constructor.\n\n// Line 447-474: This block of code creates the 'MediaElementSource' constructor.\n\n// Line 475-502: This block of code creates the 'MediaStreamSource' constructor.\n\n// Line 503-530: This block of code creates the 'MediaStreamDestination' constructor.\n\n// Line 531-558: This block of code creates the 'AudioBuffer' constructor.\n\n// Line 559: })();\n// This line closes the self-executing anonymous function.",
    useCase:
      "\n\nAudioContext is used in JavaScript to provide an interface for working with audio in web applications. It allows developers to create, manipulate, and play audio in the browser, allowing for more interactive audio experiences. AudioContext provides an API for creating audio sources, routing audio signals, and applying audio effects. It is also used for playback and recording of audio, as well as for synthesis of new audio.",
  },
  {
    code: "\n\nif (!window.Blob) {\n  var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n\n  window.Blob = function (parts, properties) {\n    parts = parts || [];\n    properties = properties || {};\n\n    try {\n      return new Blob(parts, properties);\n    } catch (e) {\n      var bb = new BlobBuilder();\n      parts.forEach(function(p) {\n        bb.append(p);\n      });\n\n      return bb.getBlob(properties.type);\n    }\n  };\n}",
    term: "Blob",
    explain:
      "\n\n// line 1: \n// If the window object does not have a Blob property, the code in this block will execute\n\n// line 2:\n// This line creates a variable called 'BlobBuilder' which stores the window.BlobBuilder, window.WebKitBlobBuilder, window.MozBlobBuilder, or window.MSBlobBuilder property.\n\n// line 3:\n// This line creates a new property in the window object called 'Blob', which is a function that takes two parameters, parts and properties.\n\n// line 4:\n// This line sets the parts parameter to an empty array if it is not defined.\n\n// line 5:\n// This line sets the properties parameter to an empty object if it is not defined.\n\n// line 6:\n// This line attempts to create a new Blob object using the parts and properties parameters.\n\n// line 7:\n// If the attempt to create a new Blob object fails, this catch statement will execute.\n\n// line 8:\n// This line creates a new BlobBuilder object and assigns it to the bb variable.\n\n// line 9:\n// This line calls the forEach method on the parts parameter, which will loop through each item in the array and execute a function.\n\n// line 10:\n// This line calls the append method on the bb object, which adds each item in the array to the BlobBuilder object.\n\n// line 11:\n// This line returns the Blob object created from the BlobBuilder object, using the type property of the properties parameter as the type.",
    useCase:
      "\n\nBlob is used in JavaScript to create immutable objects that can store large amounts of data. Blobs can be used to store large data such as images, audio, video, and other binary data. Blobs can also be used to store data in a structured format such as JSON or XML. Blob objects are also used to create objects that can be used in web applications such as images, audio, video, and other forms of data. Blobs are also used in browser-based applications to store large amounts of data that need to be sent to the server.",
  },
  {
    code: "\n\n// Polyfill for CSS.supports in Javascript\n\nconst cssSupports = (...args) => {\n\tconst len = args.length\n\tlet el = document.createElement('div')\n\tlet style = el.style\n\n\tlet result = true;\n\n\tif(len === 2) {\n\t\tif(typeof args[0] === 'string' && typeof args[1] === 'string') {\n\t\t\tstyle.setProperty(args[0], args[1])\n\t\t\tresult = window.getComputedStyle(el).getPropertyValue(args[0]);\n\t\t}\n\t}\n\telse if (len === 1) {\n\t\tif (typeof args[0] === 'string') {\n\t\t\treturn style[args[0]] !== undefined\n\t\t}\n\t\telse {\n\t\t\tlet supported = true;\n\n\t\t\tObject.keys(args[0]).forEach(prop => {\n\t\t\t\tstyle.setProperty(prop, args[0][prop])\n\t\t\t\tsupported = window.getComputedStyle(el).getPropertyValue(prop);\n\t\t\t})\n\t\t\t\n\t\t\tresult = supported\n\t\t}\n\t}\n\n\treturn result;\n}",
    term: "CSS.supports",
    explain:
      "\n\n// 1. const cssSupports = (...args) => {\n//    This line declares a constant variable called cssSupports and assigns it to a function that takes multiple arguments.\n\n// 2. let el = document.createElement('div')\n//    This line declares a variable called el and assigns it to a new div element, created with the createElement method.\n\n// 3. let style = el.style\n//    This line declares a variable called style and assigns it to the style property of the el variable, which is a div element.\n\n// 4. let result = true;\n//    This line declares a variable called result and assigns it to a boolean value of true.\n\n// 5. if(len === 2) {\n//    This line is an if statement that checks if the number of arguments passed to the function is equal to 2.\n\n// 6. if(typeof args[0] === 'string' && typeof args[1] === 'string') {\n//    This line is an if statement nested inside the previous if statement, which checks if the first and second arguments passed to the function are both strings.\n\n// 7. style.setProperty(args[0], args[1])\n//    This line sets the property of the style variable to the first and second arguments passed to the function.\n\n// 8. result = window.getComputedStyle(el).getPropertyValue(args[0]);\n//    This line assigns the variable result to the computed style of the el variable, which is a div element, using the getPropertyValue method and the first argument passed to the function.\n\n// 9. else if (len === 1) {\n//    This line is an else if statement that checks if the number of arguments passed to the function is equal to 1.\n\n// 10. if (typeof args[0] === 'string') {\n//    This line is an if statement nested inside the else if statement, which checks if the first argument passed to the function is a string.\n\n// 11. return style[args[0]] !== undefined\n//    This line returns a boolean value of true or false, depending on whether the value of the style variable, which is a div element, and the first argument passed to the function is undefined or not.\n\n// 12. else {\n//    This line is an else statement that is nested inside the else if statement.\n\n// 13. let supported = true;\n//    This line declares a variable called supported and assigns it to a boolean value of true.\n\n// 14. Object.keys(args[0]).forEach(prop => {\n//    This line uses the Object.keys method to loop through the first argument passed to the function and pass each key to the forEach method.\n\n// 15. style.setProperty(prop, args[0][prop])\n//    This line sets the property of the style variable to the key of the first argument passed to the function and the value of that key.\n\n// 16. supported = window.getComputedStyle(el).getPropertyValue(prop);\n//    This line assigns the variable supported to the computed style of the el variable, which is a div element, using the getPropertyValue method and the key of the first argument passed to the function.\n\n// 17. result = supported\n//    This line assigns the variable result to the value of the supported variable.\n\n// 18. return result;\n//    This line returns the value of the result variable.",
    useCase:
      "\n\nCSS.supports is used in Javascript to check if the current user's browser supports a specific CSS property and its associated value. This helps developers create websites and apps that will function correctly across different browsers. It also allows developers to provide different styles or functionality based on the user's browser.",
  },
  {
    code: "\n\n(function () {\n  if ( typeof window.CustomEvent === \"function\" ) return false;\n\n  function CustomEvent ( event, params ) {\n    params = params || { bubbles: false, cancelable: false, detail: undefined };\n    var evt = document.createEvent( 'CustomEvent' );\n    evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );\n    return evt;\n   }\n\n  CustomEvent.prototype = window.Event.prototype;\n\n  window.CustomEvent = CustomEvent;\n})();",
    term: "CustomEvent",
    explain:
      "\n\n1. (function () {...})(); \n// This is an immediately invoked function expression (IIFE). It allows us to use variables and functions without polluting the global scope.\n\n2. if ( typeof window.CustomEvent === \"function\" ) return false;\n// This checks to see if a function called CustomEvent exists in the global window scope. If it does, the function exits.\n\n3. function CustomEvent ( event, params ) {...}\n// This is a function declaration that takes two parameters, event and params.\n\n4. params = params || { bubbles: false, cancelable: false, detail: undefined };\n// This sets the params parameter to the given value, or if it is undefined, it sets it to an object with the given values for bubbles, cancelable, and detail.\n\n5. var evt = document.createEvent( 'CustomEvent' );\n// This creates a new event object called evt in the document object.\n\n6. evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );\n// This initializes the event object with the given parameters.\n\n7. return evt;\n// This returns the event object.\n\n8. CustomEvent.prototype = window.Event.prototype;\n// This sets the prototype of the CustomEvent function to the prototype of the window.Event function.\n\n9. window.CustomEvent = CustomEvent;\n// This sets the CustomEvent function as a property of the global window object.",
    useCase:
      "\n\nCustomEvent is used in Javascript to allow developers to create and trigger their own custom events. With CustomEvent, developers can define the name, type, and details of the event in order to handle it in their own unique way. This is especially useful when dealing with complex user interactions that need to be handled in a particular order. By creating a custom event, developers can ensure that the expected behavior is triggered and that the application remains consistent.",
  },
  {
    code: "\n\nif (typeof DOMRect === 'undefined' || DOMRect === null) {\n  class DOMRect {\n    constructor(x = 0, y = 0, width = 0, height = 0) {\n      this.x = x;\n      this.y = y;\n      this.width = width;\n      this.height = height;\n      this.top = this.y;\n      this.left = this.x;\n      this.right = this.x + this.width;\n      this.bottom = this.y + this.height;\n    }\n  }\n\n  window.DOMRect = DOMRect;\n}",
    term: "DOMRect",
    explain:
      "\n\n//Line 1: This line checks if the variable DOMRect is defined or if it is null. \n//Line 2: This line starts the DOMRect class. \n//Line 3: This line defines the constructor of the DOMRect class with initial values of 0 for x, y, width, and height. \n//Line 4-7: This lines set the x, y, width, and height values of the DOMRect class. \n//Line 8-11: This lines set the top, left, right, and bottom values of the DOMRect class. \n//Line 12: This line assigns the DOMRect class to the global window object.",
    useCase:
      "\n\nDOMRect is used in JavaScript to represent a rectangular area on the page. It is used to help compute the size and position of elements on the page, such as when calculating the position of an element relative to the viewport or when calculating the size of an element to determine how much space it occupies.",
  },
  {
    code: "\n\nif (!DOMRect.fromRect) {\n  DOMRect.fromRect = function (rect) {\n    return new DOMRect(rect.x, rect.y, rect.width, rect.height);\n  };\n}",
    term: "DOMRect.fromRect",
    explain:
      "\n\n// If the DOMRect object does not have a method called 'fromRect', create one.\n// The function takes a parameter 'rect', and uses it to create a new DOMRect object with the coordinates 'rect.x', 'rect.y', 'rect.width', and 'rect.height'.",
    useCase:
      "\n\nDOMRect.fromRect is used to create a DOMRect object from an object with properties that have the same names as the properties of DOMRect. This is useful for converting existing data structures into DOMRect objects so they can be used with the DOM. It is also helpful when passing data between different parts of a program, as it allows the data to be manipulated as a DOMRect object, rather than having to manually access each property.",
  },
  {
    code: "\n\nif (typeof DOMTokenList === 'undefined') {\n    (function (global) {\n        \"use strict\";\n        var DOMTokenList = function(el) {\n            Object.defineProperty(this, '_elem', { value: el });\n            var str = el.getAttribute('class') || '';\n            var classes = str.trim().split(/\\s+/);\n            for (var i = 0; i < classes.length; i++) {\n                Object.defineProperty(this, i, { value: classes[i] });\n            }\n            Object.defineProperty(this, 'length', { value: classes.length });\n        };\n        DOMTokenList.prototype = {\n            constructor: DOMTokenList,\n            item: function(index) {\n                return this[index] || null;\n            },\n            contains: function(token) {\n                for (var i = 0; i < this.length; i++) {\n                    if (this[i] === token) {\n                        return true;\n                    }\n                }\n                return false;\n            },\n            add: function() {\n                for (var i = 0; i < arguments.length; i++) {\n                    if (!this.contains(arguments[i])) {\n                        Object.defineProperty(this, this.length, {\n                            value: arguments[i]\n                        });\n                        this.length++;\n                    }\n                }\n                this._elem.setAttribute('class', [].slice.call(this).join(' '));\n            },\n            remove: function() {\n                for (var i = 0; i < arguments.length; i++) {\n                    for (var j = 0; j < this.length; j++) {\n                        if (this[j] === arguments[i]) {\n                            [].splice.call(this, j, 1);\n                            j--;\n                            this.length--;\n                        }\n                    }\n                }\n                this._elem.setAttribute('class', [].slice.call(this).join(' '));\n            },\n            toggle: function(token) {\n                if (this.contains(token)) {\n                    this.remove(token);\n                    return false;\n                } else {\n                    this.add(token);\n                    return true;\n                }\n            }\n        };\n        global.DOMTokenList = DOMTokenList;\n    })(window);\n}",
    term: "DOMTokenList",
    explain:
      "\n\n//line 1: if (typeof DOMTokenList === 'undefined') {\n//This line checks if the DOMTokenList is already defined or not. If it is not defined then the code inside the if block will be executed\n\n//line 2: (function (global) {\n//This line creates a self-invoking anonymous function with global as a parameter.\n\n//line 3: \"use strict\";\n//This line sets the JavaScript code to strict mode which helps to write secure code.\n\n//line 4: var DOMTokenList = function(el) {\n//This line creates a DOMTokenList function with el as a parameter.\n\n//line 5-8: Object.defineProperty(this, '_elem', { value: el });\n//These lines define a property called \"_elem\" with the value of el on the current object.\n\n//line 9: var str = el.getAttribute('class') || '';\n//This line gets the class attribute value of the element and assigns it to a variable called str. If the class attribute is not present then an empty string is assigned to str.\n\n//line 10: var classes = str.trim().split(/\\s+/);\n//This line trims the whitespaces in the str variable and splits the string into an array of classes.\n\n//line 11-13: for (var i = 0; i < classes.length; i++) {\n//This line is a for loop which iterates over each class in the classes array.\n\n//line 14-15: Object.defineProperty(this, i, { value: classes[i] });\n//These lines define a property with the index of the class in the classes array as the name and the value of the class as the value of the property.\n\n//line 16-17: Object.defineProperty(this, 'length', { value: classes.length });\n//These lines define a property called \"length\" with the value of the length of the classes array.\n\n//line 18-48: This is the definition of the DOMTokenList prototype.\n\n//line 49-55: global.DOMTokenList = DOMTokenList;\n//These lines assign the DOMTokenList function to the global object.\n\n//line 56: })(window);\n//This line invokes the anonymous function assigning the window object as the parameter.",
    useCase:
      "\n\nDOMTokenList is used in JavaScript to enable the manipulation of the class attribute of a DOM element. It provides methods to add, remove, and toggle the classes of a DOM element, which can be used to change the styling of the element. This is especially useful when creating dynamic web pages, as it allows elements to be styled based on user input.",
  },
  {
    code: "\n\nDOMTokenList.prototype[Symbol.iterator] = function() {\n  let i = 0;\n  const len = this.length;\n  const tokens = this.value;\n  return {\n    next() {\n      if (i < len) {\n        return {\n          done: false,\n          value: tokens[i++]\n        }\n      } else {\n        return {\n          done: true\n        }\n      }\n    }\n  }\n};",
    term: "DOMTokenList.prototype.@@iterator",
    explain:
      '\n\n// Line 1: This line is adding a new prototype method to the DOMTokenList class. The method is using the Symbol.iterator Symbol as its name.\n// Line 2: This line is declaring a variable called "i" and initializing it to 0.\n// Line 3: This line is declaring a variable called "len" and initializing it to the length of the DOMTokenList.\n// Line 4: This line is declaring a variable called "tokens" and initializing it to the value of the DOMTokenList.\n// Line 5-9: This is a return statement containing a function that takes no arguments and returns an object. The object contains two properties, "done" and "value", and their values are determined by the if statement. If the value of i is less than the value of len, the done property is set to false and the value property is set to the token at the current index. If i is not less than len, the done property is set to true. \n// Line 10: This line is the closing brace of the return statement.',
    useCase:
      "\n\nDOMTokenList.prototype.@@iterator is used in Javascript to provide an iterable interface for the DOMTokenList interface. This allows for iterating over the list of tokens in a DOMTokenList, which can be useful for looping through the list to perform operations. This is especially useful when working with HTML elements and manipulating their attributes.",
  },
  {
    code: '\n\nif ((typeof DOMTokenList !== "undefined") && !("forEach" in DOMTokenList.prototype)) {\n  DOMTokenList.prototype.forEach = function forEach(callback) {\n    for (var i = 0; i < this.length; i++) {\n      callback(this.item(i), i, this);\n    }\n  };\n}',
    term: "DOMTokenList.prototype.forEach",
    explain:
      '\n\n//This line checks if the DOMTokenList is defined and if the forEach method is not already a part of the DOMTokenList.prototype\nif ((typeof DOMTokenList !== "undefined") && !("forEach" in DOMTokenList.prototype)) {\n\n//This line creates the forEach method for the DOMTokenList.prototype\n  DOMTokenList.prototype.forEach = function forEach(callback) {\n\n//This line is the loop that iterates over the DOMTokenList\n    for (var i = 0; i < this.length; i++) {\n\n//This line calls the callback function for each item in the DOMTokenList\n      callback(this.item(i), i, this);\n    }\n  };\n\n//This line closes the if statement\n}',
    useCase:
      "\n\nDOMTokenList.prototype.forEach is used in Javascript to iterate over the list of tokens in a DOMTokenList object. It allows developers to perform a function on each item in the list, making it easy to manipulate the data. This can be used to filter out certain tokens, add new tokens, or do any other operation on the list.",
  },
  {
    code: "\n\nif (!('replace' in DOMTokenList.prototype)) {\n  DOMTokenList.prototype.replace = function (token, newToken) {\n    if (this.contains(token)) {\n      this.remove(token);\n      if (newToken) {\n        this.add(newToken);\n      }\n    }\n  };\n}",
    term: "DOMTokenList.prototype.replace",
    explain:
      "\n\n// This code checks to see if the 'replace' method is not present in the DOMTokenList prototype. \n// If 'replace' is not present, then the code defines a new 'replace' method on the prototype. \n// The new 'replace' method takes two parameters, token and newToken. \n// It then checks to see if the token is present in the list and if it is, it removes it and if there is a newToken provided, it adds it.",
    useCase:
      "\n\nDOMTokenList.prototype.replace is used in Javascript to replace an existing token with a new one. It is useful for updating the classList of an element by replacing an existing class with a new one. This method is also useful for manipulating HTML attributes such as rel, type, and media.",
  },
  {
    code: "\n\n// Polyfill for DataView\nif (!window.DataView) {\n  window.DataView = class DataView {\n    constructor(buffer, byteOffset = 0, byteLength = buffer.byteLength) {\n      this.buffer = buffer;\n      this.byteOffset = byteOffset;\n      this.byteLength = byteLength;\n    }\n    getInt8(byteOffset) {\n      return this._get(byteOffset, 1)[0];\n    }\n    getUint8(byteOffset) {\n      return this.getInt8(byteOffset) >>> 0;\n    }\n    getInt16(byteOffset, littleEndian) {\n      return this._get(byteOffset, 2, littleEndian)[0];\n    }\n    getUint16(byteOffset, littleEndian) {\n      return this.getInt16(byteOffset, littleEndian) >>> 0;\n    }\n    getInt32(byteOffset, littleEndian) {\n      return this._get(byteOffset, 4, littleEndian)[0];\n    }\n    getUint32(byteOffset, littleEndian) {\n      return this.getInt32(byteOffset, littleEndian) >>> 0;\n    }\n    getFloat32(byteOffset, littleEndian) {\n      return this._get(byteOffset, 4, littleEndian)[0];\n    }\n    getFloat64(byteOffset, littleEndian) {\n      return this._get(byteOffset, 8, littleEndian)[0];\n    }\n    setInt8(byteOffset, value) {\n      this._set(byteOffset, [value], 1);\n    }\n    setUint8(byteOffset, value) {\n      this.setInt8(byteOffset, value);\n    }\n    setInt16(byteOffset, value, littleEndian) {\n      this._set(byteOffset, [value], 2, littleEndian);\n    }\n    setUint16(byteOffset, value, littleEndian) {\n      this.setInt16(byteOffset, value, littleEndian);\n    }\n    setInt32(byteOffset, value, littleEndian) {\n      this._set(byteOffset, [value], 4, littleEndian);\n    }\n    setUint32(byteOffset, value, littleEndian) {\n      this.setInt32(byteOffset, value, littleEndian);\n    }\n    setFloat32(byteOffset, value, littleEndian) {\n      this._set(byteOffset, [value], 4, littleEndian);\n    }\n    setFloat64(byteOffset, value, littleEndian) {\n      this._set(byteOffset, [value], 8, littleEndian);\n    }\n    _get(byteOffset, size, littleEndian) {\n      if (byteOffset + size > this.byteLength) {\n        throw new RangeError('Index out of range');\n      }\n      const view = new Uint8Array(this.buffer, this.byteOffset + byteOffset, size);\n      const result = [0];\n      for (let i = 0; i < size; i++) {\n        result[0] += view[i] * Math.pow(2, 8 * (littleEndian ? size - i - 1 : i));\n      }\n      return result;\n    }\n    _set(byteOffset, values, size, littleEndian) {\n      if (byteOffset + size > this.byteLength) {\n        throw new RangeError('Index out of range');\n      }\n      const view = new Uint8Array(this.buffer, this.byteOffset + byteOffset, size);\n      for (let i = 0; i < size; i++) {\n        const factor = Math.pow(2, 8 * (littleEndian ? size - i - 1 : i));\n        view[i] = (values[0] / factor) & 0xff;\n      }\n    }\n  };\n}",
    term: "DataView",
    explain:
      "\n\n//This code is a Polyfill for DataView, which is a JavaScript type for representing a collection of data in a structured way. This code is setting up a class called DataView, which will contain methods for getting and setting data in the structured collection of data.\n\n// Line 1: This line is checking if window.DataView is defined, and if it isn't, then it will proceed to the code following this line. \n\n// Lines 2-29: This section of code is defining the class DataView. The constructor takes three parameters, buffer, byteOffset and byteLength. The class will also contain methods for getting and setting data, such as getInt8, getUint8, getInt16, getUint16, getInt32, getUint32, getFloat32, getFloat64, setInt8, setUint8, setInt16, setUint16, setInt32, setUint32, setFloat32, setFloat64.\n\n// Lines 30-60: This section defines the method _get which takes three parameters, byteOffset, size and littleEndian. It will also throw a RangeError when the byteOffset is out of range.\n\n// Lines 61-87: This section defines the method _set which takes four parameters, byteOffset, values, size and littleEndian. It will also throw a RangeError when the byteOffset is out of range.",
    useCase:
      "\n\nDataView is used in JavaScript to provide a low-level interface for reading and writing multiple number types in an ArrayBuffer, without having to worry about the platform's endianness. It allows developers to manipulate binary data in a consistent format, regardless of the platform. It also provides a way to access data stored in an ArrayBuffer without having to copy it into a new data structure.",
  },
  {
    code: "\n\nif (!Date.now) {\n  Date.now = function() {\n    return new Date().getTime();\n  };\n}",
    term: "Date.now",
    explain:
      "\n\n// Line 1: This sets up a conditional statement that checks if the Date.now function does not exist.\n// Line 2: If the Date.now function does not exist, this creates it as a function that returns the time since midnight of January 1, 1970 (in milliseconds). This is the standard JavaScript date format.",
    useCase:
      "\n\nDate.now() is used in Javascript to get the current timestamp in milliseconds since the Unix epoch, which is the number of milliseconds that have elapsed since January 1, 1970 00:00:00 UTC. This is useful for creating unique identifiers, measuring the time elapsed between events, and other related tasks.",
  },
  {
    code: "\n\nif (!Date.prototype.toISOString) {\n  Date.prototype.toISOString = function () {\n    Date.prototype.toISOString = function () {\n      var tzo = -this.getTimezoneOffset(),\n        dif = tzo >= 0 ? '+' : '-',\n        pad = function (num) {\n          var norm = Math.floor(Math.abs(num));\n          return (norm < 10 ? '0' : '') + norm;\n        };\n      return this.getFullYear() +\n        '-' + pad(this.getMonth() + 1) +\n        '-' + pad(this.getDate()) +\n        'T' + pad(this.getHours()) +\n        ':' + pad(this.getMinutes()) +\n        ':' + pad(this.getSeconds()) +\n        dif + pad(tzo / 60) +\n        ':' + pad(tzo % 60);\n    };\n  }\n}",
    term: "Date.prototype.toISOString",
    explain:
      "\n\n// This code checks if the Date.prototype.toISOString() method exists. If it does not exist, it will create a function to add it. \n// Line 1: If the Date.prototype.toISOString() method does not exist\n// Line 2: Add the Date.prototype.toISOString() method\n// Line 3: Get the timezone offset and determine if it is positive or negative\n// Line 4: Create a pad() function to get the hour, minutes and seconds\n// Line 5: Get the year\n// Line 6: Get the month \n// Line 7: Get the date\n// Line 8: Get the hour\n// Line 9: Get the minutes\n// Line 10: Get the seconds\n// Line 11: Get the timezone offset\n// Line 12: Get the minutes for the timezone offset\n// Line 13: Get the seconds for the timezone offset",
    useCase:
      "\n\nDate.prototype.toISOString is used in Javascript to produce a string representation of a Date object in ISO format, which is an international standard for representing dates and times. This format is especially useful for storing and sorting dates, as it is an unambiguous representation that can be easily parsed and compared to other dates. It is also useful for passing dates between different systems, as it is a widely recognized format.",
  },
  {
    code: "\n\nif (!Document) {\n  Document = function Document() {\n    this.nodeType = 9;\n    this.name = '#document';\n    this.childNodes = [];\n    this.childElementCount = 0;\n    this.children = [];\n    this.firstChild = null;\n    this.lastChild = null;\n    this.documentElement = null;\n\n    // Methods\n    Object.defineProperty(Document, 'createElement', {\n      value: function createElement(tagName) {\n        var element = new Element(tagName);\n        element.ownerDocument = this;\n        return element;\n      }\n    });\n\n    Object.defineProperty(Document, 'createTextNode', {\n      value: function createTextNode(text) {\n        var textNode = new Text(text);\n        textNode.ownerDocument = this;\n        return textNode;\n      }\n    });\n\n    Object.defineProperty(Document, 'createDocumentFragment', {\n      value: function createDocumentFragment() {\n        var documentFragment = new DocumentFragment();\n        documentFragment.ownerDocument = this;\n        return documentFragment;\n      }\n    });\n  };\n\n  // Classes\n  var Element = function Element(tagName) {\n    this.nodeType = 1;\n    this.tagName = tagName;\n    this.parentNode = null;\n    this.nextSibling = null;\n    this.previousSibling = null;\n    this.attributes = {};\n  };\n\n  var Text = function Text(text) {\n    this.nodeType = 3;\n    this.textContent = text;\n    this.parentNode = null;\n    this.nextSibling = null;\n    this.previousSibling = null;\n  };\n\n  var DocumentFragment = function DocumentFragment() {\n    this.nodeType = 11;\n    this.childNodes = [];\n    this.childElementCount = 0;\n    this.children = [];\n    this.firstChild = null;\n    this.lastChild = null;\n    this.parentNode = null;\n    this.nextSibling = null;\n    this.previousSibling = null;\n  };\n}",
    term: "Document",
    explain:
      '\n\n//This code is creating a JavaScript class that can be used to represent the DOM document.\n\n//if (!Document): Checks if "Document" is not defined.\n\n//Document = function Document(): If not defined, it creates a constructor function called "Document".\n\n//this.nodeType = 9: Sets the "nodeType" property of the Document object to 9.\n\n//this.name = \'#document\': Sets the "name" property of the Document object to \'#document\'.\n\n//this.childNodes = []: Sets the "childNodes" property of the Document object to an empty array.\n\n//this.childElementCount = 0: Sets the "childElementCount" property of the Document object to 0.\n\n//this.children = []; Sets the "children" property of the Document object to an empty array.\n\n//this.firstChild = null: Sets the "firstChild" property of the Document object to null.\n\n//this.lastChild = null: Sets the "lastChild" property of the Document object to null.\n\n//this.documentElement = null: Sets the "documentElement" property of the Document object to null.\n\n//Object.defineProperty(Document, \'createElement\', {value: function createElement(tagName) {...}: Creates a new "createElement" method on the Document object which will take a tag name as an argument and return an Element object with the given tag name.\n\n//Object.defineProperty(Document, \'createTextNode\', {value: function createTextNode(text) {...}: Creates a new "createTextNode" method on the Document object which will take a string of text as an argument and return a Text object with the given text.\n\n//Object.defineProperty(Document, \'createDocumentFragment\', {value: function createDocumentFragment() {...}: Creates a new "createDocumentFragment" method on the Document object which will return a DocumentFragment object.\n\n//var Element = function Element(tagName): Creates a constructor function called "Element" which will take a tag name as an argument.\n\n//this.nodeType = 1: Sets the "nodeType" property of the Element object to 1.\n\n//this.tagName = tagName: Sets the "tagName" property of the Element object to the given tag name.\n\n//this.parentNode = null: Sets the "parentNode" property of the Element object to null.\n\n//this.nextSibling = null: Sets the "nextSibling" property of the Element object to null.\n\n//this.previousSibling = null: Sets the "previousSibling" property of the Element object to null.\n\n//this.attributes = {}: Sets the "attributes" property of the Element object to an empty object.\n\n//var Text = function Text(text): Creates a constructor function called "Text" which will take a string of text as an argument.\n\n//this.nodeType = 3: Sets the "nodeType" property of the Text object to 3.\n\n//this.textContent = text: Sets the "textContent" property of the Text object to the given text.\n\n//this.parentNode = null: Sets the "parentNode" property of the Text object to null.\n\n//this.nextSibling = null: Sets the "nextSibling" property of the Text object to null.\n\n//this.previousSibling = null: Sets the "previousSibling" property of the Text object to null.\n\n//var DocumentFragment = function DocumentFragment(): Creates a constructor function called "DocumentFragment".\n\n//this.nodeType = 11: Sets the "nodeType" property of the DocumentFragment object to 11.\n\n//this.childNodes = []: Sets the "childNodes" property of the DocumentFragment object to an empty array.\n\n//this.childElementCount = 0: Sets the "childElementCount" property of the DocumentFragment object to 0.\n\n//this.children = []; Sets the "children" property of the DocumentFragment object to an empty array.\n\n//this.firstChild = null: Sets the "firstChild" property of the DocumentFragment object to null.\n\n//this.lastChild = null: Sets the "lastChild" property of the DocumentFragment object to null.\n\n//this.parentNode = null: Sets the "parentNode" property of the DocumentFragment object to null.\n\n//this.nextSibling = null: Sets the "nextSibling" property of the DocumentFragment object to null.\n\n//this.previousSibling = null: Sets the "previousSibling" property of the DocumentFragment object to null.',
    useCase:
      "\n\nDocument is used in Javascript to access and manipulate the content of HTML and XML documents. It provides methods and properties to interact with elements on the page, such as accessing and modifying the HTML or XML document's content, attributes, or styling. Document also provides methods to create new elements and add them to the document, as well as methods for deleting, replacing, or inserting elements.",
  },
  {
    code: '\n\n(function () {\n    if (typeof window.DocumentFragment === "undefined") {\n        window.DocumentFragment = function DocumentFragment() {\n            var element = document.createElement("div");\n            element._children = [];\n\n            element.appendChild = function (child) {\n                var l = this._children.length;\n                this._children[l] = child;\n                this.appendChild = function (child) {\n                    var l = this._children.length;\n                    this._children[l] = child;\n                    return child;\n                };\n                return child;\n            };\n\n            element.querySelectorAll = function (selector) {\n                var result = [];\n                var els;\n                for (var i = 0; i < this._children.length; i++) {\n                    els = this._children[i].querySelectorAll(selector);\n                    for (var j = 0; j < els.length; j++) {\n                        result.push(els[j]);\n                    }\n                }\n                return result;\n            };\n\n            element.querySelector = function (selector) {\n                for (var i = 0; i < this._children.length; i++) {\n                    var el = this._children[i].querySelector(selector);\n                    if (el) {\n                        return el;\n                    }\n                }\n                return null;\n            };\n\n            element.cloneNode = function (deep) {\n                if (deep) {\n                    var clone = document.createDocumentFragment();\n                    for (var i = 0; i < this._children.length; i++) {\n                        clone.appendChild(this._children[i].cloneNode(true));\n                    }\n                    return clone;\n                }\n                else {\n                    return this;\n                }\n            };\n\n            return element;\n        };\n    }\n})();',
    term: "DocumentFragment",
    explain:
      '\n\n//This code creates a polyfill for DocumentFragment if it is undefined in the browser. \n\n//(function () {\n//This line creates an anonymous function that is immediately invoked. \n\n//    if (typeof window.DocumentFragment === "undefined") {\n//This line checks if the window object has a property called DocumentFragment that is undefined. \n\n//        window.DocumentFragment = function DocumentFragment() {\n//This line creates a new property called DocumentFragment on window that is a function.\n\n//            var element = document.createElement("div");\n//This line creates a new variable called element that is an empty div.\n\n//            element._children = [];\n//This line creates a new array on the element variable called _children. \n\n//            element.appendChild = function (child) {\n//This line adds a method called appendChild to the element variable that takes one argument called child. \n\n//                var l = this._children.length;\n//This line creates a new variable called l that is set to the length of the _children array. \n\n//                this._children[l] = child;\n//This line sets the last index of the _children array to the argument passed in. \n\n//                this.appendChild = function (child) {\n//This line adds a method called appendChild to the element variable that takes one argument called child. \n\n//                    var l = this._children.length;\n//This line creates a new variable called l that is set to the length of the _children array. \n\n//                    this._children[l] = child;\n//This line sets the last index of the _children array to the argument passed in. \n\n//                    return child;\n//This line returns the child argument. \n\n//                };\n//This line closes the appendChild function. \n\n//                return child;\n//This line returns the child argument. \n\n//            };\n//This line closes the appendChild method. \n\n//            element.querySelectorAll = function (selector) {\n//This line adds a method called querySelectorAll to the element variable that takes one argument called selector. \n\n//                var result = [];\n//This line creates a new array called result. \n\n//                var els;\n//This line creates a new variable called els. \n\n//                for (var i = 0; i < this._children.length; i++) {\n//This line loop through the _children array. \n\n//                    els = this._children[i].querySelectorAll(selector);\n//This line sets the els variable to an array of elements that match the selector argument. \n\n//                    for (var j = 0; j < els.length; j++) {\n//This line loop through the els array. \n\n//                        result.push(els[j]);\n//This line adds each element to the result array. \n\n//                    }\n//This line closes the loop. \n\n//                }\n//This line closes the loop.\n\n//                return result;\n//This line returns the result array. \n\n//            };\n//This line closes the querySelectorAll method.\n\n//            element.querySelector = function (selector) {\n//This line adds a method called querySelector to the element variable that takes one argument called selector. \n\n//                for (var i = 0; i < this._children.length; i++) {\n//This line loop through the _children array. \n\n//                    var el = this._children[i].querySelector(selector);\n//This line sets the el variable to the element that matches the selector argument. \n\n//                    if (el) {\n//This line checks if the el variable is truthy. \n\n//                        return el;\n//This line returns the el variable. \n\n//                    }\n//This line closes the if statement. \n\n//                }\n//This line closes the loop. \n\n//                return null;\n//This line returns null. \n\n//            };\n//This line closes the querySelector method. \n\n//            element.cloneNode = function (deep) {\n//This line adds a method called cloneNode to the element variable that takes one argument called deep. \n\n//                if (deep) {\n//This line checks if the deep argument is truthy.\n\n//                    var clone = document.createDocumentFragment();\n//This line creates a new variable called clone that is set to a new document fragment. \n\n//                    for (var i = 0; i < this._children.length; i++) {\n//This line loop through the _children array. \n\n//                        clone.appendChild(this._children[i].cloneNode(true));\n//This line adds a clone of each element in the _children array to the clone variable. \n\n//                    }\n//This line closes the loop. \n\n//                    return clone;\n//This line returns the clone variable. \n\n//                }\n//This line closes the if statement. \n\n//                else {\n//This line runs if the deep argument is falsy. \n\n//                    return this;\n//This line returns the element variable. \n\n//                }\n//This line closes the else statement. \n\n//            };\n//This line closes the cloneNode method. \n\n//            return element;\n//This line returns the element variable. \n\n//        };\n//This line closes the DocumentFragment function. \n\n//    }\n//This line closes the if statement. \n\n//})();\n//This line closes the anonymous function and immediately invokes it.',
    useCase:
      "\n\nDocumentFragment is a lightweight, transient DOM node that can be used to hold multiple DOM nodes. It is a useful tool when building dynamic web pages, as it allows the user to group multiple nodes together and make a single insertion into the DOM tree. DocumentFragment is also useful when dealing with large DOM trees, as it reduces the amount of repainting and reflowing required when making multiple DOM changes. It can also be used to reduce the amount of memory used when making multiple DOM modifications, since the DocumentFragment itself is not part of the actual DOM tree.",
  },
  {
    code: "\n\nif (!DocumentFragment.prototype.append) {\n  DocumentFragment.prototype.append = function(node) {\n    this.appendChild(node);\n  };\n}",
    term: "DocumentFragment.prototype.append",
    explain:
      "\n\n// 1. if (!DocumentFragment.prototype.append) { \n//     This line checks if DocumentFragment.prototype object has an 'append' property. \n\n// 2. DocumentFragment.prototype.append = function(node) {\n//     If the 'append' property doesn't exist, this line adds an 'append' property to the DocumentFragment.prototype object which is a function that takes a parameter called 'node'\n\n// 3. this.appendChild(node);\n//     This line calls the appendChild method of the DocumentFragment.prototype object, passing in the 'node' parameter as an argument.",
    useCase:
      "\n\nDocumentFragment.prototype.append is used in Javascript to efficiently add elements to a DocumentFragment. It is an easier and more efficient way of adding DOM elements to a DocumentFragment than manually creating each element and appending it. DocumentFragment.prototype.append allows developers to quickly add multiple elements to a DocumentFragment, which can then be added to the DOM. This makes it easier to manipulate the DOM and also helps to reduce the amount of code that needs to be written.",
  },
  {
    code: "\n\nif (!DocumentFragment.prototype.hasOwnProperty('prepend')) {\n  DocumentFragment.prototype.prepend = function () {\n    const args = [].slice.call(arguments);\n    const firstChild = this.firstChild;\n\n    args.forEach((arg) => {\n      if (arg instanceof Node) {\n        this.insertBefore(arg, firstChild);\n      } else if (typeof arg === 'string' || typeof arg === 'number') {\n        const node = document.createTextNode(arg);\n        this.insertBefore(node, firstChild);\n      } else {\n        throw new Error(\n          `Error: DocumentFragment.prototype.prepend() only accepts instances of Node or strings`\n        );\n      }\n    });\n  };\n}",
    term: "DocumentFragment.prototype.prepend",
    explain:
      "\n\n// Line 1: This line checks if the DocumentFragment prototype does not have the property 'prepend'.\n// Line 2: If the DocumentFragment prototype does not have the property 'prepend', this line creates a function called 'prepend' which is attached to the DocumentFragment prototype.\n// Line 3: This line creates an array called 'args' that contains all of the arguments passed to the 'prepend' function.\n// Line 4: This line creates a variable called 'firstChild' that holds a reference to the first child of the DocumentFragment.\n// Line 5: This line uses the 'forEach' method to iterate over all of the items in the 'args' array.\n// Line 6: This line checks if the current item in the 'args' array is an instance of the Node class.\n// Line 7: If the item is an instance of the Node class, this line inserts the node before the 'firstChild' of the DocumentFragment.\n// Line 8: This line checks if the current item in the 'args' array is a string or a number.\n// Line 9: If the item is a string or a number, this line creates a TextNode with the provided argument and inserts it before the 'firstChild' of the DocumentFragment.\n// Line 10: If the item is neither a Node instance nor a string/number, this line throws an error.",
    useCase:
      "\n\nDocumentFragment.prototype.prepend is used in Javascript to allow for the insertion of multiple elements into the DOM at once. This can be useful for performance when making multiple changes, as the browser only needs to perform a single DOM update. Additionally, this method allows developers to insert elements into the DOM before the start of the document, which can be useful in certain scenarios.",
  },
  {
    code: "\n\nif ( typeof Element !== 'function' ) {\n  Element = function( name ) {\n    this.name = name;\n  }\n\n  Element.prototype.render = function(){\n    return `<${this.name}></${this.name}>`;\n  }\n}",
    term: "Element",
    explain:
      "\n\n//This code checks to see if the Element function has been defined.\n//If not, it creates a new Element function with a parameter of name. \n//It then sets the prototype of the Element function to a render function, \n//which returns a string of the HTML element with the name passed in from the parameter.",
    useCase:
      "\n\nElement is used in JavaScript to access and manipulate HTML elements on a page. It enables developers to interact with the page’s Document Object Model (DOM) to make changes to the page’s structure, style, and content. With Element, developers can access specific HTML elements, change their attributes, and add and remove elements from the page. Element makes it easy to create complex web page interactions and animations.",
  },
  {
    code: "\n\n// Element.prototype.after\nif (!Element.prototype.after) {\n  Element.prototype.after = function(newNode) {\n    let nextSibling = this.nextSibling;\n    let parent = this.parentNode;\n    if (nextSibling) {\n      parent.insertBefore(newNode, nextSibling);\n    } else {\n      parent.appendChild(newNode);\n    }\n  };\n}",
    term: "Element.prototype.after",
    explain:
      "\n\n//Line 1: This line is creating a new property of Element, called after.\n//Line 2: This line checks to see if the after property already exists, and if it does not, it executes the code in the block.\n//Line 3: This line creates a new function called after and sets it to the after property of Element.\n//Line 4: This line creates a new variable called nextSibling to store the element's next sibling.\n//Line 5: This line creates a new variable called parent to store the element's parent node.\n//Line 6: This line checks to see if there is a next sibling. If there is, it executes the code in the block.\n//Line 7: This line inserts the newNode, before the nextSibling.\n//Line 8: This line is the else statement for line 6. If there is not a next sibling, it executes the code in the block.\n//Line 9: This line appends the newNode to the parent node.",
    useCase:
      "\n\nElement.prototype.after is used in JavaScript to insert a node or an HTML string after a specified element. This is useful when an element needs to be dynamically added to the DOM after an existing element. This method allows developers to quickly and easily add new elements to the DOM without having to write cumbersome code to locate the desired element and then locate the element after it.",
  },
  {
    code: '\n\n(function () {\n  // Check if the browser supports Element.prototype.animate\n  if (!Element.prototype.animate) {\n    // If not, add the prototype\n    Element.prototype.animate = function (keyframe, options) {\n      // Check if the keyframe argument is valid\n      if (!keyframe || typeof keyframe !== "object") {\n        throw new TypeError("First argument must be a valid object")\n      }\n\n      // Check if the options argument is valid\n      if (options && typeof options !== "object") {\n        throw new TypeError("Second argument must be a valid object")\n      }\n\n      // Create an animation\n      let animation = this.animate([], keyframe, options)\n\n      // Monitor the animation and dispatch events\n      return new Promise((resolve, reject) => {\n        animation.addEventListener(\'finish\', resolve)\n        animation.addEventListener(\'cancel\', reject)\n      })\n    }\n  }\n})();',
    term: "Element.prototype.animate",
    explain:
      '\n\n// (function () {\n// This line of code creates an anonymous self-executing function, meaning it will run immediately when the script is executed.\n\n//   if (!Element.prototype.animate) {\n// This line of code checks if the Element.prototype.animate method exists. If it does not exist, it will be added.\n\n//     Element.prototype.animate = function (keyframe, options) {\n// This line of code adds the Element.prototype.animate method to the Element prototype.\n\n//       if (!keyframe || typeof keyframe !== "object") {\n// This line of code checks if the keyframe argument is valid. If it is not valid, it will throw an error.\n\n//         throw new TypeError("First argument must be a valid object")\n// This line of code will throw an error if the keyframe argument is not valid.\n\n//       if (options && typeof options !== "object") {\n// This line of code checks if the options argument is valid. If it is not valid, it will throw an error.\n\n//         throw new TypeError("Second argument must be a valid object")\n// This line of code will throw an error if the options argument is not valid.\n\n//       let animation = this.animate([], keyframe, options)\n// This line of code creates an animation using the provided keyframe and options arguments.\n\n//       return new Promise((resolve, reject) => {\n// This line of code returns a new Promise object which will either resolve or reject based on the outcome of the animation.\n\n//         animation.addEventListener(\'finish\', resolve)\n// This line of code adds an event listener that will resolve the Promise if the animation finishes successfully.\n\n//         animation.addEventListener(\'cancel\', reject)\n// This line of code adds an event listener that will reject the Promise if the animation is cancelled.\n\n//       })\n// This line of code closes the Promise object.\n\n//     }\n// This line of code closes the Element.prototype.animate method.\n\n//   }\n// This line of code closes the if statement.\n\n// })();\n// This line of code closes the anonymous self-executing function.',
    useCase:
      "\n\nElement.prototype.animate is used to animate HTML elements in Javascript. It allows for the animation of specific properties of an element, such as its size, position, color, or opacity. It is a powerful tool for creating interactive, dynamic, and animated web experiences. It also gives developers the ability to create highly-customizable animations with just a few lines of code.",
  },
  {
    code: '\n\nif (!Element.prototype.append) {\n  Element.prototype.append = function append(children) {\n    if (children == null) {\n      return;\n    }\n    if (typeof children === "string") {\n      this.insertAdjacentHTML("beforeend", children);\n    } else {\n      if (Array.isArray(children)) {\n        for (var i = 0; i < children.length; i++) {\n          this.append(children[i]);\n        }\n      } else {\n        this.appendChild(children);\n      }\n    }\n  };\n}',
    term: "Element.prototype.append",
    explain:
      "\n\n// Line 1: \n// This line checks to see if the append method already exists in the Element prototype. If it doesn't, the code inside the if statement will execute.\n\n// Line 2: \n// This line adds the append method to the Element prototype.\n\n// Line 3: \n// This line checks to see if the children argument passed to the append method is null. If it is, the code inside the if statement will execute, which is to return without doing anything.\n\n// Line 4: \n// This line checks to see if the children argument passed to the append method is a string. If it is, the code inside the if statement will execute, which is to insert the HTML into the element before the end.\n\n// Line 5: \n// This line checks to see if the children argument passed to the append method is an array. If it is, the code inside the if statement will execute, which is to loop through the array and append each element to the element.\n\n// Line 6: \n// This line is the else clause to the previous if statement. It will execute if the children argument passed to the append method is not an array. The code inside the if statement will execute, which is to append the child element to the element.",
    useCase:
      "\n\nElement.prototype.append is used in Javascript to add an element to the end of a parent element. This is useful for creating and manipulating a dynamic HTML structure. It can also be used to insert content from other sources, such as text nodes, HTML strings, and document fragments. By using Element.prototype.append, developers can quickly and easily add elements to the DOM without having to hard-code them into the HTML.",
  },
  {
    code: "\n\n// Create a function Element.prototype.before\nElement.prototype.before = function(newElement){\n    // Store the element before which newElement is to be inserted\n    let currentElement = this;\n\t\n    // If the element has a parent node\n    if (currentElement.parentNode) {\n        // Store the parent node\n        let parentNode = currentElement.parentNode;\n        \n        // If the element has a previous sibling\n        if (currentElement.previousSibling){\n            // Insert the newElement before the currentElement's previous sibling\n            parentNode.insertBefore(newElement, currentElement.previousSibling);\n        } else {\n            // Otherwise, insert the newElement at the beginning of the parentNode\n            parentNode.insertBefore(newElement, currentElement);\n        }\n    }\n};",
    term: "Element.prototype.before",
    explain:
      "\n\n// This code creates a function, Element.prototype.before, which inserts an element before the current element.\n\n// 1. Create a function Element.prototype.before: This line creates a function called Element.prototype.before which will be used to insert an element before the current element.\n\n// 2. let currentElement = this: This line stores the element before which the new element will be inserted.\n\n// 3. if (currentElement.parentNode): This line checks if the element has a parent node.\n\n// 4. let parentNode = currentElement.parentNode: This line stores the parent node of the current element.\n\n// 5. if (currentElement.previousSibling): This line checks if the element has a previous sibling.\n\n// 6. parentNode.insertBefore(newElement, currentElement.previousSibling): If the element has a previous sibling, this line inserts the new element before the current element's previous sibling.\n\n// 7. parentNode.insertBefore(newElement, currentElement): Otherwise, this line inserts the new element at the beginning of the parent node.",
    useCase:
      "\n\nElement.prototype.before is used in Javascript to insert a node before the specified element. This method can be used to add new elements before an existing element in the DOM tree without having to remove the existing element. This makes it easier and faster to update the DOM tree.",
  },
  {
    code: "\n\nif (!Element.prototype.classList) {\n    Element.prototype.classList = {\n        add: function (className) {\n            if (!this.className.includes(className)) {\n                this.className += ' ' + className;\n            }\n        },\n        remove: function (className) {\n            if (this.className.includes(className)) {\n                this.className = this.className.replace(className, '').trim();\n            }\n        },\n        toggle: function (className) {\n            if (this.className.includes(className)) {\n                this.className = this.className.replace(className, '').trim();\n            } else {\n                this.className += ' ' + className;\n            }\n        },\n        contains: function (className) {\n            return this.className.includes(className);\n        }\n    };\n}",
    term: "Element.prototype.classList",
    explain:
      "\n\n// Line 1: This line checks whether the Element.prototype.classList is available or not.\n// Line 2: If Element.prototype.classList is not available then it adds the classList object to the Element.prototype.\n// Line 3: This line adds the className to the Element.prototype.classList object if it does not present.\n// Line 4: This line removes the className from the Element.prototype.classList object if it is present.\n// Line 5: This line checks if the className is present in the Element.prototype.classList object and if it is present then it will remove the className from the list.\n// Line 6: This line checks if the className is present in the Element.prototype.classList object and if it is not present then it will add the className to the list.\n// Line 7: This line checks if the className is present in the Element.prototype.classList object and return a boolean value.",
    useCase:
      "\n\nElement.prototype.classList is used in Javascript to provide an easy way to access and manipulate the list of classes for an element. It allows developers to add, remove, toggle and check for the presence of classes on an element. This is useful for quickly changing the styles of an element by adding, removing or toggling a class. It helps to keep code clean and maintainable by avoiding the need to use string manipulation to access and modify the list of classes.",
  },
  {
    code: "\n\nif (!Element.prototype.cloneNode) {\n  Element.prototype.cloneNode = function (deep) {\n    let newClone = this.cloneNode.call(this, deep);\n\n    let attrs = this.attributes;\n    if (attrs) {\n      for (let i = 0; i < attrs.length; i++) {\n        let attr = attrs[i];\n        newClone.setAttribute(attr.name, attr.value);\n      }\n    }\n\n    return newClone;\n  };\n}",
    term: "Element.prototype.cloneNode",
    explain:
      "\n\n//Line 1: This line checks to see if the Element.prototype.cloneNode method is not defined.\n//Line 2: If the Element.prototype.cloneNode is not defined, this line creates the method and provides a function to clone the node.\n//Line 3: This line creates a new clone of the node using the cloneNode.call method.\n//Line 4: This line creates a variable to store the attributes of the node.\n//Line 5: This line checks to see if the node has any attributes.\n//Line 6: This line creates a loop to iterate through the attributes of the node.\n//Line 7: This line creates a variable to store a single attribute.\n//Line 8: This line sets the attribute of the new clone to the value of the attribute from the original node.\n//Line 9: This line returns the newly cloned node.",
    useCase:
      "\n\nElement.prototype.cloneNode is used in Javascript to create a duplicate of an existing element and its children. This allows developers to easily create copies of elements with all the same attributes, styles, and event handlers. It can also be used to quickly create multiple elements with the same properties without having to manually define each one. It is a useful tool for manipulating the DOM, creating custom elements, and reducing the amount of code required to achieve a given effect.",
  },
  {
    code: "\n\nif (window.Element && !Element.prototype.closest) {\n    // Element.prototype.closest\n    Element.prototype.closest = \n    function(s) {\n        var el = this;\n        var ancestor = this;\n        if (!document.documentElement.contains(el)) return null;\n        do {\n            if (ancestor.matches(s)) return ancestor;\n            ancestor = ancestor.parentElement;\n        } while (ancestor !== null); \n        return null;\n    };\n}",
    term: "Element.prototype.closest",
    explain:
      "\n\n// Line 1: This line checks if the window object has the Element constructor and if the Element prototype does not have the closest method. \n// Line 2: This line adds a closest method to the Element prototype.\n// Line 3: This line sets a variable el to the current element.\n// Line 4: This line sets a variable ancestor to the current element.\n// Line 5: This line checks if the document element does not contain the current element and returns null if it does not.\n// Line 6: This line loops through the ancestors of the current element and checks for a matching selector. If a match is found, it returns the ancestor.\n// Line 7: This line updates the ancestor to the parent element.\n// Line 8: This line checks if the ancestor is not null and continues looping until the ancestor is null.\n// Line 9: This line returns null if no matching selector is found.",
    useCase:
      "\n\nElement.prototype.closest() is used in Javascript to find the closest ancestor of the current element that matches the specified selector, including itself. This method is useful for traversing up the DOM tree to find the closest matching ancestor for a given element. It can be used in situations where you need to find the closest parent of an element that matches a certain criteria, such as a particular class, ID, or attribute.",
  },
  {
    code: "\n\nif (Element.prototype.dataset === undefined) {\n  Element.prototype.dataset = {};\n  Object.defineProperty(Element.prototype, 'dataset', {\n    get: function () {\n      let element = this;\n      let attributes = this.attributes;\n      let map = {};\n      for (let i = 0; i < attributes.length; i++) {\n        let attribute = attributes[i];\n        if (attribute.name.substring(0, 5) === 'data-') {\n          let key = attribute.name.substring(5);\n          let value = attribute.value;\n          map[key] = value;\n        }\n      }\n      Object.defineProperty(element, 'dataset', {\n        value: map,\n        writable: true,\n        enumerable: true\n      });\n      return map;\n    }\n  });\n}",
    term: "Element.prototype.dataset",
    explain:
      '\n\n// Line 1: This line checks if the Element.prototype.dataset property is undefined. \n// Line 2: If it is, it is set to an empty object. \n// Line 3: This line sets the Element.prototype.dataset property to a getter function. \n// Line 4: This declares a variable to store the element being tested.\n// Line 5: This line declares a variable to store the attributes of the element.\n// Line 6: This line declares a variable to store the map of data-* attributes. \n// Line 7-10: This loop iterates through the attributes and checks if the attribute name starts with "data-". If it does, it adds the data to the map.\n// Line 11-14: This line defines the dataset property on the element with the value of the map, and makes it writable and enumerable. \n// Line 15: This returns the map of data-* attributes.',
    useCase:
      "\n\nElement.prototype.dataset is used to allow developers to store custom data on DOM elements. It provides a simple way to access and manipulate that data, making it easier to create dynamic webpages and applications. This feature is especially useful when working with HTML5 data attributes, as it allows developers to store and access custom data in a structured way.",
  },
  {
    code: "\n\nif (!Element.prototype.getAttributeNames) {\n    Element.prototype.getAttributeNames = function () {\n        let attrs = [];\n        for (let i = 0; i < this.attributes.length; i++) {\n            attrs.push(this.attributes[i].name);\n        }\n        return attrs;\n    };\n}",
    term: "Element.prototype.getAttributeNames",
    explain:
      "\n\n// Line 1: This line checks if the Element prototype doesn't already have a getAttributeNames() function. \n// If it doesn't, the code inside the if statement will be executed.\n\n// Line 2: This line defines a new function called getAttributeNames() that will be added to the Element prototype. \n\n// Line 3: This line declares an empty array called attrs that will be used to store the names of the element's attributes.\n\n// Line 4: This line uses a for loop to loop through all of the element's attributes.\n\n// Line 5: This line adds the name of the current attribute to the attrs array.\n\n// Line 6: This line returns the attrs array when the loop is finished.\n\n// Line 7: This line closes the if statement.",
    useCase:
      "\n\nElement.prototype.getAttributeNames is used in JavaScript to retrieve a list of all the attribute names of an element. This is useful for finding out what attributes are available for a particular element, as well as for iterating through the list and retrieving each attribute's value. It can also be used to check whether a specific attribute is present on an element or not.",
  },
  {
    code: "\n\n/**\n * Polyfill for Element.prototype.inert\n */\n(() => {\n  if ('inert' in Object.getOwnPropertyDescriptors(Element.prototype)) {\n    return;\n  }\n\n  /**\n   * Sets the Inert property of the HTMLElement\n   */\n  Object.defineProperty(Element.prototype, 'inert', {\n    enumerable: true,\n    configurable: true,\n    get() {\n      return this.hasAttribute('inert');\n    },\n    set(val) {\n      if (val) {\n        this.setAttribute('inert', '');\n      } else {\n        this.removeAttribute('inert');\n      }\n    }\n  });\n})();",
    term: "Element.prototype.inert",
    explain:
      "\n\n// Line 1: This line declares a function that is immediately invoked. This is a polyfill for Element.prototype.inert, which is used to enable or disable the ability of an element to be interacted with.\n\n// Line 4: This line checks if the 'inert' property already exists in the Element.prototype object. If it does, the function returns and does nothing.\n\n// Line 9: This line uses the Object.defineProperty() method to define the 'inert' property on the Element.prototype object. \n\n// Line 10: This line sets the enumerability of the 'inert' property to true.\n\n// Line 11: This line sets the configurability of the 'inert' property to true.\n\n// Line 12: This line defines a getter method for the 'inert' property. This getter method checks if the element has an 'inert' attribute.\n\n// Line 16: This line defines a setter method for the 'inert' property. This setter method adds or removes the 'inert' attribute depending on the value passed to the property.",
    useCase:
      "\n\nElement.prototype.inert is used to make an element on a web page unresponsive to user input, such as mouse clicks, keystrokes, or focus. This can be useful for creating UI elements that are not meant to be interacted with, or for making certain elements inaccessible under certain circumstances.",
  },
  {
    code: "\n\nif (!Element.prototype.matches) {\n\tElement.prototype.matches = \n\t\tElement.prototype.matchesSelector || \n\t\tElement.prototype.mozMatchesSelector ||\n\t\tElement.prototype.msMatchesSelector || \n\t\tElement.prototype.oMatchesSelector || \n\t\tElement.prototype.webkitMatchesSelector ||\n\t\tfunction(s) {\n\t\t\tvar matches = (this.document || this.ownerDocument).querySelectorAll(s);\n\t\t\tvar i = matches.length;\n\t\t\twhile (--i >= 0 && matches.item(i) !== this) {}\n\t\t\treturn i > -1;            \n\t\t};\n}",
    term: "Element.prototype.matches",
    explain:
      "\n\n//If the Element.prototype object does not have a 'matches' property\n// then add the 'matches' property to the Element.prototype \n//and assign it a function that checks if the Element matches \n//one of the other Element prototype properties (matchesSelector, mozMatchesSelector, msMatchesSelector, oMatchesSelector, or webkitMatchesSelector)\n//If none of the other Element prototype properties match the specified selector, \n//query the document or the ownerDocument for any elements matching the selector \n// and check if the Element matches the queried elements. \n//If the Element does match one of the queried elements, return true, otherwise return false.",
    useCase:
      "\n\nElement.prototype.matches is used in Javascript to determine if an element matches a selector. This is especially useful when trying to identify if a particular element matches a given selector without having to manually check each of its attributes. It is also useful for finding elements within a given document that match a certain selector.",
  },
  {
    code: "\n\nif (!Element.prototype.nextElementSibling) {\n    Element.prototype.nextElementSibling = function() {\n        let currentElement = this;\n        do {\n            currentElement = currentElement.nextSibling;\n        } while (currentElement && currentElement.nodeType !== 1);\n        return currentElement;\n    }\n}",
    term: "Element.prototype.nextElementSibling",
    explain:
      "\n\n// if (!Element.prototype.nextElementSibling): This line checks to see if the nextElementSibling property already exists on the Element prototype.\n\n// Element.prototype.nextElementSibling = function(): If the property does not already exist, this line defines a new function named nextElementSibling on the Element prototype.\n\n// let currentElement = this: This line creates a local variable named currentElement and sets it equal to the current element.\n\n// do { currentElement = currentElement.nextSibling: This line runs a loop that assigns the value of the nextSibling property of the currentElement to the currentElement variable.\n\n// } while (currentElement && currentElement.nodeType !== 1): This line checks the condition that the currentElement is not null and the nodeType of the currentElement is not equal to 1.\n\n// return currentElement: This line returns the value of the currentElement variable.",
    useCase:
      "\n\nElement.prototype.nextElementSibling is used to access the next element sibling of the given element. This is useful for traversing the DOM and manipulating siblings. It can be used to add or remove classes, or insert and delete elements from sibling elements. It also makes it easier to select and manipulate elements in a parent element.",
  },
  {
    code: '\n\n// Create a placeholder property for Element prototype\nElement.prototype.placeholder = {};\n\n// Create a getter for placeholder property\nObject.defineProperty(Element.prototype, "placeholder", {\n  get: function() {\n    // Get placeholder value from element\'s data-placeholder attribute\n    var attrPlaceholder = this.getAttribute("data-placeholder");\n\n    // If data-placeholder attribute is present, return its value\n    if (attrPlaceholder) {\n      return attrPlaceholder;\n    }\n\n    // Otherwise, return empty string\n    return "";\n  },\n  // Make placeholder property read-only\n  configurable: false\n});',
    term: "Element.prototype.placeholder",
    explain:
      "\n\n// This code creates a placeholder property on the Element prototype, which is the base prototype for all HTML elements. It creates a getter for this property which retrieves the value of the element's data-placeholder attribute. If the data-placeholder attribute is present, its value is returned, otherwise an empty string is returned. Finally, the placeholder property is made read-only.",
    useCase:
      "\n\nElement.prototype.placeholder is used to set or return the value of the placeholder attribute of an element. It allows developers to set a predefined value in an input field, which can then be replaced with user input when the field is interacted with. This can be useful for prompting users to enter information in the correct format, such as a phone number or email address.",
  },
  {
    code: "\n\nif (!Element.prototype.prepend) {\n  Element.prototype.prepend = function(el) {\n    let firstChild = this.firstChild;\n    this.insertBefore(el, firstChild);\n  };\n}",
    term: "Element.prototype.prepend",
    explain:
      '\n\n//Line 1: This line checks to see if the Element.prototype object already has a method called "prepend". If it does not, the code block that follows will execute.\n\n//Line 2: A new function is added as a method to Element.prototype called "prepend". The argument "el" will be used when this method is called.\n\n//Line 3: A variable called "firstChild" is declared, and is assigned the value of the first child of the element that calls this method.\n\n//Line 4: The method "insertBefore" is called on the element that calls the "prepend" method. This method takes two arguments, the first being the element to be inserted and the second being the element that it should be inserted before. In this case, the "el" argument passed to the "prepend" method is inserted before the "firstChild" variable.',
    useCase:
      "\n\nElement.prototype.prepend is used in Javascript to insert a node as the first child of a specified element. This is useful for adding new elements to the beginning of a page or rearranging existing elements. It is also useful for adding text to existing elements, as it allows text to be added to the beginning of an element instead of only at the end.",
  },
  {
    code: "\n\nif (!Object.prototype.hasOwnProperty.call(Element.prototype, 'previousElementSibling')) {\n    Object.defineProperty(Element.prototype, 'previousElementSibling', {\n        get() {\n            let currentNode = this.previousSibling;\n            do {\n                if (currentNode.nodeType === 1) {\n                    return currentNode;\n                }\n                currentNode = currentNode.previousSibling;\n            }\n            while (currentNode);\n        }\n    });\n}",
    term: "Element.prototype.previousElementSibling",
    explain:
      "\n\n//Line 1: This line checks if the Object prototype does not have a property called 'previousElementSibling'. \n//Line 2: If it does not, then the Object.defineProperty method is used to define a new property on the Element prototype object called 'previousElementSibling' and set it as a getter.\n//Line 3: This line sets the currentNode variable to the previousSibling of the element.\n//Line 4: This line is a do-while loop that will run until the currentNode variable is falsey.\n//Line 5: This line checks if the nodeType of the currentNode is equal to 1. If it is, then it will return the currentNode.\n//Line 6: This line sets the currentNode variable to the previousSibling of the currentNode.\n//Line 7: This line closes the do-while loop. \n//Line 8: This line closes the Object.defineProperty method.\n//Line 9: This line closes the if statement.",
    useCase:
      "\n\nElement.prototype.previousElementSibling is used to access the element that immediately precedes the specified element in the same tree level. It is useful for manipulating the DOM, as it allows developers to quickly traverse the DOM tree and manipulate elements in a specific order.",
  },
  {
    code: "\n\nif (!Element.prototype.remove) {\n  Element.prototype.remove = function() {\n    if (this.parentElement) {\n      this.parentElement.removeChild(this);\n    }\n  };\n}",
    term: "Element.prototype.remove",
    explain:
      "\n\n// Line 1: This line checks to see if the Element prototype object does not have the remove method. \n// Line 2: If the Element prototype object does not have the remove method, this line adds a remove method to the Element prototype object. \n// Line 3: This line checks to see if the element has a parent element.\n// Line 4: If the element does have a parent element, this line removes the element from its parent element.",
    useCase:
      "\n\nElement.prototype.remove is used in Javascript to remove an element from the DOM (Document Object Model). It is a convenient way to remove elements from the DOM without having to search for them using other methods such as querySelector or getElementById.",
  },
  {
    code: "\n\nif (!Element.prototype.replaceWith) {\n  Element.prototype.replaceWith = function(newNode) {\n    this.parentNode.replaceChild(newNode, this);\n  };\n}",
    term: "Element.prototype.replaceWith",
    explain:
      "\n\n// Line 1: This line checks if the Element prototype already has a replaceWith function.\n// Line 2: If the Element prototype does not have a replaceWith function, a new one is created.\n// Line 3: This line defines the new replaceWith function created. It takes one argument, newNode, and replaces the current element with the newNode.\n// Line 4: This line calls the replaceChild function on the parentNode of the current element, and passes in the newNode and the current element as arguments.",
    useCase:
      "\n\nElement.prototype.replaceWith is used in Javascript to replace an element in the DOM with a new element. This is often used to update the content of a page without having to reload the entire page. It can also be used to replace an element in the DOM with an entirely different type of element, making it a powerful tool for transforming a page on the fly.",
  },
  {
    code: "\n\n//Create a polyfill of Element.prototype.scroll\nif (Element.prototype.scroll === undefined) {\n    Element.prototype.scroll = function(x, y) {\n        //Check that x and y are valid numbers\n        if (typeof x === 'number' && typeof y === 'number') {\n            if (this.nodeType === 1) {\n                this.scrollLeft = x;\n                this.scrollTop = y;\n            }\n        }\n    };\n}",
    term: "Element.prototype.scroll",
    explain:
      "\n\n//Line 1: \n//This line creates a polyfill of Element.prototype.scroll. A polyfill is a piece of code that provides the technology that is missing from the browser.\n\n//Line 2: \n//This line checks whether Element.prototype.scroll is undefined. If it is, then the code within the if statement is executed.\n\n//Line 3: \n//This line creates a new function called scroll, which takes two parameters, x and y.\n\n//Line 4: \n//This line checks whether the parameters x and y are valid numbers. If they are, then the code within the if statement is executed.\n\n//Line 5: \n//This line checks whether the element is a node type 1. If it is, then the code within the if statement is executed.\n\n//Line 6 & 7: \n//These lines set the scrollLeft and scrollTop properties of the element to the values of x and y, respectively.",
    useCase:
      "\n\nElement.prototype.scroll is used in Javascript to scroll the content of an element horizontally or vertically. This method can be used to quickly scroll an element to the top, bottom, left, or right of its scrollable area. Additionally, it can be used to scroll an element to a specific position or to scroll an element by a certain amount. This method is useful for creating smooth scrolling effects or for quickly adjusting the scroll position of an element.",
  },
  {
    code: "\n\nif (!Element.prototype.scrollBy) {\n  Element.prototype.scrollBy = function(x, y) {\n    this.scrollLeft += x;\n    this.scrollTop += y;\n  };\n}",
    term: "Element.prototype.scrollBy",
    explain:
      "\n\n// Line 1: This checks to see if the scrollBy method is already defined on the Element prototype. If not, the code inside the if statement will be executed.\n\n// Line 2: This defines a scrollBy method on the Element prototype.\n\n// Line 3: This sets the scrollLeft property of the element to what it was before plus the value of x.\n\n// Line 4: This sets the scrollTop property of the element to what it was before plus the value of y.",
    useCase:
      "\n\nElement.prototype.scrollBy is used in JavaScript to scroll an element by a specified number of pixels. It can be used to scroll the page by a certain number of pixels, or to scroll a particular element by a certain number of pixels. It can be used to create smooth scrolling animations or to automatically scroll an element into view. It can also be used to scroll an element to the top or bottom of its scrollable area.",
  },
  {
    code: "\n\nif (!Element.prototype.scrollIntoView) {\n  // Get the top-level document object\n  var d = window.document;\n  // determine the current scroll position\n  function scrollY() {\n    var y;\n    if (window.pageYOffset) y = window.pageYOffset;\n    else if (d.documentElement && d.documentElement.scrollTop) y = d.documentElement.scrollTop;\n    else if (d.body) y = d.body.scrollTop;\n    return y;\n  }\n  // determine the current horizontal scroll position\n  function scrollX() {\n    var x;\n    if (window.pageXOffset) x = window.pageXOffset;\n    else if (d.documentElement && d.documentElement.scrollLeft) x = d.documentElement.scrollLeft;\n    else if (d.body) x = d.body.scrollLeft;\n    return x;\n  }\n  // Scroll the document\n  Element.prototype.scrollIntoView = function(){\n    // the element's bounding rectangle\n    var rect = this.getBoundingClientRect();\n    // the base scroll position\n    var sx = scrollX();\n    var sy = scrollY();\n    // the current viewport size\n    var vw = window.innerWidth;\n    var vh = window.innerHeight;\n    // the element's size, relative to the viewport\n    var tw = rect.width;\n    var th = rect.height;\n    // the calculated target scroll position\n    var tx = sx + rect.left;\n    var ty = sy + rect.top;\n    // the threshold for when the element should be aligned to the top of the viewport\n    var thresh = th - vh;\n    // adjust the target scroll position if necessary\n    if (ty > sy + thresh) ty = sy + thresh;\n    if (tx + tw > sx + vw) tx = sx + vw - tw;\n    // scroll the element into view\n    window.scrollTo(tx, ty);\n  };\n}",
    term: "Element.prototype.scrollIntoView",
    explain:
      "\n\n//Line 1: This line checks if the scrollIntoView prototype method exists on the Element object. If it does not exist, it will create the method. \n//Line 2: This line stores the top-level document object in the d variable.\n//Line 3: This line creates a function that determines the current vertical scroll position. \n//Line 4: This line checks if the pageYOffset property of the window object is set. If it is, it stores the value in the y variable.\n//Line 5: This line checks if the documentElement property of the document object is set and if the scrollTop property of the documentElement is set. If both are set, it stores the value in the y variable.\n//Line 6: This line checks if the body property of the document object is set. If it is, it stores the value in the y variable.\n//Line 7: This line returns the value stored in the y variable.\n//Line 8: This line creates a function that determines the current horizontal scroll position. \n//Line 9: This line checks if the pageXOffset property of the window object is set. If it is, it stores the value in the x variable.\n//Line 10: This line checks if the documentElement property of the document object is set and if the scrollLeft property of the documentElement is set. If both are set, it stores the value in the x variable.\n//Line 11: This line checks if the body property of the document object is set. If it is, it stores the value in the x variable.\n//Line 12: This line returns the value stored in the x variable.\n//Line 13: This line creates the scrollIntoView method on the Element prototype.\n//Line 14: This line stores the bounding rectangle of the element in the rect variable.\n//Line 15: This line stores the current horizontal scroll position in the sx variable.\n//Line 16: This line stores the current vertical scroll position in the sy variable.\n//Line 17: This line stores the width of the current viewport in the vw variable.\n//Line 18: This line stores the height of the current viewport in the vh variable.\n//Line 19: This line stores the width of the element, relative to the viewport, in the tw variable.\n//Line 20: This line stores the height of the element, relative to the viewport, in the th variable.\n//Line 21: This line stores the calculated target scroll position in the tx variable.\n//Line 22: This line stores the calculated target scroll position in the ty variable.\n//Line 23: This line stores the threshold for when the element should be aligned to the top of the viewport in the thresh variable.\n//Line 24: This line checks if the ty variable is greater than the sy variable plus the thresh variable. If it is, it sets the ty variable to the sy variable plus the thresh variable.\n//Line 25: This line checks if the tx variable plus the tw variable is greater than the sx variable plus the vw variable. If it is, it sets the tx variable to the sx variable plus the vw variable minus the tw variable.\n//Line 26: This line scrolls the element into view by calling the window.scrollTo() method with the tx and ty variables as arguments.",
    useCase:
      "\n\nElement.prototype.scrollIntoView is used in JavaScript to bring the element into the visible area of the browser window. It is a useful method when you want to ensure that a particular element is visible on the page, and can be used to scroll the element into the viewport when it is not currently visible. It can also be used in combination with other JavaScript functions to create a smooth scrolling effect.",
  },
  {
    code: "\n\nif(!Element.prototype.toggleAttribute) {\n  Element.prototype.toggleAttribute = function (name, force){\n    var val = this.getAttribute(name);\n    if(force === undefined) {\n      if (val === null){\n        this.setAttribute(name, '');\n        return true;\n      } else {\n        this.removeAttribute(name);\n        return false;\n      }\n    } else if (force) {\n      this.setAttribute(name, '');\n      return true;\n    } else {\n      this.removeAttribute(name);\n      return false;\n    }\n  };\n}",
    term: "Element.prototype.toggleAttribute",
    explain:
      "\n\n//Line 1: \n// This line checks if the Element.prototype.toggleAttribute function has been defined. \n\n//Line 2: \n// If the function has not been defined, the function is defined in the following lines.\n\n//Line 3: \n// This line creates a variable called 'val' that stores the value of the attribute with the name passed in as an argument.\n\n//Line 4: \n// This line checks if no 'force' argument was passed in. \n\n//Line 5: \n// If no 'force' argument was passed in, and the value of the attribute was null, then the attribute is set to an empty string and the function returns true.\n\n//Line 6: \n// If no 'force' argument was passed in, and the value of the attribute was not null, then the attribute is removed and the function returns false.\n\n//Line 7: \n// If a 'force' argument was passed in, and it is true, then the attribute is set to an empty string and the function returns true.\n\n//Line 8: \n// If a 'force' argument was passed in, and it is false, then the attribute is removed and the function returns false.",
    useCase:
      "\n\nElement.prototype.toggleAttribute is used in Javascript to enable an element to be toggled between two states. This method allows developers to quickly and easily switch an element between two states without having to manually set each state. By using toggleAttribute, developers can create a one-click toggle for elements, such as a checkbox or a switch. This method is particularly useful when creating complex user interfaces, as it makes it easier to quickly toggle between two different states.",
  },
  {
    code: "\n\n// Polyfill for Event in Javascript\nif (!window.Event) {\n  function Event(event, params) {\n    params = params || { bubbles: false, cancelable: false, detail: null };\n    const evt = document.createEvent('Event');\n    evt.initEvent(event, params.bubbles, params.cancelable, params.detail);\n    return evt;\n  }\n  window.Event = Event;\n}",
    term: "Event",
    explain:
      "\n\n//This line of code checks if the window object has an Event property. If it does not, then it creates a custom Event function. \nif (!window.Event) {\n\n//This line of code defines the Event function and gives it two parameters, event and params. The params parameter is optional and allows for additional parameters such as bubbling and cancelable. \n  function Event(event, params) {\n\n//This line of code sets the default values for the params parameter.\n    params = params || { bubbles: false, cancelable: false, detail: null };\n\n//This line of code creates a new event object.\n    const evt = document.createEvent('Event');\n\n//This line of code initializes the event object with the provided parameters.\n    evt.initEvent(event, params.bubbles, params.cancelable, params.detail);\n\n//This line of code returns the newly created event.\n    return evt;\n  }\n\n//This line of code assigns the Event function to the window object.\n  window.Event = Event;\n}",
    useCase:
      "\n\nEvent is used in Javascript to allow code to be executed when certain types of events occur in the browser window, such as when a user clicks a button, scrolls the page, or moves the mouse over an element. By using Event, developers can create interactive web applications that respond to user actions.",
  },
  {
    code: '\n\nif (!("focusin" in Event.prototype)) {\n  Object.defineProperty(Event.prototype, "focusin", {\n    configurable: true,\n    enumerable: true,\n    get() {\n      return this._focusin || (this.type === "focusin");\n    },\n    set(value) {\n      Object.defineProperty(this, "_focusin", { value });\n    },\n  });\n}',
    term: "Event.focusin",
    explain:
      '\n\n// Line 1: \n// This line checks if "focusin" is not a property of Event.prototype. \n\n// Line 2: \n// This line defines a new property "focusin" on the Event.prototype object.\n\n// Line 3-7: \n// These lines set the configurable, enumerable, get, and set functions for the "focusin" property. The get function checks if the type property of the event is equal to "focusin". The set function sets the value of the _focusin property.',
    useCase:
      "\n\nEvent.focusin is used in Javascript to detect when an element receives focus. This event is typically used to trigger an action when the user focuses on a specific form element or other interactive element on a page. It can be used to customize the user experience by delaying or preventing certain actions until a user is focused on a specific element.",
  },
  {
    code: "\n\n(function () {\n  let hash = window.location.hash;\n  if (hash === '') {\n    hash = '#';\n  }\n  const oldHash = hash;\n  \n  let delay = 250;\n  let pollingInterval;\n  \n  window.onhashchange = function (e) {\n    if (oldHash !== e.newURL.split('#')[1]) {\n      let event = new Event('hashchange');\n      event.oldURL = oldHash;\n      event.newURL = e.newURL;\n      window.dispatchEvent(event);\n    }\n    oldHash = e.newURL.split('#')[1];\n  };\n  \n  const pollHash = function () {\n    if (window.location.hash !== hash) {\n      hash = window.location.hash;\n      window.onhashchange({\n        newURL: window.location.href\n      });\n    }\n  };\n  \n  pollHash();\n  pollingInterval = window.setInterval(pollHash, delay);\n  \n  if (typeof window.addEventListener === 'function') {\n    window.addEventListener('beforeunload', function () {\n      window.clearInterval(pollingInterval);\n    }, false);\n  }\n  \n})();",
    term: "Event.hashchange",
    explain:
      "\n\n//(function () {\n//  Creates an anonymous function \n\n//  let hash = window.location.hash;\n//  Sets the variable 'hash' to the current window location hash\n\n//  if (hash === '') {\n//    hash = '#';\n//  }\n//  Checks if the variable 'hash' is empty, if it is sets it to '#'\n\n//  const oldHash = hash;\n//  Sets the constant variable 'oldHash' to the value of 'hash'\n\n//  let delay = 250;\n//  let pollingInterval;\n//  Sets the variable 'delay' to 250 and creates an empty variable 'pollingInterval'\n\n//  window.onhashchange = function (e) {\n//    if (oldHash !== e.newURL.split('#')[1]) {\n//      let event = new Event('hashchange');\n//      event.oldURL = oldHash;\n//      event.newURL = e.newURL;\n//      window.dispatchEvent(event);\n//    }\n//    oldHash = e.newURL.split('#')[1];\n//  };\n//  Creates an event listener for when the hash is changed, checks to see if the old hash is different, if it is creates a new event called 'hashchange' and sets the oldURL and newURL to the old and new hash respectively.\n\n//  const pollHash = function () {\n//    if (window.location.hash !== hash) {\n//      hash = window.location.hash;\n//      window.onhashchange({\n//        newURL: window.location.href\n//      });\n//    }\n//  };\n//  Creates a function to poll the hash, checks to see if the window location hash is different from the hash variable, if it is sets the hash variable to the new window location hash and calls the onhashchange event listener.\n\n//  pollHash();\n//  pollingInterval = window.setInterval(pollHash, delay);\n//  Calls the pollHash function and sets the pollingInterval to call the pollHash function every 250 milliseconds.\n\n//  if (typeof window.addEventListener === 'function') {\n//    window.addEventListener('beforeunload', function () {\n//      window.clearInterval(pollingInterval);\n//    }, false);\n//  }\n//  Checks if the window has an addEventListener function, if it does sets an event listener for beforeunload and clears the pollingInterval\n\n//})();\n//End of the anonymous function",
    useCase:
      "\n\nEvent.hashchange is used in Javascript to detect changes to the part of a url that follows the # symbol. This can be used to detect when the user navigates to a different page within a single-page application, or when the user changes the parameters of the page, such as when a user changes the sorting of a list. It can also be used to detect when the user has manually changed the url hash.",
  },
  {
    code: "\n\n(function() {\n    function EventSource(url) {\n        this.url = url;\n        this.readyState = 0;\n        this.onopen = function(){};\n        this.onmessage = function() {};\n        this.onerror = function() {};\n        this.poll();\n    }\n    \n    EventSource.prototype.CONNECTING = 0;\n    EventSource.prototype.OPEN = 1;\n    EventSource.prototype.CLOSED = 2;\n    \n    EventSource.prototype.poll = function() {\n        var self = this;\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', this.url);\n        xhr.onreadystatechange = function() {\n            if (this.readyState === 4 && this.status === 200) {\n                self.readyState = self.OPEN;\n                self.onopen();\n                self.onmessage({\n                    data: this.responseText\n                });\n            }\n            else {\n                self.onerror();\n            }\n        };\n        xhr.send();\n    };\n    \n    window.EventSource = EventSource;\n})();",
    term: "EventSource",
    explain:
      "\n\n// (function(){}) is an immediately invoked function expression (IIFE), which is used to create a new scope in which variables declared inside of it are not visible outside of it.\n\n// function EventSource(url) { ... } is a function constructor which is used to create EventSource objects with a specific URL.\n\n// this.url = url; is a property which assigns the URL passed as an argument to the instance of the EventSource object.\n\n// this.readyState = 0; is a property which initializes the readyState property with 0.\n\n// this.onopen = function(){}; is a property which sets the onopen property to a function that does nothing.\n\n// this.onmessage = function() {}; is a property which sets the onmessage property to a function that does nothing.\n\n// this.onerror = function() {}; is a property which sets the onerror property to a function that does nothing.\n\n// this.poll(); is a method which is called immediately after the EventSource object is created.\n\n// EventSource.prototype.CONNECTING = 0; is a prototype property of the EventSource constructor which assigns the CONNECTING constant a value of 0.\n\n// EventSource.prototype.OPEN = 1; is a prototype property of the EventSource constructor which assigns the OPEN constant a value of 1.\n\n// EventSource.prototype.CLOSED = 2; is a prototype property of the EventSource constructor which assigns the CLOSED constant a value of 2.\n\n// EventSource.prototype.poll = function() { ... }; is a prototype method of the EventSource constructor which is used to poll the server for any new data.\n\n// window.EventSource = EventSource; is used to set the EventSource constructor as a global object in the window object.",
    useCase:
      "?\n\nEventSource is used in Javascript as a way to enable server-sent events (SSEs). This allows for a real-time connection between the client and server so that the server can push data to the client without the client having to request it. This can be used for notifications, updates, or even streaming data.",
  },
  {
    code: "\n\nconst Float32ArrayPolyfill = (function() {\n\n  return {\n    from(arrayLike) {\n      if (!arrayLike.length) return new Float32Array(0);\n      const array = new Float32Array(arrayLike.length);\n\n      for (let i = 0; i < array.length; i++) {\n        array[i] = arrayLike[i];\n      }\n\n      return array;\n    },\n    of(...items) {\n      return new Float32Array(items);\n    }\n  };\n})();",
    term: "Float32Array",
    explain:
      "\n\n//1. const Float32ArrayPolyfill = (function() {\n//this line declares a constant variable named Float32ArrayPolyfill and sets it equal to an anonymous function.\n\n//2. return {\n//this line returns an object literal\n\n//3. from(arrayLike) {\n//this line declares the from method which accepts an arrayLike argument\n\n//4. if (!arrayLike.length) return new Float32Array(0);\n// this line checks to see if the arrayLike argument has a length of 0, if it does it will return a new Float32Array object with a length of 0\n\n//5. const array = new Float32Array(arrayLike.length);\n//this line declares a variable named array and sets it equal to a new Float32Array object with a length equal to the arrayLike argument's length\n\n//6. for (let i = 0; i < array.length; i++) {\n//this line declares a for loop which starts at 0 and iterates until it is less than the length of the array\n\n//7. array[i] = arrayLike[i];\n//this line sets the value of the array at index i equal to the value of the arrayLike argument at index i\n\n//8. return array;\n//this line returns the array\n\n//9. of(...items) {\n//this line declares the of method which accepts multiple items as arguments\n\n//10. return new Float32Array(items);\n//this line returns a new Float32Array object with the items passed in as arguments",
    useCase:
      "\n\nFloat32Array is used in Javascript because it stores data more efficiently than other data types. It is used to represent numbers that have a decimal point, such as 3.14159. Float32Array is also faster to read and write than other data types. It is especially useful when dealing with large amounts of data, such as 3D graphics or scientific calculations.",
  },
  {
    code: "\n\nif (!window.Float64Array) {\n  window.Float64Array = function Float64Array() {\n    // Create an empty array.\n    let array = new Array(arguments.length);\n\n    // Copy the arguments into the array.\n    for (let i = 0; i < arguments.length; i++) {\n      array[i] = arguments[i];\n    }\n\n    // Add the raw method.\n    array.BYTES_PER_ELEMENT = 8;\n    array.get = (index) => {\n      return array[index];\n    };\n    array.set = (index, value) => {\n      array[index] = value;\n    };\n    array.subarray = (begin, end) => {\n      return array.slice(begin, end);\n    };\n    array.buffer = () => {\n      return array;\n    };\n    array.length = () => {\n      return array.length;\n    };\n\n    return array;\n  };\n}",
    term: "Float64Array",
    explain:
      "\n\n// Line 1: This checks if window.Float64Array is not defined.\n// Line 2: If window.Float64Array is not defined, then a new function is created and assigned to window.Float64Array.\n// Line 3: An empty array is created.\n// Line 4: This loop is used to copy the arguments that are passed to the Float64Array function into the array.\n// Line 5: The BYTES_PER_ELEMENT property is set to 8.\n// Line 6: This is a function that gets the value at a specific index in the array.\n// Line 7: This is a function that sets the value at a specific index in the array.\n// Line 8: This is a function that gets a subarray of the array.\n// Line 9: This is a function that returns the array.\n// Line 10: This is a function that returns the length of the array.\n// Line 11: The array is returned.",
    useCase:
      "\n\nFloat64Array is used in Javascript because it allows for more precise calculations with decimal numbers than the regular Number type, which is limited to a precision of 16 decimal digits. Float64Array is also faster for certain operations than the regular Number type, which makes it a better choice for applications that require more precision or speed.",
  },
  {
    code: "\n\nif (!Object.hasOwnProperty(\"name\")) {\n  Object.defineProperty(Function.prototype, 'name', {\n    get: function () {\n      var matches = this.toString().match(/^\\s*function\\s*([^\\s(]+)/);\n      return matches ? matches[1] : '';\n    }\n  });\n}",
    term: "Function.name",
    explain:
      '\n\n// Line 1: \n// This line checks if the Object class has a property called "name". If not, it will execute the code block.\n\n// Line 2: \n// This line adds a new property called "name" to the Function prototype.\n\n// Line 3: \n// This line creates a getter method that checks the current function\'s toString() value and tries to match it to a regular expression pattern. If the pattern matches, it will return the matched value. Otherwise, it will return an empty string.',
    useCase:
      '\n\nFunction.name is used in Javascript to retrieve a function\'s name as a string. It is useful for debugging purposes, or when writing code that needs to be able to determine the name of a given function. This is especially important when working with anonymous functions, as the Function.name property will return the assigned name of the function, instead of a generic string such as "anonymous".',
  },
  {
    code: "\n\nif (!Function.prototype.bind) {\n  Function.prototype.bind = function(oThis) {\n    if (typeof this !== 'function') {\n      // closest thing possible to the ECMAScript 5\n      // internal IsCallable function\n      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n    }\n \n    var aArgs   = Array.prototype.slice.call(arguments, 1),\n        fToBind = this,\n        fNOP    = function() {},\n        fBound  = function() {\n          return fToBind.apply(this instanceof fNOP\n                 ? this\n                 : oThis,\n                 aArgs.concat(Array.prototype.slice.call(arguments)));\n        };\n \n    // fNOP.prototype = this.prototype;\n    fBound.prototype = new fNOP();\n \n    return fBound;\n  };\n}",
    term: "Function.prototype.bind",
    explain:
      "\n\n1.  if (!Function.prototype.bind) { // The if statement checks if the bind method is not present in the Function prototype\n\n2.  Function.prototype.bind = function(oThis) { // If the bind method is not present, it is added to the Function prototype\n\n3.  if (typeof this !== 'function') { // Checks if the function is not a function\n\n4.  throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable'); // If the function is not a function, throw a TypeError\n\n5.  var aArgs   = Array.prototype.slice.call(arguments, 1), // Create a variable aArgs and assign it the arguments passed to the function\n\n6.  fToBind = this, // Create a variable fToBind and assign it to the current function\n\n7.  fNOP    = function() {}, // Create a variable fNOP and assign it an empty function\n\n8.  fBound  = function() { // Create a variable fBound and assign it a function\n\n9.    return fToBind.apply(this instanceof fNOP // The function will return the result of the function fToBind applied to the arguments\n\n10.      ? this // If the condition is true, this will be assigned to the fToBind function\n\n11.      : oThis, // If the condition is false, the argument oThis will be assigned to the fToBind function\n\n12.      aArgs.concat(Array.prototype.slice.call(arguments))); // Concatenate the aArgs variable to the arguments\n\n13.  fBound.prototype = new fNOP(); // Assign the prototype of fBound to a new instance of fNOP\n\n14.  return fBound; // Return the function fBound",
    useCase:
      "\n\nFunction.prototype.bind is used in JavaScript to create a new function that, when called, has its this keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function is called. This allows for a more concise way of specifying a function to be called with a certain context and set of arguments.",
  },
  {
    code: '\n\n// define function if not defined\nif (!Function.prototype.hasOwnProperty("name")) {\n    Object.defineProperty(Function.prototype, "name", {\n        get: function(){\n            if("name" in this){\n                return this.name;\n            }\n            var match = this.toString().match(/^\\s*function\\s*([^(]*)\\(/);\n            return match && match[1].length > 0 ? match[1] : "";\n        }\n    })\n}',
    term: "Function.prototype.name",
    explain:
      '\n\n// Line 1: This line checks to see if the Function.prototype already has a "name" property. \n// Line 2: If it does not, then a new property is defined on the Function.prototype. \n// Line 3: The "name" property is a getter, so when it is accessed, a function is called. \n// Line 4: This line checks to see if the "name" property has already been set on the function. \n// Line 5: If it has, then the value of the "name" property is returned. \n// Line 6: If not, then a regex is used to try to extract the name of the function from the definition. \n// Line 7: If a name was extracted, then that is returned, otherwise an empty string is returned.',
    useCase:
      "\n\nFunction.prototype.name is used in Javascript to provide a way to access the name of a function. This is especially useful for debugging or logging purposes, as it allows developers to easily see what function is being called or referenced. It can also be used to help ensure that functions have been named correctly, as a missing or incorrect name can be easily spotted and corrected.",
  },
];
