export const DATA = [
  {
    code: "\n\nclass AbortController {\n  constructor() {\n    this.signal = new AbortSignal();\n  }\n \n  abort() {\n    this.signal.abort();\n  }\n}\nclass AbortSignal {\n  constructor(){\n    this.aborted = false;\n    this.onabort = null;\n  }\n \n  get aborted(){\n    return this.aborted;\n  }\n \n  set onabort(handler){\n    if (this.onabort) {\n      throw new DOMException('AbortSignal is already sending a signal', 'InvalidStateError');\n    }\n    this.onabort = handler;\n  }\n \n  toString(){\n    return '[object AbortSignal]';\n  }\n \n  abort(){\n    if (this.onabort) {\n      this.onabort();\n    }\n    this.aborted = true;\n  }\n}",
    term: "AbortController",
    explain:
      "\n\n// 1. class AbortController { - This line creates the AbortController class, which is used to handle the aborting of a network request. \n// 2. constructor() { - This line is the constructor method for this class, which is used to initialize an instance of AbortController.\n// 3. this.signal = new AbortSignal(); - This line creates a new instance of the AbortSignal class and assigns it to the signal property of the AbortController instance.\n// 4. abort() { - This line creates a method on the AbortController class that allows for aborting the network request.\n// 5. class AbortSignal { - This line creates the AbortSignal class, which is used to handle the aborting of a network request.\n// 6. constructor(){ - This line is the constructor method for this class, which is used to initialize an instance of AbortSignal.\n// 7. this.aborted = false; - This line sets the aborted property of the AbortSignal instance to false.\n// 8. this.onabort = null; - This line sets the onabort property of the AbortSignal instance to null.\n// 9. get aborted(){ - This line creates a method on the AbortSignal class that allows for getting the aborted state of the instance.\n// 10. set onabort(handler){ - This line creates a method on the AbortSignal class that allows for setting the onabort handler.\n// 11. toString(){ - This line creates a method on the AbortSignal class that allows for getting the string representation of the instance.\n// 12. abort(){ - This line creates a method on the AbortSignal class that allows for aborting the network request.",
    useCase:
      "\n\nAbortController is used in JavaScript to allow for the cancellation of a request. This is useful for requests that take a long time to complete, such as lengthy API calls. The AbortController provides developers with a way to cancel the request before it completes, freeing up resources and preventing potential errors. Additionally, AbortController can be used to abort any fetch request, even if the API endpoint does not natively support aborting requests.",
  },
  {
    code: "\n\nclass AggregateError extends Error { \n\n  constructor(errors) {\n    if (Array.isArray(errors)) {\n      const message = errors.length > 1 ?\n        `${errors.length} errors occurred` :\n        `An error occurred`;\n      super(message);\n      this.name = 'AggregateError';\n      this.errors = errors;\n    } else {\n      throw new TypeError(`Argument 1 of AggregateError must be an Array`);\n    }\n  }\n}",
    term: "AggregateError",
    explain:
      '\n\n// Line 1: This line creates a class called AggregateError that extends the Error class. This allows us to create objects which inherit the properties and methods of the Error class. \n// Line 2: This line creates a constructor function for the AggregateError class which takes in an array of errors as an argument. \n// Line 3: This line checks if the argument passed into the constructor is an array. \n// Line 4: This line creates a message which will be displayed when the AggregateError object is created. The message will either say "An error occurred" if there is one error, or "X errors occurred" if there are multiple errors.\n// Line 5: This line calls the super() method and passes the created message as an argument. This will set the message property of the AggregateError object to the created message. \n// Line 6: This line sets the name property of the AggregateError object to "AggregateError".\n// Line 7: This line sets the errors property of the AggregateError object to the array of errors passed into the constructor. \n// Line 8: This line throws an error if the argument passed into the constructor is not an array.',
    useCase:
      "\n\nAggregateError is used in JavaScript to provide a single unified type for a variety of errors that may occur in a program. This allows developers to have a consistent way of dealing with errors, regardless of the type of error that occurs. It also allows for a more organized approach to error handling, as developers can catch a single error type and act accordingly, rather than having to consider each type of error separately.",
  },
  {
    code: "\n\nif (!Array.from) {\n  Array.from = function(object) {\n    return [].slice.call(object);\n  };\n}",
    term: "Array.from",
    explain:
      "\n\n// This code checks if the Array.from method is not defined, meaning that the current environment does not support it.\n// If Array.from is not defined, then this code defines it as a function that takes in one parameter, 'object'.\n// The Array.from function will then call the slice method on the array prototype and pass in the 'object' parameter as an argument. \n// This will return a new array with the elements from the passed in 'object' parameter.",
    useCase:
      "\n\nArray.from is used in JavaScript to create a new, shallow-copied Array instance from an array-like or iterable object. It allows you to convert array-like objects, such as arguments objects, NodeList, and other array-like objects into true JavaScript arrays. This is useful when you want to use array methods, such as map, reduce, filter, etc., on an array-like object.",
  },
  {
    code: '\n\nconst ArrayisArray = (arg) => {\n  if (Object.prototype.toString.call(arg) === "[object Array]") {\n    return true;\n  } else {\n    return false;\n  }\n};',
    term: "Array.isArray",
    explain:
      "\n\n// Line 1: This line is declaring a constant variable named 'ArrayisArray' and assigning it with an anonymous function. This function takes one argument named 'arg'. \n// Line 2: This line is using the 'Object.prototype.toString.call' method to convert the 'arg' argument to a string and comparing it to the string value '[object Array]'. \n// Line 3: This line is returning the boolean value 'true' if the comparison in line 2 is true.\n// Line 4: This line is returning the boolean value 'false' if the comparison in line 2 is false.",
    useCase:
      "\n\nArray.isArray is used in JavaScript to determine whether a given value is an array or not. This is useful for checking the data type of a variable before performing operations on it. It is a reliable way to ensure that the data type of a variable is an array and that operations such as iteration and mapping can be performed on it.",
  },
  {
    code: "\n\nif (!Array.of) {\n  Array.of = function() {\n    return Array.prototype.slice.call(arguments);\n  };\n}",
    term: "Array.of",
    explain:
      "\n\n/*\nLine 1: If the Array.of method does not exist,\nReason: This checks to see if the Array.of method already exists, and if not, it will proceed to create it.\n\nLine 2: Array.of = function() {\nReason: This creates the function that will be assigned to the Array.of method.\n\nLine 3: return Array.prototype.slice.call(arguments);\nReason: This returns the arguments passed into the function as an array using the Array.prototype.slice.call method. This allows the Array.of method to take any number of arguments and returns them as an array.",
    useCase:
      "\n\nArray.of is used in JavaScript to create a new Array instance from a variable number of arguments. It allows developers to create an Array instance with a single argument, or with multiple arguments. It also provides an easy way to create an array from a non-array type, such as a string or number.",
  },
  {
    code: "\n\nif (!Array.prototype.hasOwnProperty('@@iterator')) {\n    Object.defineProperty(Array.prototype, '@@iterator', {\n        value: function() {\n            let index = 0;\n\n            return {\n                next: () => {\n                    if (index < this.length) {\n                        return {\n                            value: this[index++],\n                            done: false\n                        };\n                    } else {\n                        return {\n                            value: undefined,\n                            done: true\n                        };\n                    }\n                }\n            }\n        }\n    });\n}",
    term: "Array.prototype.@@iterator",
    explain:
      '\n\n//Line 1:\n//This line checks if the Array prototype does not have a property named "@@iterator".\n\n//Line 2:\n//If the condition is true, then this line uses Object.defineProperty() to define a new property with the specified name and value on the Array prototype.\n\n//Line 3:\n//This line creates a variable called "index" and sets its value to 0.\n\n//Line 4-11:\n//This block defines an iterator which returns the next item in the array when called. It returns an object with two properties: "value" which is the value of the next item in the array and "done" which is a boolean value which is true if the end of the array has been reached. \n\n//Line 12:\n//This line closes the if block from line 2.',
    useCase:
      "\n\nArray.prototype.@@iterator is used in Javascript to create an iterable object for the array. This allows developers to use the iterator protocol to easily loop through the array and access each element in the array. The iterator protocol is a standard way of providing a way to iterate through a collection of data, such as an array. This makes it simple to loop through the array and access each element without having to write custom code.",
  },
  {
    code: "\n\nif (!Array.prototype.at) {\n  Array.prototype.at = function (index) {\n    const length = this.length;\n    if (index >= length || index < 0) {\n      return undefined;\n    }\n\n    return this[index];\n  };\n}",
    term: "Array.prototype.at",
    explain:
      "\n\n// Line 1: This line checks if the array prototype at() method exists. If not, it will proceed to the next line.\n// Line 2: This line adds a at() method to the array prototype, taking an index parameter. \n// Line 3: This line saves the length of the array in a variable.\n// Line 4: This line checks if the index provided is greater than or equal to the length of the array or less than 0. If so, it will return undefined. \n// Line 5: This line returns the value of the array at the specified index.",
    useCase:
      "\n\nArray.prototype.at is used in Javascript to quickly retrieve a specific element from an array without having to iterate through the entire array. This method is especially useful when the index of the element is known, as it is much faster than looping through the array.",
  },
  {
    code: "\n\nif (!Array.prototype.copyWithin) {\n  Array.prototype.copyWithin = function(target, start, end = this.length) {\n    if (start < 0) {\n      start = this.length + start;\n    }\n    if (end < 0) {\n      end = this.length + end;\n    }\n    let last = this.length - 1;\n    for (let i = end - 1; i >= start; i--) {\n      let from = i;\n      let to = target + i - start;\n      if (to > last) {\n        to = last;\n      }\n      if (from in this) {\n        this[to] = this[from];\n      } else {\n        delete this[to];\n      }\n    }\n    return this;\n  };\n}",
    term: "Array.prototype.copyWithin",
    explain:
      "\n\n// Line 1: \n// This is a conditional statement that checks if the Array.prototype.copyWithin method is available.\n\n// Line 2: \n// This line initializes the Array.prototype.copyWithin method and passes in 3 arguments: the target index, the start index, and the end index.\n\n// Line 3: \n// This line checks if the start index is less than 0. If so, it sets the start index to the length of the array plus the start index.\n\n// Line 4: \n// This line checks if the end index is less than 0. If so, it sets the end index to the length of the array plus the end index.\n\n// Line 5: \n// This line sets the last index of the array to the length of the array minus 1.\n\n// Line 6: \n// This line creates a for loop that iterates backwards through the array starting at the end index minus 1 and ending at the start index.\n\n// Line 7: \n// This line sets the from index equal to the current iteration index of the loop.\n\n// Line 8: \n// This line sets the to index equal to the target index plus the iteration index minus the start index.\n\n// Line 9: \n// This line checks if the to index is greater than the last index of the array. If so, it sets the to index to the last index of the array.\n\n// Line 10: \n// This line checks if the from index exists in the array. If so, it sets the to index of the array equal to the from index of the array.\n\n// Line 11: \n// This line executes if the from index does not exist in the array. In this case, it deletes the to index of the array.\n\n// Line 12: \n// This line returns the modified array.",
    useCase:
      "\n\nArray.prototype.copyWithin is used in Javascript to copy a sequence of array elements within the same array. This method allows for elements to be copied from one part of the array to another part of the same array, without changing the length of the array. This method is useful for creating new arrays from existing ones in an efficient manner. It can also be used to move elements in an array around, making it easier to rearrange and manipulate data.",
  },
  {
    code: "\n\nif (!Array.prototype.entries) {\n  Array.prototype.entries = function() {\n    let index = 0;\n    let arr = this;\n    const length = arr.length;\n    return {\n      next() {\n        if (index < length) {\n          return {\n            value: [index, arr[index++]],\n            done: false\n          };\n        } else {\n          return {\n            done: true\n          };\n        }\n      }\n    };\n  };\n}",
    term: "Array.prototype.entries",
    explain:
      "\n\n// line 1: \n// This line checks if the entries method has not been added to the Array prototype.\n\n// line 2: \n// This line adds an entries method to the Array prototype.\n\n// line 3: \n// This line declares a local variable named index and sets it to 0.\n\n// line 4: \n// This line declares a local variable named arr and sets it to the array object that the entries method is being called on.\n\n// line 5: \n// This line declares a constant variable named length and sets it to the length of the array object.\n\n// line 6: \n// This line returns an object with a next method.\n\n// lines 7-14: \n// This code defines the next method. It checks if the index is less than the length of the array. If it is, it returns an object with a value property containing an array with the index and the element at that index, and a done property set to false. If the index is not less than the length, it returns an object with the done property set to true.",
    useCase:
      "\n\nArray.prototype.entries is used to return a new Array Iterator object that contains the key/value pairs for each index in the array. This can be useful when looping through an array and needing to access both the index and value of each element. This can also be used in conjunction with other methods like find() or filter() to quickly iterate through an array and perform specific operations on each element.",
  },
  {
    code: "\n\nif (!Array.prototype.every) {\n  Array.prototype.every = function(callbackfn, thisArg) {\n    let T, k;\n    if (this == null) {\n      throw new TypeError('this is null or not defined');\n    }\n    let O = Object(this);\n    let len = O.length >>> 0;\n    if (typeof callbackfn !== 'function') {\n      throw new TypeError();\n    }\n    if (arguments.length > 1) {\n      T = thisArg;\n    }\n    k = 0;\n    while (k < len) {\n      let kValue;\n      if (k in O) {\n        kValue = O[k];\n        let testResult = callbackfn.call(T, kValue, k, O);\n        if (!testResult) {\n          return false;\n        }\n      }\n      k++;\n    }\n    return true;\n  };\n}",
    term: "Array.prototype.every",
    explain:
      "\n\n// if (!Array.prototype.every) { \n// This checks to see if the every method is already added to the Array prototype. If not, it will add it.\n\n// Array.prototype.every = function(callbackfn, thisArg) { \n// This is the function definition for the every method. It takes in two parameters, a callback function, and a this argument.\n\n// let T, k; \n// This declares and initializes two variables, T and k.\n\n// if (this == null) { \n// This checks if the this argument is null.\n\n// throw new TypeError('this is null or not defined');\n// If the this argument is null, a TypeError is thrown.\n\n// let O = Object(this); \n// This creates an object out of the this argument.\n\n// let len = O.length >>> 0; \n// This sets the variable len to the length of the object created from the this argument.\n\n// if (typeof callbackfn !== 'function') { \n// This checks if the callback function is a function.\n\n// throw new TypeError(); \n// If the callback function is not a function, a TypeError is thrown.\n\n// if (arguments.length > 1) { \n// This checks if there is more than one argument.\n\n// T = thisArg; \n// If there is more than one argument, the variable T is set to the thisArg parameter.\n\n// k = 0; \n// This sets the variable k to 0.\n\n// while (k < len) { \n// This sets up a while loop that runs until k is less than the length of the object O.\n\n// let kValue; \n// This declares the variable kValue.\n\n// if (k in O) { \n// This checks if the value of k is in the object O.\n\n// kValue = O[k]; \n// If the value of k is in the object O, kValue is set to the value of O at the index of k.\n\n// let testResult = callbackfn.call(T, kValue, k, O); \n// This calls the callback function with the parameters kValue, k, and O.\n\n// if (!testResult) { \n// This checks the result of the callback function.\n\n// return false; \n// If the result of the callback function is false, false is returned.\n\n// k++; \n// This increments the value of k.\n\n// return true; \n// This returns true if the callback function returns true for every value in the object.",
    useCase:
      "\n\nArray.prototype.every is used in Javascript to test whether all elements in an array pass a certain test. It can be used to check if all elements in an array satisfy a certain condition, such as being less than a certain number or being of a certain type. It is a useful tool for testing the contents of an array and ensuring that they meet certain criteria.",
  },
  {
    code: "\n\nif (!Array.prototype.fill) {\n  Object.defineProperty(Array.prototype, 'fill', {\n    value: function(value) {\n      if (this == null) {\n        throw new TypeError('this is null or not defined');\n      }\n      let O = Object(this);\n      let len = O.length >>> 0;\n      let start = arguments[1];\n      let relativeStart = start >> 0;\n      let k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);\n      let end = arguments[2];\n      let relativeEnd = end === undefined ? len : end >> 0;\n      let final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);\n      while (k < final) {\n        O[k] = value;\n        k++;\n      }\n      return O;\n    }\n  });\n}",
    term: "Array.prototype.fill",
    explain:
      "\n\n// Line 1: This is an if statement, checking to see if the fill method has been defined for the Array prototype. If not, Object.defineProperty is used to define the method. \n// Line 2: This sets the value of the Array.prototype.fill method to a function which is defined below. \n// Line 3: This checks to make sure that the array is not null or undefined. If it is, a TypeError is thrown. \n// Line 4: This creates a new object from the array. \n// Line 5: This sets the length of the array to a number with no decimal places (>>> operator). \n// Line 6: This sets the start argument to the second argument of the function. \n// Line 7: This sets the relativeStart argument (start argument shifted by 0 bits) to the start argument. \n// Line 8: This sets the k argument to the larger of the two numbers (relativeStart and 0) or the smaller of the two numbers (relativeStart and the length of the array). \n// Line 9: This sets the end argument to the third argument of the function. \n// Line 10: This sets the relativeEnd argument (end argument shifted by 0 bits) to the end argument, or if it is undefined, the length of the array. \n// Line 11: This sets the final argument to the larger of the two numbers (relativeEnd and 0) or the smaller of the two numbers (relativeEnd and length of the array). \n// Line 12-14: This is a while loop, which loops through the array from start to end, setting each element to the value argument. \n// Line 15: This returns the array with the elements set to the value argument.",
    useCase:
      "\n\nArray.prototype.fill is used in Javascript to fill all the elements of an array with a static value, from a start index to an end index. This is useful for quickly populating an array with a set value, or for quickly resetting an array to a given value. It is also a useful tool for creating new arrays based on existing arrays with modified values.",
  },
  {
    code: "\n\nif (!Array.prototype.filter) {\n  Array.prototype.filter = function(callback, thisArg) {\n    let arr = [];\n    if (this == null) throw new TypeError('this is null or not defined');\n    let o = Object(this);\n    let len = o.length >>> 0;\n    if (typeof callback !== 'function') throw new TypeError(callback + ' is not a function');\n    for (let i = 0; i < len; i++) {\n      if (i in o) {\n        let val = o[i];\n        if (callback.call(thisArg, val, i, o)) {\n          arr.push(val);\n        }\n      }\n    }\n    return arr;\n  };\n}",
    term: "Array.prototype.filter",
    explain:
      "\n\n//1. This line checks if the filter function already exists in the Array prototype. \nif (!Array.prototype.filter) {\n\n//2. If it doesn't, then the following function is added to the Array prototype.\n  Array.prototype.filter = function(callback, thisArg) {\n\n//3. A new array is initialized to store the results.\n    let arr = [];\n\n//4. This line checks if the array being used is null or undefined.\n    if (this == null) throw new TypeError('this is null or not defined');\n\n//5. This line converts the array to an object for use.\n    let o = Object(this);\n\n//6. This line stores the length of the array as a 32-bit unsigned integer.\n    let len = o.length >>> 0;\n\n//7. This line checks to make sure the callback being used is actually a function.\n    if (typeof callback !== 'function') throw new TypeError(callback + ' is not a function');\n\n//8. This loop iterates over the array and runs the callback function on each item. \n    for (let i = 0; i < len; i++) {\n\n//9. This line checks if the item is part of the array.\n      if (i in o) {\n\n//10. This line stores the current item in the array.\n        let val = o[i];\n\n//11. This line calls the callback on the current item in the array and checks if it returns true. \n        if (callback.call(thisArg, val, i, o)) {\n\n//12. If it does, then the item is added to the new array. \n          arr.push(val);\n        }\n      }\n    }\n\n//13. This line returns the new array with the filtered items. \n    return arr;\n  };\n}",
    useCase:
      "\n\nArray.prototype.filter is used to create a new array with all elements that pass the test implemented by the provided function. It is a useful tool for filtering out elements from an array that don't meet certain criteria. It is a great way to reduce the amount of data that needs to be processed.",
  },
  {
    code: "\n\nif (!Array.prototype.find) {\n  Object.defineProperty(Array.prototype, 'find', {\n    value: function(predicate) {\n      if (this == null) {\n        throw new TypeError('\"this\" is null or not defined');\n      }\n      var o = Object(this);\n      var len = o.length >>> 0;\n      if (typeof predicate !== 'function') {\n        throw new TypeError('predicate must be a function');\n      }\n      var thisArg = arguments[1];\n      var k = 0;\n      while (k < len) {\n        var kValue = o[k];\n        if (predicate.call(thisArg, kValue, k, o)) {\n          return kValue;\n        }\n        k++;\n      }\n      return undefined;\n    }\n  });\n}",
    term: "Array.prototype.find",
    explain:
      '\n\n1. if (!Array.prototype.find) { // checks if the Array.prototype object has a property called find\n\n2. Object.defineProperty(Array.prototype, \'find\', { // adds a new property to the Array.prototype object\n\n3. value: function(predicate) { // assigns the value of the new property to a function\n\n4. if (this == null) { // checks if the value of "this" is null or not defined\n\n5. throw new TypeError(\'"this" is null or not defined\'); // throws an error if the value of "this" is null or not defined\n\n6. var o = Object(this); // assigns the value of "this" to a variable\n\n7. var len = o.length >>> 0; // assigns the length of the variable "o" to a variable\n\n8. if (typeof predicate !== \'function\') { // checks that the type of the variable "predicate" is a function\n\n9. throw new TypeError(\'predicate must be a function\'); // throws an error if the type of the variable "predicate" is not a function\n\n10. var thisArg = arguments[1]; // assigns the second argument to a variable\n\n11. var k = 0; // sets a counter variable to 0\n\n12. while (k < len) { // loops while the counter variable is less than the length of the variable "o"\n\n13. var kValue = o[k]; // assigns the value of the kth item in the variable "o" to a variable\n\n14. if (predicate.call(thisArg, kValue, k, o)) { // checks if the function "predicate" returns true when passed the variables "thisArg", "kValue", and "o"\n\n15. return kValue; // returns the value of the variable "kValue" if the function "predicate" returns true\n\n16. k++; // increments the counter variable\n\n17. } // ends the loop\n\n18. return undefined; // returns undefined if the function "predicate" does not return true\n\n19. } // ends the value of the new property\n\n20. }); // ends the Object.defineProperty method\n\n21. } // ends the if statement',
    useCase:
      "\n\nArray.prototype.find is used in Javascript to find the first element in an array that satisfies a given condition. It is a useful way to quickly search through an array and return a value that matches the condition. It is much simpler and faster than using a for loop to loop through the array and manually check each element.",
  },
  {
    code: "\n\nif (!Array.prototype.findIndex) {\n  Array.prototype.findIndex = function(predicate) {\n    if (this === null) {\n      throw new TypeError('Array.prototype.findIndex called on null or undefined');\n    }\n    if (typeof predicate !== 'function') {\n      throw new TypeError('predicate must be a function');\n    }\n    var list = Object(this);\n    var length = list.length >>> 0;\n    var thisArg = arguments[1];\n    var value;\n\n    for (var i = 0; i < length; i++) {\n      value = list[i];\n      if (predicate.call(thisArg, value, i, list)) {\n        return i;\n      }\n    }\n    return -1;\n  };\n}",
    term: "Array.prototype.findIndex",
    explain:
      "\n\n// Line 1: \n// Checks to see if the Array.prototype.findIndex is already defined. \n\n// Line 2: \n// If the Array.prototype.findIndex is not already defined, define it using a function that takes a predicate as an argument. \n\n// Line 3: \n// If the this value passed in to the function is null or undefined, throw a TypeError. \n\n// Line 4: \n// If the predicate argument is not a function, throw a TypeError.\n\n// Line 5: \n// Declare a variable called list set to the object passed in to the function.\n\n// Line 6: \n// Declare a variable called length set to the length of the list variable.\n\n// Line 7:\n// Declare a variable called thisArg set to the argument at index 1.\n\n// Line 8: \n// Declare a variable called value.\n\n// Lines 9-14: \n// Iterate through the list variable, setting the value variable to the current element in the list. \n// If the predicate function returns true when called on the value, the index of the current element is returned. \n\n// Line 15: \n// If the predicate function never returns true, return -1.",
    useCase:
      "\n\nArray.prototype.findIndex is used to find the index of the first element in an array that satisfies the provided testing function. It returns the index of the found element, or -1 if no element is found. This method can be used to quickly search an array for a specific element and return its index, or to find the index of the first element that meets certain criteria.",
  },
  {
    code: "\n\nif (!Array.prototype.flat) {\n  Array.prototype.flat = function() {\n    let res = [];\n    for (let i = 0; i < this.length; i++) {\n      if (Array.isArray(this[i])) {\n        res = res.concat(this[i].flat());\n      } else {\n        res.push(this[i]);\n      }\n    }\n    return res;\n  };\n}",
    term: "Array.prototype.flat",
    explain:
      "\n\n//Line 1: \n//This line checks if the flat method is not present in the Array prototype.\n\n//Line 2: \n//This line adds a flat method to the Array prototype.\n\n//Line 3: \n//This line creates an empty array named 'res' to store the flattened array.\n\n//Line 4: \n//This line is a for loop that iterates over the array.\n\n//Line 5: \n//This line checks if the current element is an array and calls the flat method on it.\n\n//Line 6: \n//This line concats the flattened array with the res array.\n\n//Line 7: \n//This line pushes the element to the res array if it is not an array.\n\n//Line 8: \n//This line returns the flattened array.",
    useCase:
      "\n\nArray.prototype.flat is used to flatten an array of sub-arrays into a single, flat array. It is a useful method for reducing the number of nested levels in an array, allowing easier access to elements in the array. It is also useful for manipulating data, such as when combining multiple arrays into a single array.",
  },
  {
    code: "\n\nif (!Array.prototype.flatMap) {\n    Array.prototype.flatMap = function(callback) {\n        return this.reduce((acc, x) => {\n            return acc.concat(callback(x));\n        }, []);\n    };\n}",
    term: "Array.prototype.flatMap",
    explain:
      "\n\n// Line 1: This line checks if the Array.prototype does not have a flatmap method.\n// Line 2: This line is the beginning of the flatmap function definition. The function takes in a callback function as a parameter.\n// Line 3: This line uses the reduce() method to reduce the array to a single value. The callback function takes in two parameters, the accumulator and the current value, and returns a concatenated array.\n// Line 4: This line is the return statement, which returns the concatenated array.\n// Line 5: This line is the end of the function definition.",
    useCase:
      "\n\nArray.prototype.flatMap is used in Javascript to map each element using a mapping function, then flatten the resulting arrays into a single array. This is useful when you need to apply a mapping function to each element of an array, and then flatten all the resulting arrays into a single array. For example, it can be used to take an array of strings and map each string to an array of characters, and then flatten the resulting arrays of characters into a single array of characters.",
  },
  {
    code: "\n\nif (!Array.prototype.forEach) {\n  Array.prototype.forEach = function(callback/*, thisArg*/) {\n    let array = this;\n    let thisArg = arguments[1];\n    for (let i = 0; i < array.length; i++) {\n      callback.call(thisArg, array[i], i, array);\n    }\n  };\n}",
    term: "Array.prototype.forEach",
    explain:
      "\n\n// Line 1:\n// This line checks to see if the forEach method has already been added to the Array prototype. If it has not been added, the code inside the if statement will be run.\n\n// Line 2:\n// This line adds a forEach method to the Array prototype. It takes a callback function and a thisArg argument as parameters.\n\n// Line 3:\n// This line stores the array that the forEach method is called on in a variable called array.\n\n// Line 4:\n// This line stores the second argument of the forEach method in a variable called thisArg.\n\n// Line 5:\n// This line is a for loop that loops through each element in the array.\n\n// Line 6:\n// This line calls the callback function that was passed into the forEach method. It passes in the current element in the array, the index of the element, and the array itself as arguments. It also sets the context of the callback function to the thisArg argument.",
    useCase:
      "\n\nArray.prototype.forEach is used in Javascript to loop through each element in an array and execute a function for each element. It is a useful tool for iterating over each element of an array and performing some action on it, such as manipulating the element or adding it to a new array. It is more efficient than manually looping through each element of an array.",
  },
  {
    code: "\n\nif (!Array.prototype.includes) {\n  Array.prototype.includes = function(element, startIndex) {\n    if (startIndex === undefined) {\n      startIndex = 0\n    }\n    for (var i = startIndex; i < this.length; i++) {\n      if (this[i] === element) {\n        return true\n      }\n    }\n    return false\n  }\n}",
    term: "Array.prototype.includes",
    explain:
      "\n\n// Line 1: \n// This line checks whether the 'includes' method is already defined in the Array prototype. If not, then the following code is executed.\n\n// Line 2: \n// This line defines the 'includes' method in the Array prototype.\n\n// Line 3: \n// This line checks whether the startIndex argument is undefined. If so, it assigns it the value 0.\n\n// Line 4: \n// This line initializes a loop with the variable i as the iterator, starting at the value of startIndex and ending at the last element of the array.\n\n// Line 5: \n// This line checks if the element at the current index is equal to the element passed as an argument. If so, it returns true.\n\n// Line 6: \n// This line is executed when the loop ends, and it returns false if no element in the array was equal to the argument.",
    useCase:
      "\n\nArray.prototype.includes is used in Javascript to determine whether an array includes a certain element, returning true or false as appropriate. It is an efficient way to check if a specific element is present in an array, without needing to loop through the array and manually check each element.",
  },
  {
    code: "\n\nif (!Array.prototype.indexOf) {\n  Array.prototype.indexOf = function(searchElement, fromIndex) {\n    if (this == null) {\n      throw new TypeError('\"this\" is null or not defined');\n    }\n    var o = Object(this);\n    var len = o.length >>> 0;\n    if (len === 0) {\n      return -1;\n    }\n    var n = fromIndex | 0;\n    if (n >= len) {\n      return -1;\n    }\n    var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\n    while (k < len) {\n      if (k in o && o[k] === searchElement) {\n        return k;\n      }\n      k++;\n    }\n    return -1;\n  };\n}",
    term: "Array.prototype.indexOf",
    explain:
      "\n\n// if (!Array.prototype.indexOf) {\n// This line checks to see if the 'indexOf' method already exists on the Array object.\n\n// Array.prototype.indexOf = function(searchElement, fromIndex) {\n// This line adds the 'indexOf' method to the Array object if it doesn't already exist.\n\n// if (this == null) {\n// This line checks to see if the 'this' keyword is null or undefined.\n\n// var o = Object(this);\n// This line creates an object from the current array.\n\n// var len = o.length >>> 0;\n// This line gets the length of the object and converts it to an unsigned 32-bit integer.\n\n// if (len === 0) {\n// This line checks to see if the array is empty.\n\n// return -1;\n// This line returns -1 if the array is empty.\n\n// var n = fromIndex | 0;\n// This line creates an integer from the 'fromIndex' parameter.\n\n// if (n >= len) {\n// This line checks to see if the 'fromIndex' is greater than or equal to the array length.\n\n// return -1;\n// This line returns -1 if the 'fromIndex' is greater than or equal to the array length.\n\n// var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\n// This line creates a variable 'k' that is equal to the maximum value of either the 'fromIndex' or the array length - the absolute value of the 'fromIndex'.\n\n// while (k < len) {\n// This line creates a loop that runs until 'k' is equal to the array length.\n\n// if (k in o && o[k] === searchElement) {\n// This line checks to see if the current element in the array is equal to the 'searchElement' parameter.\n\n// return k;\n// This line returns the index of the element if it is found.\n\n// k++;\n// This line increments 'k' by 1 at the end of each loop.\n\n// return -1;\n// This line returns -1 if the element is not found.",
    useCase:
      "\n\nArray.prototype.indexOf is used in Javascript to find the index of an element in an array. It takes the element as an argument and returns the index of the first occurrence of the element in the array, or -1 if the element is not present. This method is useful for quickly finding the position of an element in an array and for checking if an element exists in an array.",
  },
  {
    code: "\n\nif (!Array.prototype.keys) {\n  Array.prototype.keys = function() {\n    let index = 0;\n    let array = this;\n    return {\n      next: () => {\n        if (index < array.length) {\n          return {\n            value: index++, \n            done: false\n          };\n        }\n        return {\n          done: true\n        };\n      }\n    };\n  };\n}",
    term: "Array.prototype.keys",
    explain:
      "\n\n// Line 1: This line checks to see if the Array.prototype object has a property of 'keys' and if not, it proceeds to the next line of code. \n// Line 2: This line adds a 'keys' property to the Array.prototype object that is a function. \n// Line 3: This line declares a variable called 'index' and sets its value to 0. \n// Line 4: This line declares a variable called 'array' and sets its value to the array calling the function. \n// Line 5: This line returns an object with a 'next' property, which is a function. \n// Line 6: This line checks to see if the 'index' is less than the length of the array and if it is, it returns an object with a 'value' property set to the 'index' and a 'done' property set to false. \n// Line 7: This line is executed if the 'index' is not less than the length of the array and it returns an object with a 'done' property set to true. \n// Line 8: This line closes the 'next' function. \n// Line 9: This line closes the 'keys' function.",
    useCase:
      "\n\nArray.prototype.keys is used in Javascript to return a new Array Iterator object that contains the keys for each index in the array. This allows developers to iterate over the array and access the keys of each index, which can then be used to access the corresponding value. This method is useful for accessing and manipulating the data stored in an array.",
  },
  {
    code: "\n\nif (!Array.prototype.lastIndexOf) {\n    Array.prototype.lastIndexOf = function (searchElement, fromIndex) {\n        let k;\n        if (fromIndex === undefined) {\n            k = this.length - 1;\n        } else {\n            k = fromIndex >= 0 ? fromIndex : this.length + fromIndex;\n        }\n        for (let i = k; i >= 0; i--) {\n            if (this[i] === searchElement) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}",
    term: "Array.prototype.lastIndexOf",
    explain:
      "\n\n// This code is checking to see if the lastIndexOf function is already present on the Array.prototype object.\n// If it is not, it is adding the function to the Array.prototype object.\n\n// Line 1: \n// This is a check to see if the lastIndexOf function is already present on the Array.prototype object. \n// If it is, the code does not need to be run.\n\n// Line 2: \n// This line is defining the lastIndexOf function and adding it to the Array.prototype object if it is not already present.\n\n// Line 3:\n// This line is setting up the k variable. If the fromIndex parameter is not specified, it sets k to the length of the array minus 1. \n// Otherwise, it sets k to the value of fromIndex if it is greater than or equal to 0, or the length of the array plus the value of fromIndex if it is less than 0.\n\n// Line 4:\n// This line is starting a for loop that runs from k to 0.\n\n// Line 5:\n// This line is checking to see if the element at the current index of the array is equal to the searchElement parameter. \n// If it is, it returns the index of the element.\n\n// Line 6: \n// This line is run if the element at the current index of the array is not equal to the searchElement parameter. \n// It returns -1, indicating that the searchElement was not found in the array.",
    useCase:
      "\n\nArray.prototype.lastIndexOf is used in JavaScript to find the last index of an element in an array. It is useful for finding the last occurrence of an element in an array and can be used to determine whether an element exists in the array or not. It is also useful for identifying the index of the last item in an array that meets a certain criteria.",
  },
  {
    code: "\n\n//polyfill of Array.prototype.map function\nif(!Array.prototype.map){\n    Array.prototype.map = function(callback, thisArg){\n        let resultArray = [];\n        for(let i = 0; i < this.length; i++){\n            resultArray.push(callback.call(thisArg, this[i], i, this));\n        }\n        return resultArray;\n    }\n}",
    term: "Array.prototype.map",
    explain:
      "\n\n//This code creates a polyfill of the Array.prototype.map function. This is a function that allows the user to traverse through each element of an array and apply a callback function on each element.\n\n//Line 1:\n//This line checks to see if the Array.prototype.map function already exists.\n\n//Line 2:\n//If the function does not already exist, this line creates the Array.prototype.map function.\n\n//Line 3:\n//This line creates an empty resultArray that will contain the result of the map function.\n\n//Line 4:\n//This line creates a for loop that iterates through each element of the array and applies the callback function. \n\n//Line 5:\n//This line pushes the result of the callback function to the resultArray.\n\n//Line 6:\n//This line returns the resultArray.",
    useCase:
      "\n\nArray.prototype.map is used in Javascript to create a new array of values by mapping each element in an existing array through a function. This can be used to transform each element in the existing array into a different value or format. It is useful for performing operations on all elements in an array in a concise manner.",
  },
  {
    code: "\n\nif (!Array.prototype.reduce) {\n  Array.prototype.reduce = function(callback /*, initialValue*/) {\n    if (this === null) {\n      throw new TypeError('Array.prototype.reduce ' +\n        'called on null or undefined');\n    }\n    if (typeof callback !== 'function') {\n      throw new TypeError(callback +\n        ' is not a function');\n    }\n\n    // 1. Let O be ? ToObject(this value).\n    var o = Object(this);\n\n    // 2. Let len be ? ToLength(? Get(O, \"length\")).\n    var len = o.length >>> 0;\n\n    // Steps 3, 4, 5, 6, 7\n    var k = 0;\n    var value;\n\n    if (arguments.length >= 2) {\n      value = arguments[1];\n    } else {\n      while (k < len && !(k in o)) {\n        k++;\n      }\n\n      // 3. If len is 0 and initialValue is not present,\n      //    throw a TypeError exception.\n      if (k >= len) {\n        throw new TypeError('Reduce of empty array ' +\n          'with no initial value');\n      }\n      value = o[k++];\n    }\n\n    // 8. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      // b. Let kPresent be ? HasProperty(O, Pk).\n      // c. If kPresent is true, then\n      //    i. Let kValue be ? Get(O, Pk).\n      //    ii. Let accumulator be ? Call(\n      //          callbackfn, undefined,\n      //          « accumulator, kValue, k, O »).\n      if (k in o) {\n        value = callback(value, o[k], k, o);\n      }\n\n      // d. Increase k by 1.\n      k++;\n    }\n\n    // 9. Return accumulator.\n    return value;\n  };\n}",
    term: "Array.prototype.reduce",
    explain:
      "\n\n// Line 1: This line is a check to make sure the reduce function is not already present in the Array.prototype. If the reduce function is not present, the code will continue.\n\n// Line 2: This line is the beginning of the reduce function that will be added to the Array.prototype. It takes in a callback as its argument.\n\n// Line 3-6: This block of code is a check to make sure that the object passed in is an Array. If it is not an Array, it will throw an error.\n\n// Line 7-11: This block of code is a check to make sure the initial value is passed in. If an initial value is not passed in, the first value of the array will be used.\n\n// Line 12-21: This block of code is a loop that will iterate over the array and call the callback function with the accumulator, current value, index, and array as arguments.\n\n// Line 22-25: This block of code returns the accumulator after the loop is finished.",
    useCase:
      "\n\nArray.prototype.reduce is used in JavaScript to iterate through an array and reduce it down to a single value. It can be used to perform a variety of tasks such as summing up values, calculating the average, joining elements together in a string, and more. It is a powerful method that allows developers to quickly and efficiently work with data in an array.",
  },
  {
    code: "\n\nif (!Array.prototype.reduceRight) {\n  Array.prototype.reduceRight = function(callback, initialValue) {\n    let arr = Object(this); \n    let len = arr.length >>> 0; \n    let k = len - 1;\n    let accumulator;\n\n    if (arguments.length >= 2) {\n      accumulator = initialValue;\n    } else {\n      while (k >= 0 && !(k in arr)) {\n        k--;\n      }\n      if (k < 0)\n        throw new TypeError('Reduce of empty array with no initial value');\n      accumulator = arr[k--];\n    }\n    \n    for (; k >= 0; k--) {\n      if (k in arr) {\n       accumulator = callback(accumulator, arr[k], k, arr);\n      }\n    }\n    return accumulator; \n  }\n}",
    term: "Array.prototype.reduceRight",
    explain:
      '\n\n// Line 1: \n// This line checks if the Array.prototype.reduceRight function already exists. If it does not, it will create the function.\n\n// Line 2: \n// This line creates the Array.prototype.reduceRight function, with two parameters, callback and initialValue.\n\n// Line 3: \n// This line creates a variable called "arr" which is an object version of the array.\n\n// Line 4: \n// This line creates a variable called "len" which stores the length of the array.\n\n// Line 5: \n// This line creates a variable called "k" which is equal to the length of the array minus 1.\n\n// Line 6: \n// This line creates a variable called "accumulator" which will store the result of the reduceRight operation.\n\n// Line 7: \n// This line checks if there are two arguments (callback and initialValue). If there are two arguments, the accumulator variable is set to the initialValue argument.\n\n// Line 8: \n// This line checks if the k variable is greater than or equal to 0 and if the kth element of the array exists. If it does not, the k variable is decremented by 1.\n\n// Line 9: \n// This line checks if the k variable is less than 0. If it is, it throws an error because there is no initial value. \n\n// Line 10: \n// This line sets the accumulator variable to the kth element of the array and decrements k by 1.\n\n// Line 11: \n// This line runs a for loop from k to 0.\n\n// Line 12: \n// This line checks if the kth element of the array exists. If it does, the accumulator variable is set to the result of the callback function.\n\n// Line 13: \n// This line returns the accumulator variable which holds the result of the reduceRight operation.',
    useCase:
      "\n\nArray.prototype.reduceRight is used to iterate through an array from right to left, applying a callback function to each element. This can be useful for performing a certain operation on an array, such as adding up all the numbers in an array or finding the maximum value. It also allows developers to apply their own custom logic to each element, enabling them to create more complex applications.",
  },
  {
    code: "\n\nif (!Array.prototype.some) {\n    Array.prototype.some = function(callback, thisArg) {\n        let T, k;\n        if (this == null) {\n            throw new TypeError('this is null or not defined');\n        }\n        let O = Object(this);\n        let len = O.length >>> 0;\n        if (typeof callback !== 'function') {\n            throw new TypeError(callback + ' is not a function');\n        }\n        if (arguments.length > 1) {\n            T = thisArg;\n        }\n        k = 0;\n        while (k < len) {\n            let kValue;\n            if (k in O) {\n                kValue = O[k];\n                let testResult = callback.call(T, kValue, k, O);\n                if (testResult) {\n                    return true;\n                }\n            }\n            k++;\n        }\n        return false;\n    };\n}",
    term: "Array.prototype.some",
    explain:
      "\n\n//Line 1: This line checks if the .some() method exists on the Array prototype.\n//Line 2: If it does not exist, the function creates a .some() method on the Array prototype.\n//Line 3: This line creates a variable T and k to store temporary values.\n//Line 4: This line checks if the array is null or undefined.\n//Line 5: This line creates an Object from the array.\n//Line 6: This line creates a variable len to store the length of the array.\n//Line 7: This line checks if the callback argument is a function.\n//Line 8: This line checks if the thisArg argument is present.\n//Line 9: This line sets the value of k to 0.\n//Line 10: This line creates a while loop that runs until k is equal to the length of the array.\n//Line 11: This line creates a variable kValue to store the value of the array at the given index.\n//Line 12: This line checks if the index exists in the array.\n//Line 13: This line sets kValue to the value of the array at the given index.\n//Line 14: This line calls the callback function with the current value, index, and array as arguments.\n//Line 15: This line checks if the callback returns true, and if so, returns true.\n//Line 16: This line increments k.\n//Line 17: This line returns false if the callback function never returns true.",
    useCase:
      "\n\nArray.prototype.some is used in JavaScript to check if at least one element in the array passes a certain condition. It is useful for quickly testing if any elements in an array meet a certain criteria. It can be used to check if any elements in an array match a certain value, or if any elements in an array satisfy a certain condition.",
  },
  {
    code: "\n\nif (!Array.prototype.sort) {\n  Array.prototype.sort = function(compareFn) {\n\n    const length = this.length;\n\n    for (let i = 0; i < length; i++) {\n      for (let j = 0; j < length - 1; j++) {\n        if (compareFn ? compareFn(this[j], this[j + 1]) > 0 : this[j] > this[j + 1]) {\n          let temp = this[j];\n          this[j] = this[j + 1];\n          this[j + 1] = temp;\n        }\n      }\n    }\n    return this;\n  }\n}",
    term: "Array.prototype.sort",
    explain:
      "\n\n// Line 1: This line is a conditional statement that checks to see if the Array.prototype has a sort method.\n// Line 2: If the Array.prototype does not have a sort method, this line defines a sort method for the Array.prototype.\n// Line 3: This line declares a variable length that is set to the length of the array.\n// Line 4: This line is a for loop that iterates through the array starting at the first element.\n// Line 5: This line is a nested for loop that iterates through the array starting at the second element.\n// Line 6: This line is a conditional statement that checks if the compareFn parameter is passed in and compares the two elements. If the compareFn parameter is not passed in, then it compares the two elements with the greater than operator.\n// Line 7: This line declares a temporary variable and sets it to the first element.\n// Line 8: This line sets the first element to the second element.\n// Line 9: This line sets the second element to the temporary variable which is the first element.\n// Line 10: This line closes the nested for loop.\n// Line 11: This line closes the for loop.\n// Line 12: This line returns the array after it has been sorted.\n// Line 13: This line closes the conditional statement.",
    useCase:
      "\n\nArray.prototype.sort is used in Javascript to sort an array in ascending or descending order. This method is used to sort elements of an array alphabetically, numerically, or by any other custom sorting criteria. This method is useful for sorting data in a more efficient way than manually looping through the array and comparing each element.",
  },
  {
    code: "\n\nif (!Array.prototype.values) {\n    Array.prototype.values = function () {\n        let i = 0;\n        let current = this[i];\n        const iterator = {\n            next: function () {\n                const value = {\n                    done: i >= this.length,\n                    value: current\n                }\n                i++;\n                current = this[i];\n                return value;\n            }\n        };\n        return iterator;\n    };\n}",
    term: "Array.prototype.values",
    explain:
      "\n\n// Line 1: \n// This line checks to see if there is already an existing 'values' prototype method for the Array object. \n\n// Line 2: \n// If the 'values' prototype method does not exist, this line adds it as a function on the Array prototype.\n\n// Line 3: \n// This line initializes a counter variable i and sets it to 0.\n\n// Line 4: \n// This line initializes a variable called current and sets it to the first element in the array.\n\n// Line 5: \n// This line creates an iterator object and assigns it to the variable iterator.\n\n// Line 6: \n// This line creates a function called next which returns an object with two properties, done and value. The done property is set to true if the counter is greater than or equal to the length of the array, and the value property is set to the current element in the array.\n\n// Line 7: \n// This line increments the counter variable.\n\n// Line 8: \n// This line sets the current variable to the next element in the array.\n\n// Line 9: \n// This line returns the iterator object.\n\n// Line 10: \n// This line returns the values function.",
    useCase:
      "\n\nArray.prototype.values is used in Javascript to return a new Array Iterator object that contains the values for each index in the array. It provides a way to access all the elements of an array without having to loop through them individually. This is helpful when dealing with large arrays, as it can speed up the process of iterating over them.",
  },
  {
    code: "\n\nif (!ArrayBuffer.prototype.slice) {\n    ArrayBuffer.prototype.slice = function(start, end) {\n        let that = new Uint8Array(this);\n        if (end === undefined) end = that.length;\n        let result = new ArrayBuffer(end - start);\n        let resultArray = new Uint8Array(result);\n        for (let i = 0; i < resultArray.length; i++) {\n            resultArray[i] = that[i + start];\n        }\n        return result;\n    };\n}",
    term: "ArrayBuffer",
    explain:
      "\n\n// Line 1: \n// This line checks if the ArrayBuffer.prototype object does not have a slice method. If it does not, it will proceed to the next line. Otherwise, it will skip the rest of the code. \n\n// Line 2: \n// This line adds a slice method to the ArrayBuffer.prototype object. This method takes two arguments, start and end.\n\n// Line 3: \n// This line creates a new Uint8Array from the ArrayBuffer. If the end argument is not given, it will set end equal to the length of the Uint8Array.\n\n// Line 4:\n// This line creates a new ArrayBuffer with the length of end minus start.\n\n// Line 5:\n// This line creates a new Uint8Array from the new ArrayBuffer. \n\n// Line 6: \n// This line iterates through the resultArray and sets each element to the corresponding element in the that array, which is the original Uint8Array.\n\n// Line 7: \n// This line returns the result ArrayBuffer.",
    useCase:
      "\n\nArrayBuffer is used in JavaScript to store binary data, such as the contents of an image file or a video. It can be used to create a typed array, which is an array of a specific type of data, such as integers or floating-point numbers. ArrayBuffers are also used to create ArrayBufferViews, which are views into an ArrayBuffer that can represent the data as an array of a specific type. ArrayBuffers are a low-level primitive for storing binary data, and are used by many of the higher-level APIs for handling binary data, such as the File and Blob APIs.",
  },
  {
    code: "\n\nif (!ArrayBuffer.isView) {\n  ArrayBuffer.isView = function(arg) {\n    return arg !== null && typeof arg === 'object' && arg.buffer instanceof ArrayBuffer;\n  };\n}",
    term: "ArrayBuffer.isView",
    explain:
      "\n\nLine 1: if (!ArrayBuffer.isView) {\n\nThis line checks whether the isView method already exists on the ArrayBuffer object.\n\nLine 2: ArrayBuffer.isView = function(arg) {\n\nThis line creates a new method on the ArrayBuffer object called isView which takes in a single argument. \n\nLine 3: return arg !== null && typeof arg === 'object' && arg.buffer instanceof ArrayBuffer;\n\nThis line returns a boolean value based on the argument passed to the isView function. It returns true if the argument is not null, is an object, and has a buffer property which is an instance of an ArrayBuffer.",
    useCase:
      "\n\nArrayBuffer.isView is used in Javascript to check if a given value is a view on an ArrayBuffer. This is useful when working with binary data, as it allows us to determine whether a given value is a view of the underlying array buffer. This can be used to ensure that the data is being accessed and manipulated correctly, as well as to detect incorrect uses of views.",
  },
  {
    code: "\n\n(function() {\n  var lastTime = 0;\n  var vendors = ['ms', 'moz', 'webkit', 'o'];\n  for(var x = 0; x < vendors.length && !window.AudioContext; ++x) {\n    window.AudioContext = window[vendors[x]+'AudioContext'];\n  }\n\n  if (!window.AudioContext) {\n    window.AudioContext = function() {\n      this.sampleRate = 44100;\n      this.currentTime = 0;\n      this.listener = {\n        setPosition: function () {},\n        setOrientation: function () {},\n        setVelocity: function () {}\n      };\n      this.createGainNode = function () {\n          return new GainNode();\n      };\n      this.createScriptProcessor = function () {\n          return new ScriptProcessor();\n      };\n      this.createBufferSource = function () {\n          return new BufferSourceNode();\n      };\n      this.createDelayNode = function () {\n          return new DelayNode();\n      };\n      this.createPanner = function () {\n          return new Panner();\n      };\n      this.createAnalyser = function () {\n          return new Analyser();\n      };\n      this.createWaveShaper = function () {\n          return new WaveShaper();\n      };\n      this.createBiquadFilter = function () {\n          return new BiquadFilter();\n      };\n      this.createIIRFilter = function () {\n          return new IIRFilter();\n      };\n      this.createConvolver = function () {\n          return new Convolver();\n      };\n      this.createChannelSplitter = function () {\n          return new ChannelSplitter();\n      };\n      this.createChannelMerger = function () {\n          return new ChannelMerger();\n      };\n      this.createOscillator = function () {\n          return new OscillatorNode();\n      };\n      this.createPeriodicWave = function () {\n          return new PeriodicWave();\n      };\n      this.createMediaElementSource = function () {\n          return new MediaElementSource();\n      };\n      this.createMediaStreamSource = function () {\n          return new MediaStreamSource();\n      };\n      this.createMediaStreamDestination = function () {\n          return new MediaStreamDestination();\n      };\n      this.close = function () {};\n      this.suspend = function () {};\n      this.resume = function () {};\n      this.createBuffer = function () {\n          return new AudioBuffer();\n      };\n      this.decodeAudioData = function () {};\n      this.getOutputTimestamp = function () {\n          return {\n              contextTime: 0,\n              performanceTime: 0\n           }; \n      };\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n    }\n  }\n\n  function GainNode() {\n      this.gain = {\n          value: 1,\n      };\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function ScriptProcessor() {\n      this.onaudioprocess = undefined;\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function BufferSourceNode() {\n      this.buffer = null;\n      this.loop = false;\n      this.loopStart = 0;\n      this.loopEnd = 0;\n      this.onended = null;\n      this.start = function () {};\n      this.stop = function () {};\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function DelayNode() {\n      this.delayTime = {\n          value: 0\n      };\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function Panner() {\n      this.panningModel = 'equalpower';\n      this.setPosition = function () {};\n      this.setOrientation = function () {};\n      this.setVelocity = function () {};\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function Analyser() {\n      this.fftSize = 2048;\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function WaveShaper() {\n      this.oversample = '4x';\n      this.curve = null;\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function BiquadFilter() {\n      this.type = 'lowpass';\n      this.frequency = {\n          value: 440\n      };\n      this.Q = {\n          value: 1\n      };\n      this.detune = {\n          value: 0\n      };\n      this.gain = {\n          value: 0\n      };\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function IIRFilter() {\n      this.type = 'lowpass';\n      this.frequency = {\n          value: 440\n      };\n      this.Q = {\n          value: 1\n      };\n      this.detune = {\n          value: 0\n      };\n      this.gain = {\n          value: 0\n      };\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function Convolver() {\n      this.normalize = true;\n      this.buffer = null;\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function ChannelSplitter() {\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function ChannelMerger() {\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function OscillatorNode() {\n      this.type = 'sine';\n      this.frequency = {\n          value: 440\n      };\n      this.detune = {\n          value: 0\n      };\n      this.start = function () {};\n      this.stop = function () {};\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function PeriodicWave() {\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function MediaElementSource() {\n      this.mediaElement = null;\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function MediaStreamSource() {\n      this.mediaStream = null;\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener = function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function MediaStreamDestination() {\n      this.mediaStream = null;\n      this.connect = function () {};\n      this.disconnect = function () {};\n      this.addEventListener =",
    term: "AudioContext",
    explain:
      " function () {};\n      this.removeEventListener = function () {};\n  }\n\n  function AudioBuffer() {\n      this.length = 0;\n      this.sampleRate = 0;\n      this.duration = 0;\n      this.numberOfChannels = 0;\n      this.getChannelData = function () {};\n      this.copyFromChannel = function () {};\n      this.copyToChannel = function () {};\n  }\n\n})();\n\n// Line 1: (function() {\n// This line creates a self-executing anonymous function to contain all of the code in the script. This creates a new scope, where variables can be declared without affecting the global scope. \n\n// Line 2: var lastTime = 0;\n// This line declares a variable called 'lastTime' and initializes it to 0.\n\n// Line 3: var vendors = ['ms', 'moz', 'webkit', 'o'];\n// This line declares a variable called 'vendors' and initializes it to an array of vendor prefixed strings.\n\n// Line 4: for(var x = 0; x < vendors.length && !window.AudioContext; ++x) {\n// This line creates a for loop that runs while 'x' is less than the length of the 'vendors' array and 'window.AudioContext' is not true.\n\n// Line 5: window.AudioContext = window[vendors[x]+'AudioContext'];\n// This line sets 'window.AudioContext' to the 'window' object property that corresponds to the current 'vendors' array item.\n\n// Line 6: if (!window.AudioContext) {\n// This line checks to see if 'window.AudioContext' is not true.\n\n// Line 7-54: This block of code creates a new 'AudioContext' constructor.\n\n// Line 55-82: This block of code creates the 'GainNode' constructor.\n\n// Line 83-110: This block of code creates the 'ScriptProcessor' constructor.\n\n// Line 111-138: This block of code creates the 'BufferSourceNode' constructor.\n\n// Line 139-166: This block of code creates the 'DelayNode' constructor.\n\n// Line 167-194: This block of code creates the 'Panner' constructor.\n\n// Line 195-222: This block of code creates the 'Analyser' constructor.\n\n// Line 223-250: This block of code creates the 'WaveShaper' constructor.\n\n// Line 251-278: This block of code creates the 'BiquadFilter' constructor.\n\n// Line 279-306: This block of code creates the 'IIRFilter' constructor.\n\n// Line 307-334: This block of code creates the 'Convolver' constructor.\n\n// Line 335-362: This block of code creates the 'ChannelSplitter' constructor.\n\n// Line 363-390: This block of code creates the 'ChannelMerger' constructor.\n\n// Line 391-418: This block of code creates the 'OscillatorNode' constructor.\n\n// Line 419-446: This block of code creates the 'PeriodicWave' constructor.\n\n// Line 447-474: This block of code creates the 'MediaElementSource' constructor.\n\n// Line 475-502: This block of code creates the 'MediaStreamSource' constructor.\n\n// Line 503-530: This block of code creates the 'MediaStreamDestination' constructor.\n\n// Line 531-558: This block of code creates the 'AudioBuffer' constructor.\n\n// Line 559: })();\n// This line closes the self-executing anonymous function.",
    useCase:
      "\n\nAudioContext is used in JavaScript to provide an interface for working with audio in web applications. It allows developers to create, manipulate, and play audio in the browser, allowing for more interactive audio experiences. AudioContext provides an API for creating audio sources, routing audio signals, and applying audio effects. It is also used for playback and recording of audio, as well as for synthesis of new audio.",
  },
  {
    code: "\n\nif (!window.Blob) {\n  var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n\n  window.Blob = function (parts, properties) {\n    parts = parts || [];\n    properties = properties || {};\n\n    try {\n      return new Blob(parts, properties);\n    } catch (e) {\n      var bb = new BlobBuilder();\n      parts.forEach(function(p) {\n        bb.append(p);\n      });\n\n      return bb.getBlob(properties.type);\n    }\n  };\n}",
    term: "Blob",
    explain:
      "\n\n// line 1: \n// If the window object does not have a Blob property, the code in this block will execute\n\n// line 2:\n// This line creates a variable called 'BlobBuilder' which stores the window.BlobBuilder, window.WebKitBlobBuilder, window.MozBlobBuilder, or window.MSBlobBuilder property.\n\n// line 3:\n// This line creates a new property in the window object called 'Blob', which is a function that takes two parameters, parts and properties.\n\n// line 4:\n// This line sets the parts parameter to an empty array if it is not defined.\n\n// line 5:\n// This line sets the properties parameter to an empty object if it is not defined.\n\n// line 6:\n// This line attempts to create a new Blob object using the parts and properties parameters.\n\n// line 7:\n// If the attempt to create a new Blob object fails, this catch statement will execute.\n\n// line 8:\n// This line creates a new BlobBuilder object and assigns it to the bb variable.\n\n// line 9:\n// This line calls the forEach method on the parts parameter, which will loop through each item in the array and execute a function.\n\n// line 10:\n// This line calls the append method on the bb object, which adds each item in the array to the BlobBuilder object.\n\n// line 11:\n// This line returns the Blob object created from the BlobBuilder object, using the type property of the properties parameter as the type.",
    useCase:
      "\n\nBlob is used in JavaScript to create immutable objects that can store large amounts of data. Blobs can be used to store large data such as images, audio, video, and other binary data. Blobs can also be used to store data in a structured format such as JSON or XML. Blob objects are also used to create objects that can be used in web applications such as images, audio, video, and other forms of data. Blobs are also used in browser-based applications to store large amounts of data that need to be sent to the server.",
  },
  {
    code: "\n\n// Polyfill for CSS.supports in Javascript\n\nconst cssSupports = (...args) => {\n\tconst len = args.length\n\tlet el = document.createElement('div')\n\tlet style = el.style\n\n\tlet result = true;\n\n\tif(len === 2) {\n\t\tif(typeof args[0] === 'string' && typeof args[1] === 'string') {\n\t\t\tstyle.setProperty(args[0], args[1])\n\t\t\tresult = window.getComputedStyle(el).getPropertyValue(args[0]);\n\t\t}\n\t}\n\telse if (len === 1) {\n\t\tif (typeof args[0] === 'string') {\n\t\t\treturn style[args[0]] !== undefined\n\t\t}\n\t\telse {\n\t\t\tlet supported = true;\n\n\t\t\tObject.keys(args[0]).forEach(prop => {\n\t\t\t\tstyle.setProperty(prop, args[0][prop])\n\t\t\t\tsupported = window.getComputedStyle(el).getPropertyValue(prop);\n\t\t\t})\n\t\t\t\n\t\t\tresult = supported\n\t\t}\n\t}\n\n\treturn result;\n}",
    term: "CSS.supports",
    explain:
      "\n\n// 1. const cssSupports = (...args) => {\n//    This line declares a constant variable called cssSupports and assigns it to a function that takes multiple arguments.\n\n// 2. let el = document.createElement('div')\n//    This line declares a variable called el and assigns it to a new div element, created with the createElement method.\n\n// 3. let style = el.style\n//    This line declares a variable called style and assigns it to the style property of the el variable, which is a div element.\n\n// 4. let result = true;\n//    This line declares a variable called result and assigns it to a boolean value of true.\n\n// 5. if(len === 2) {\n//    This line is an if statement that checks if the number of arguments passed to the function is equal to 2.\n\n// 6. if(typeof args[0] === 'string' && typeof args[1] === 'string') {\n//    This line is an if statement nested inside the previous if statement, which checks if the first and second arguments passed to the function are both strings.\n\n// 7. style.setProperty(args[0], args[1])\n//    This line sets the property of the style variable to the first and second arguments passed to the function.\n\n// 8. result = window.getComputedStyle(el).getPropertyValue(args[0]);\n//    This line assigns the variable result to the computed style of the el variable, which is a div element, using the getPropertyValue method and the first argument passed to the function.\n\n// 9. else if (len === 1) {\n//    This line is an else if statement that checks if the number of arguments passed to the function is equal to 1.\n\n// 10. if (typeof args[0] === 'string') {\n//    This line is an if statement nested inside the else if statement, which checks if the first argument passed to the function is a string.\n\n// 11. return style[args[0]] !== undefined\n//    This line returns a boolean value of true or false, depending on whether the value of the style variable, which is a div element, and the first argument passed to the function is undefined or not.\n\n// 12. else {\n//    This line is an else statement that is nested inside the else if statement.\n\n// 13. let supported = true;\n//    This line declares a variable called supported and assigns it to a boolean value of true.\n\n// 14. Object.keys(args[0]).forEach(prop => {\n//    This line uses the Object.keys method to loop through the first argument passed to the function and pass each key to the forEach method.\n\n// 15. style.setProperty(prop, args[0][prop])\n//    This line sets the property of the style variable to the key of the first argument passed to the function and the value of that key.\n\n// 16. supported = window.getComputedStyle(el).getPropertyValue(prop);\n//    This line assigns the variable supported to the computed style of the el variable, which is a div element, using the getPropertyValue method and the key of the first argument passed to the function.\n\n// 17. result = supported\n//    This line assigns the variable result to the value of the supported variable.\n\n// 18. return result;\n//    This line returns the value of the result variable.",
    useCase:
      "\n\nCSS.supports is used in Javascript to check if the current user's browser supports a specific CSS property and its associated value. This helps developers create websites and apps that will function correctly across different browsers. It also allows developers to provide different styles or functionality based on the user's browser.",
  },
  {
    code: "\n\n(function () {\n  if ( typeof window.CustomEvent === \"function\" ) return false;\n\n  function CustomEvent ( event, params ) {\n    params = params || { bubbles: false, cancelable: false, detail: undefined };\n    var evt = document.createEvent( 'CustomEvent' );\n    evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );\n    return evt;\n   }\n\n  CustomEvent.prototype = window.Event.prototype;\n\n  window.CustomEvent = CustomEvent;\n})();",
    term: "CustomEvent",
    explain:
      "\n\n1. (function () {...})(); \n// This is an immediately invoked function expression (IIFE). It allows us to use variables and functions without polluting the global scope.\n\n2. if ( typeof window.CustomEvent === \"function\" ) return false;\n// This checks to see if a function called CustomEvent exists in the global window scope. If it does, the function exits.\n\n3. function CustomEvent ( event, params ) {...}\n// This is a function declaration that takes two parameters, event and params.\n\n4. params = params || { bubbles: false, cancelable: false, detail: undefined };\n// This sets the params parameter to the given value, or if it is undefined, it sets it to an object with the given values for bubbles, cancelable, and detail.\n\n5. var evt = document.createEvent( 'CustomEvent' );\n// This creates a new event object called evt in the document object.\n\n6. evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );\n// This initializes the event object with the given parameters.\n\n7. return evt;\n// This returns the event object.\n\n8. CustomEvent.prototype = window.Event.prototype;\n// This sets the prototype of the CustomEvent function to the prototype of the window.Event function.\n\n9. window.CustomEvent = CustomEvent;\n// This sets the CustomEvent function as a property of the global window object.",
    useCase:
      "\n\nCustomEvent is used in Javascript to allow developers to create and trigger their own custom events. With CustomEvent, developers can define the name, type, and details of the event in order to handle it in their own unique way. This is especially useful when dealing with complex user interactions that need to be handled in a particular order. By creating a custom event, developers can ensure that the expected behavior is triggered and that the application remains consistent.",
  },
  {
    code: "\n\nif (typeof DOMRect === 'undefined' || DOMRect === null) {\n  class DOMRect {\n    constructor(x = 0, y = 0, width = 0, height = 0) {\n      this.x = x;\n      this.y = y;\n      this.width = width;\n      this.height = height;\n      this.top = this.y;\n      this.left = this.x;\n      this.right = this.x + this.width;\n      this.bottom = this.y + this.height;\n    }\n  }\n\n  window.DOMRect = DOMRect;\n}",
    term: "DOMRect",
    explain:
      "\n\n//Line 1: This line checks if the variable DOMRect is defined or if it is null. \n//Line 2: This line starts the DOMRect class. \n//Line 3: This line defines the constructor of the DOMRect class with initial values of 0 for x, y, width, and height. \n//Line 4-7: This lines set the x, y, width, and height values of the DOMRect class. \n//Line 8-11: This lines set the top, left, right, and bottom values of the DOMRect class. \n//Line 12: This line assigns the DOMRect class to the global window object.",
    useCase:
      "\n\nDOMRect is used in JavaScript to represent a rectangular area on the page. It is used to help compute the size and position of elements on the page, such as when calculating the position of an element relative to the viewport or when calculating the size of an element to determine how much space it occupies.",
  },
  {
    code: "\n\nif (!DOMRect.fromRect) {\n  DOMRect.fromRect = function (rect) {\n    return new DOMRect(rect.x, rect.y, rect.width, rect.height);\n  };\n}",
    term: "DOMRect.fromRect",
    explain:
      "\n\n// If the DOMRect object does not have a method called 'fromRect', create one.\n// The function takes a parameter 'rect', and uses it to create a new DOMRect object with the coordinates 'rect.x', 'rect.y', 'rect.width', and 'rect.height'.",
    useCase:
      "\n\nDOMRect.fromRect is used to create a DOMRect object from an object with properties that have the same names as the properties of DOMRect. This is useful for converting existing data structures into DOMRect objects so they can be used with the DOM. It is also helpful when passing data between different parts of a program, as it allows the data to be manipulated as a DOMRect object, rather than having to manually access each property.",
  },
  {
    code: "\n\nif (typeof DOMTokenList === 'undefined') {\n    (function (global) {\n        \"use strict\";\n        var DOMTokenList = function(el) {\n            Object.defineProperty(this, '_elem', { value: el });\n            var str = el.getAttribute('class') || '';\n            var classes = str.trim().split(/\\s+/);\n            for (var i = 0; i < classes.length; i++) {\n                Object.defineProperty(this, i, { value: classes[i] });\n            }\n            Object.defineProperty(this, 'length', { value: classes.length });\n        };\n        DOMTokenList.prototype = {\n            constructor: DOMTokenList,\n            item: function(index) {\n                return this[index] || null;\n            },\n            contains: function(token) {\n                for (var i = 0; i < this.length; i++) {\n                    if (this[i] === token) {\n                        return true;\n                    }\n                }\n                return false;\n            },\n            add: function() {\n                for (var i = 0; i < arguments.length; i++) {\n                    if (!this.contains(arguments[i])) {\n                        Object.defineProperty(this, this.length, {\n                            value: arguments[i]\n                        });\n                        this.length++;\n                    }\n                }\n                this._elem.setAttribute('class', [].slice.call(this).join(' '));\n            },\n            remove: function() {\n                for (var i = 0; i < arguments.length; i++) {\n                    for (var j = 0; j < this.length; j++) {\n                        if (this[j] === arguments[i]) {\n                            [].splice.call(this, j, 1);\n                            j--;\n                            this.length--;\n                        }\n                    }\n                }\n                this._elem.setAttribute('class', [].slice.call(this).join(' '));\n            },\n            toggle: function(token) {\n                if (this.contains(token)) {\n                    this.remove(token);\n                    return false;\n                } else {\n                    this.add(token);\n                    return true;\n                }\n            }\n        };\n        global.DOMTokenList = DOMTokenList;\n    })(window);\n}",
    term: "DOMTokenList",
    explain:
      "\n\n//line 1: if (typeof DOMTokenList === 'undefined') {\n//This line checks if the DOMTokenList is already defined or not. If it is not defined then the code inside the if block will be executed\n\n//line 2: (function (global) {\n//This line creates a self-invoking anonymous function with global as a parameter.\n\n//line 3: \"use strict\";\n//This line sets the JavaScript code to strict mode which helps to write secure code.\n\n//line 4: var DOMTokenList = function(el) {\n//This line creates a DOMTokenList function with el as a parameter.\n\n//line 5-8: Object.defineProperty(this, '_elem', { value: el });\n//These lines define a property called \"_elem\" with the value of el on the current object.\n\n//line 9: var str = el.getAttribute('class') || '';\n//This line gets the class attribute value of the element and assigns it to a variable called str. If the class attribute is not present then an empty string is assigned to str.\n\n//line 10: var classes = str.trim().split(/\\s+/);\n//This line trims the whitespaces in the str variable and splits the string into an array of classes.\n\n//line 11-13: for (var i = 0; i < classes.length; i++) {\n//This line is a for loop which iterates over each class in the classes array.\n\n//line 14-15: Object.defineProperty(this, i, { value: classes[i] });\n//These lines define a property with the index of the class in the classes array as the name and the value of the class as the value of the property.\n\n//line 16-17: Object.defineProperty(this, 'length', { value: classes.length });\n//These lines define a property called \"length\" with the value of the length of the classes array.\n\n//line 18-48: This is the definition of the DOMTokenList prototype.\n\n//line 49-55: global.DOMTokenList = DOMTokenList;\n//These lines assign the DOMTokenList function to the global object.\n\n//line 56: })(window);\n//This line invokes the anonymous function assigning the window object as the parameter.",
    useCase:
      "\n\nDOMTokenList is used in JavaScript to enable the manipulation of the class attribute of a DOM element. It provides methods to add, remove, and toggle the classes of a DOM element, which can be used to change the styling of the element. This is especially useful when creating dynamic web pages, as it allows elements to be styled based on user input.",
  },
  {
    code: "\n\nDOMTokenList.prototype[Symbol.iterator] = function() {\n  let i = 0;\n  const len = this.length;\n  const tokens = this.value;\n  return {\n    next() {\n      if (i < len) {\n        return {\n          done: false,\n          value: tokens[i++]\n        }\n      } else {\n        return {\n          done: true\n        }\n      }\n    }\n  }\n};",
    term: "DOMTokenList.prototype.@@iterator",
    explain:
      '\n\n// Line 1: This line is adding a new prototype method to the DOMTokenList class. The method is using the Symbol.iterator Symbol as its name.\n// Line 2: This line is declaring a variable called "i" and initializing it to 0.\n// Line 3: This line is declaring a variable called "len" and initializing it to the length of the DOMTokenList.\n// Line 4: This line is declaring a variable called "tokens" and initializing it to the value of the DOMTokenList.\n// Line 5-9: This is a return statement containing a function that takes no arguments and returns an object. The object contains two properties, "done" and "value", and their values are determined by the if statement. If the value of i is less than the value of len, the done property is set to false and the value property is set to the token at the current index. If i is not less than len, the done property is set to true. \n// Line 10: This line is the closing brace of the return statement.',
    useCase:
      "\n\nDOMTokenList.prototype.@@iterator is used in Javascript to provide an iterable interface for the DOMTokenList interface. This allows for iterating over the list of tokens in a DOMTokenList, which can be useful for looping through the list to perform operations. This is especially useful when working with HTML elements and manipulating their attributes.",
  },
  {
    code: '\n\nif ((typeof DOMTokenList !== "undefined") && !("forEach" in DOMTokenList.prototype)) {\n  DOMTokenList.prototype.forEach = function forEach(callback) {\n    for (var i = 0; i < this.length; i++) {\n      callback(this.item(i), i, this);\n    }\n  };\n}',
    term: "DOMTokenList.prototype.forEach",
    explain:
      '\n\n//This line checks if the DOMTokenList is defined and if the forEach method is not already a part of the DOMTokenList.prototype\nif ((typeof DOMTokenList !== "undefined") && !("forEach" in DOMTokenList.prototype)) {\n\n//This line creates the forEach method for the DOMTokenList.prototype\n  DOMTokenList.prototype.forEach = function forEach(callback) {\n\n//This line is the loop that iterates over the DOMTokenList\n    for (var i = 0; i < this.length; i++) {\n\n//This line calls the callback function for each item in the DOMTokenList\n      callback(this.item(i), i, this);\n    }\n  };\n\n//This line closes the if statement\n}',
    useCase:
      "\n\nDOMTokenList.prototype.forEach is used in Javascript to iterate over the list of tokens in a DOMTokenList object. It allows developers to perform a function on each item in the list, making it easy to manipulate the data. This can be used to filter out certain tokens, add new tokens, or do any other operation on the list.",
  },
  {
    code: "\n\nif (!('replace' in DOMTokenList.prototype)) {\n  DOMTokenList.prototype.replace = function (token, newToken) {\n    if (this.contains(token)) {\n      this.remove(token);\n      if (newToken) {\n        this.add(newToken);\n      }\n    }\n  };\n}",
    term: "DOMTokenList.prototype.replace",
    explain:
      "\n\n// This code checks to see if the 'replace' method is not present in the DOMTokenList prototype. \n// If 'replace' is not present, then the code defines a new 'replace' method on the prototype. \n// The new 'replace' method takes two parameters, token and newToken. \n// It then checks to see if the token is present in the list and if it is, it removes it and if there is a newToken provided, it adds it.",
    useCase:
      "\n\nDOMTokenList.prototype.replace is used in Javascript to replace an existing token with a new one. It is useful for updating the classList of an element by replacing an existing class with a new one. This method is also useful for manipulating HTML attributes such as rel, type, and media.",
  },
  {
    code: "\n\n// Polyfill for DataView\nif (!window.DataView) {\n  window.DataView = class DataView {\n    constructor(buffer, byteOffset = 0, byteLength = buffer.byteLength) {\n      this.buffer = buffer;\n      this.byteOffset = byteOffset;\n      this.byteLength = byteLength;\n    }\n    getInt8(byteOffset) {\n      return this._get(byteOffset, 1)[0];\n    }\n    getUint8(byteOffset) {\n      return this.getInt8(byteOffset) >>> 0;\n    }\n    getInt16(byteOffset, littleEndian) {\n      return this._get(byteOffset, 2, littleEndian)[0];\n    }\n    getUint16(byteOffset, littleEndian) {\n      return this.getInt16(byteOffset, littleEndian) >>> 0;\n    }\n    getInt32(byteOffset, littleEndian) {\n      return this._get(byteOffset, 4, littleEndian)[0];\n    }\n    getUint32(byteOffset, littleEndian) {\n      return this.getInt32(byteOffset, littleEndian) >>> 0;\n    }\n    getFloat32(byteOffset, littleEndian) {\n      return this._get(byteOffset, 4, littleEndian)[0];\n    }\n    getFloat64(byteOffset, littleEndian) {\n      return this._get(byteOffset, 8, littleEndian)[0];\n    }\n    setInt8(byteOffset, value) {\n      this._set(byteOffset, [value], 1);\n    }\n    setUint8(byteOffset, value) {\n      this.setInt8(byteOffset, value);\n    }\n    setInt16(byteOffset, value, littleEndian) {\n      this._set(byteOffset, [value], 2, littleEndian);\n    }\n    setUint16(byteOffset, value, littleEndian) {\n      this.setInt16(byteOffset, value, littleEndian);\n    }\n    setInt32(byteOffset, value, littleEndian) {\n      this._set(byteOffset, [value], 4, littleEndian);\n    }\n    setUint32(byteOffset, value, littleEndian) {\n      this.setInt32(byteOffset, value, littleEndian);\n    }\n    setFloat32(byteOffset, value, littleEndian) {\n      this._set(byteOffset, [value], 4, littleEndian);\n    }\n    setFloat64(byteOffset, value, littleEndian) {\n      this._set(byteOffset, [value], 8, littleEndian);\n    }\n    _get(byteOffset, size, littleEndian) {\n      if (byteOffset + size > this.byteLength) {\n        throw new RangeError('Index out of range');\n      }\n      const view = new Uint8Array(this.buffer, this.byteOffset + byteOffset, size);\n      const result = [0];\n      for (let i = 0; i < size; i++) {\n        result[0] += view[i] * Math.pow(2, 8 * (littleEndian ? size - i - 1 : i));\n      }\n      return result;\n    }\n    _set(byteOffset, values, size, littleEndian) {\n      if (byteOffset + size > this.byteLength) {\n        throw new RangeError('Index out of range');\n      }\n      const view = new Uint8Array(this.buffer, this.byteOffset + byteOffset, size);\n      for (let i = 0; i < size; i++) {\n        const factor = Math.pow(2, 8 * (littleEndian ? size - i - 1 : i));\n        view[i] = (values[0] / factor) & 0xff;\n      }\n    }\n  };\n}",
    term: "DataView",
    explain:
      "\n\n//This code is a Polyfill for DataView, which is a JavaScript type for representing a collection of data in a structured way. This code is setting up a class called DataView, which will contain methods for getting and setting data in the structured collection of data.\n\n// Line 1: This line is checking if window.DataView is defined, and if it isn't, then it will proceed to the code following this line. \n\n// Lines 2-29: This section of code is defining the class DataView. The constructor takes three parameters, buffer, byteOffset and byteLength. The class will also contain methods for getting and setting data, such as getInt8, getUint8, getInt16, getUint16, getInt32, getUint32, getFloat32, getFloat64, setInt8, setUint8, setInt16, setUint16, setInt32, setUint32, setFloat32, setFloat64.\n\n// Lines 30-60: This section defines the method _get which takes three parameters, byteOffset, size and littleEndian. It will also throw a RangeError when the byteOffset is out of range.\n\n// Lines 61-87: This section defines the method _set which takes four parameters, byteOffset, values, size and littleEndian. It will also throw a RangeError when the byteOffset is out of range.",
    useCase:
      "\n\nDataView is used in JavaScript to provide a low-level interface for reading and writing multiple number types in an ArrayBuffer, without having to worry about the platform's endianness. It allows developers to manipulate binary data in a consistent format, regardless of the platform. It also provides a way to access data stored in an ArrayBuffer without having to copy it into a new data structure.",
  },
  {
    code: "\n\nif (!Date.now) {\n  Date.now = function() {\n    return new Date().getTime();\n  };\n}",
    term: "Date.now",
    explain:
      "\n\n// Line 1: This sets up a conditional statement that checks if the Date.now function does not exist.\n// Line 2: If the Date.now function does not exist, this creates it as a function that returns the time since midnight of January 1, 1970 (in milliseconds). This is the standard JavaScript date format.",
    useCase:
      "\n\nDate.now() is used in Javascript to get the current timestamp in milliseconds since the Unix epoch, which is the number of milliseconds that have elapsed since January 1, 1970 00:00:00 UTC. This is useful for creating unique identifiers, measuring the time elapsed between events, and other related tasks.",
  },
  {
    code: "\n\nif (!Date.prototype.toISOString) {\n  Date.prototype.toISOString = function () {\n    Date.prototype.toISOString = function () {\n      var tzo = -this.getTimezoneOffset(),\n        dif = tzo >= 0 ? '+' : '-',\n        pad = function (num) {\n          var norm = Math.floor(Math.abs(num));\n          return (norm < 10 ? '0' : '') + norm;\n        };\n      return this.getFullYear() +\n        '-' + pad(this.getMonth() + 1) +\n        '-' + pad(this.getDate()) +\n        'T' + pad(this.getHours()) +\n        ':' + pad(this.getMinutes()) +\n        ':' + pad(this.getSeconds()) +\n        dif + pad(tzo / 60) +\n        ':' + pad(tzo % 60);\n    };\n  }\n}",
    term: "Date.prototype.toISOString",
    explain:
      "\n\n// This code checks if the Date.prototype.toISOString() method exists. If it does not exist, it will create a function to add it. \n// Line 1: If the Date.prototype.toISOString() method does not exist\n// Line 2: Add the Date.prototype.toISOString() method\n// Line 3: Get the timezone offset and determine if it is positive or negative\n// Line 4: Create a pad() function to get the hour, minutes and seconds\n// Line 5: Get the year\n// Line 6: Get the month \n// Line 7: Get the date\n// Line 8: Get the hour\n// Line 9: Get the minutes\n// Line 10: Get the seconds\n// Line 11: Get the timezone offset\n// Line 12: Get the minutes for the timezone offset\n// Line 13: Get the seconds for the timezone offset",
    useCase:
      "\n\nDate.prototype.toISOString is used in Javascript to produce a string representation of a Date object in ISO format, which is an international standard for representing dates and times. This format is especially useful for storing and sorting dates, as it is an unambiguous representation that can be easily parsed and compared to other dates. It is also useful for passing dates between different systems, as it is a widely recognized format.",
  },
  {
    code: "\n\nif (!Document) {\n  Document = function Document() {\n    this.nodeType = 9;\n    this.name = '#document';\n    this.childNodes = [];\n    this.childElementCount = 0;\n    this.children = [];\n    this.firstChild = null;\n    this.lastChild = null;\n    this.documentElement = null;\n\n    // Methods\n    Object.defineProperty(Document, 'createElement', {\n      value: function createElement(tagName) {\n        var element = new Element(tagName);\n        element.ownerDocument = this;\n        return element;\n      }\n    });\n\n    Object.defineProperty(Document, 'createTextNode', {\n      value: function createTextNode(text) {\n        var textNode = new Text(text);\n        textNode.ownerDocument = this;\n        return textNode;\n      }\n    });\n\n    Object.defineProperty(Document, 'createDocumentFragment', {\n      value: function createDocumentFragment() {\n        var documentFragment = new DocumentFragment();\n        documentFragment.ownerDocument = this;\n        return documentFragment;\n      }\n    });\n  };\n\n  // Classes\n  var Element = function Element(tagName) {\n    this.nodeType = 1;\n    this.tagName = tagName;\n    this.parentNode = null;\n    this.nextSibling = null;\n    this.previousSibling = null;\n    this.attributes = {};\n  };\n\n  var Text = function Text(text) {\n    this.nodeType = 3;\n    this.textContent = text;\n    this.parentNode = null;\n    this.nextSibling = null;\n    this.previousSibling = null;\n  };\n\n  var DocumentFragment = function DocumentFragment() {\n    this.nodeType = 11;\n    this.childNodes = [];\n    this.childElementCount = 0;\n    this.children = [];\n    this.firstChild = null;\n    this.lastChild = null;\n    this.parentNode = null;\n    this.nextSibling = null;\n    this.previousSibling = null;\n  };\n}",
    term: "Document",
    explain:
      '\n\n//This code is creating a JavaScript class that can be used to represent the DOM document.\n\n//if (!Document): Checks if "Document" is not defined.\n\n//Document = function Document(): If not defined, it creates a constructor function called "Document".\n\n//this.nodeType = 9: Sets the "nodeType" property of the Document object to 9.\n\n//this.name = \'#document\': Sets the "name" property of the Document object to \'#document\'.\n\n//this.childNodes = []: Sets the "childNodes" property of the Document object to an empty array.\n\n//this.childElementCount = 0: Sets the "childElementCount" property of the Document object to 0.\n\n//this.children = []; Sets the "children" property of the Document object to an empty array.\n\n//this.firstChild = null: Sets the "firstChild" property of the Document object to null.\n\n//this.lastChild = null: Sets the "lastChild" property of the Document object to null.\n\n//this.documentElement = null: Sets the "documentElement" property of the Document object to null.\n\n//Object.defineProperty(Document, \'createElement\', {value: function createElement(tagName) {...}: Creates a new "createElement" method on the Document object which will take a tag name as an argument and return an Element object with the given tag name.\n\n//Object.defineProperty(Document, \'createTextNode\', {value: function createTextNode(text) {...}: Creates a new "createTextNode" method on the Document object which will take a string of text as an argument and return a Text object with the given text.\n\n//Object.defineProperty(Document, \'createDocumentFragment\', {value: function createDocumentFragment() {...}: Creates a new "createDocumentFragment" method on the Document object which will return a DocumentFragment object.\n\n//var Element = function Element(tagName): Creates a constructor function called "Element" which will take a tag name as an argument.\n\n//this.nodeType = 1: Sets the "nodeType" property of the Element object to 1.\n\n//this.tagName = tagName: Sets the "tagName" property of the Element object to the given tag name.\n\n//this.parentNode = null: Sets the "parentNode" property of the Element object to null.\n\n//this.nextSibling = null: Sets the "nextSibling" property of the Element object to null.\n\n//this.previousSibling = null: Sets the "previousSibling" property of the Element object to null.\n\n//this.attributes = {}: Sets the "attributes" property of the Element object to an empty object.\n\n//var Text = function Text(text): Creates a constructor function called "Text" which will take a string of text as an argument.\n\n//this.nodeType = 3: Sets the "nodeType" property of the Text object to 3.\n\n//this.textContent = text: Sets the "textContent" property of the Text object to the given text.\n\n//this.parentNode = null: Sets the "parentNode" property of the Text object to null.\n\n//this.nextSibling = null: Sets the "nextSibling" property of the Text object to null.\n\n//this.previousSibling = null: Sets the "previousSibling" property of the Text object to null.\n\n//var DocumentFragment = function DocumentFragment(): Creates a constructor function called "DocumentFragment".\n\n//this.nodeType = 11: Sets the "nodeType" property of the DocumentFragment object to 11.\n\n//this.childNodes = []: Sets the "childNodes" property of the DocumentFragment object to an empty array.\n\n//this.childElementCount = 0: Sets the "childElementCount" property of the DocumentFragment object to 0.\n\n//this.children = []; Sets the "children" property of the DocumentFragment object to an empty array.\n\n//this.firstChild = null: Sets the "firstChild" property of the DocumentFragment object to null.\n\n//this.lastChild = null: Sets the "lastChild" property of the DocumentFragment object to null.\n\n//this.parentNode = null: Sets the "parentNode" property of the DocumentFragment object to null.\n\n//this.nextSibling = null: Sets the "nextSibling" property of the DocumentFragment object to null.\n\n//this.previousSibling = null: Sets the "previousSibling" property of the DocumentFragment object to null.',
    useCase:
      "\n\nDocument is used in Javascript to access and manipulate the content of HTML and XML documents. It provides methods and properties to interact with elements on the page, such as accessing and modifying the HTML or XML document's content, attributes, or styling. Document also provides methods to create new elements and add them to the document, as well as methods for deleting, replacing, or inserting elements.",
  },
  {
    code: '\n\n(function () {\n    if (typeof window.DocumentFragment === "undefined") {\n        window.DocumentFragment = function DocumentFragment() {\n            var element = document.createElement("div");\n            element._children = [];\n\n            element.appendChild = function (child) {\n                var l = this._children.length;\n                this._children[l] = child;\n                this.appendChild = function (child) {\n                    var l = this._children.length;\n                    this._children[l] = child;\n                    return child;\n                };\n                return child;\n            };\n\n            element.querySelectorAll = function (selector) {\n                var result = [];\n                var els;\n                for (var i = 0; i < this._children.length; i++) {\n                    els = this._children[i].querySelectorAll(selector);\n                    for (var j = 0; j < els.length; j++) {\n                        result.push(els[j]);\n                    }\n                }\n                return result;\n            };\n\n            element.querySelector = function (selector) {\n                for (var i = 0; i < this._children.length; i++) {\n                    var el = this._children[i].querySelector(selector);\n                    if (el) {\n                        return el;\n                    }\n                }\n                return null;\n            };\n\n            element.cloneNode = function (deep) {\n                if (deep) {\n                    var clone = document.createDocumentFragment();\n                    for (var i = 0; i < this._children.length; i++) {\n                        clone.appendChild(this._children[i].cloneNode(true));\n                    }\n                    return clone;\n                }\n                else {\n                    return this;\n                }\n            };\n\n            return element;\n        };\n    }\n})();',
    term: "DocumentFragment",
    explain:
      '\n\n//This code creates a polyfill for DocumentFragment if it is undefined in the browser. \n\n//(function () {\n//This line creates an anonymous function that is immediately invoked. \n\n//    if (typeof window.DocumentFragment === "undefined") {\n//This line checks if the window object has a property called DocumentFragment that is undefined. \n\n//        window.DocumentFragment = function DocumentFragment() {\n//This line creates a new property called DocumentFragment on window that is a function.\n\n//            var element = document.createElement("div");\n//This line creates a new variable called element that is an empty div.\n\n//            element._children = [];\n//This line creates a new array on the element variable called _children. \n\n//            element.appendChild = function (child) {\n//This line adds a method called appendChild to the element variable that takes one argument called child. \n\n//                var l = this._children.length;\n//This line creates a new variable called l that is set to the length of the _children array. \n\n//                this._children[l] = child;\n//This line sets the last index of the _children array to the argument passed in. \n\n//                this.appendChild = function (child) {\n//This line adds a method called appendChild to the element variable that takes one argument called child. \n\n//                    var l = this._children.length;\n//This line creates a new variable called l that is set to the length of the _children array. \n\n//                    this._children[l] = child;\n//This line sets the last index of the _children array to the argument passed in. \n\n//                    return child;\n//This line returns the child argument. \n\n//                };\n//This line closes the appendChild function. \n\n//                return child;\n//This line returns the child argument. \n\n//            };\n//This line closes the appendChild method. \n\n//            element.querySelectorAll = function (selector) {\n//This line adds a method called querySelectorAll to the element variable that takes one argument called selector. \n\n//                var result = [];\n//This line creates a new array called result. \n\n//                var els;\n//This line creates a new variable called els. \n\n//                for (var i = 0; i < this._children.length; i++) {\n//This line loop through the _children array. \n\n//                    els = this._children[i].querySelectorAll(selector);\n//This line sets the els variable to an array of elements that match the selector argument. \n\n//                    for (var j = 0; j < els.length; j++) {\n//This line loop through the els array. \n\n//                        result.push(els[j]);\n//This line adds each element to the result array. \n\n//                    }\n//This line closes the loop. \n\n//                }\n//This line closes the loop.\n\n//                return result;\n//This line returns the result array. \n\n//            };\n//This line closes the querySelectorAll method.\n\n//            element.querySelector = function (selector) {\n//This line adds a method called querySelector to the element variable that takes one argument called selector. \n\n//                for (var i = 0; i < this._children.length; i++) {\n//This line loop through the _children array. \n\n//                    var el = this._children[i].querySelector(selector);\n//This line sets the el variable to the element that matches the selector argument. \n\n//                    if (el) {\n//This line checks if the el variable is truthy. \n\n//                        return el;\n//This line returns the el variable. \n\n//                    }\n//This line closes the if statement. \n\n//                }\n//This line closes the loop. \n\n//                return null;\n//This line returns null. \n\n//            };\n//This line closes the querySelector method. \n\n//            element.cloneNode = function (deep) {\n//This line adds a method called cloneNode to the element variable that takes one argument called deep. \n\n//                if (deep) {\n//This line checks if the deep argument is truthy.\n\n//                    var clone = document.createDocumentFragment();\n//This line creates a new variable called clone that is set to a new document fragment. \n\n//                    for (var i = 0; i < this._children.length; i++) {\n//This line loop through the _children array. \n\n//                        clone.appendChild(this._children[i].cloneNode(true));\n//This line adds a clone of each element in the _children array to the clone variable. \n\n//                    }\n//This line closes the loop. \n\n//                    return clone;\n//This line returns the clone variable. \n\n//                }\n//This line closes the if statement. \n\n//                else {\n//This line runs if the deep argument is falsy. \n\n//                    return this;\n//This line returns the element variable. \n\n//                }\n//This line closes the else statement. \n\n//            };\n//This line closes the cloneNode method. \n\n//            return element;\n//This line returns the element variable. \n\n//        };\n//This line closes the DocumentFragment function. \n\n//    }\n//This line closes the if statement. \n\n//})();\n//This line closes the anonymous function and immediately invokes it.',
    useCase:
      "\n\nDocumentFragment is a lightweight, transient DOM node that can be used to hold multiple DOM nodes. It is a useful tool when building dynamic web pages, as it allows the user to group multiple nodes together and make a single insertion into the DOM tree. DocumentFragment is also useful when dealing with large DOM trees, as it reduces the amount of repainting and reflowing required when making multiple DOM changes. It can also be used to reduce the amount of memory used when making multiple DOM modifications, since the DocumentFragment itself is not part of the actual DOM tree.",
  },
  {
    code: "\n\nif (!DocumentFragment.prototype.append) {\n  DocumentFragment.prototype.append = function(node) {\n    this.appendChild(node);\n  };\n}",
    term: "DocumentFragment.prototype.append",
    explain:
      "\n\n// 1. if (!DocumentFragment.prototype.append) { \n//     This line checks if DocumentFragment.prototype object has an 'append' property. \n\n// 2. DocumentFragment.prototype.append = function(node) {\n//     If the 'append' property doesn't exist, this line adds an 'append' property to the DocumentFragment.prototype object which is a function that takes a parameter called 'node'\n\n// 3. this.appendChild(node);\n//     This line calls the appendChild method of the DocumentFragment.prototype object, passing in the 'node' parameter as an argument.",
    useCase:
      "\n\nDocumentFragment.prototype.append is used in Javascript to efficiently add elements to a DocumentFragment. It is an easier and more efficient way of adding DOM elements to a DocumentFragment than manually creating each element and appending it. DocumentFragment.prototype.append allows developers to quickly add multiple elements to a DocumentFragment, which can then be added to the DOM. This makes it easier to manipulate the DOM and also helps to reduce the amount of code that needs to be written.",
  },
  {
    code: "\n\nif (!DocumentFragment.prototype.hasOwnProperty('prepend')) {\n  DocumentFragment.prototype.prepend = function () {\n    const args = [].slice.call(arguments);\n    const firstChild = this.firstChild;\n\n    args.forEach((arg) => {\n      if (arg instanceof Node) {\n        this.insertBefore(arg, firstChild);\n      } else if (typeof arg === 'string' || typeof arg === 'number') {\n        const node = document.createTextNode(arg);\n        this.insertBefore(node, firstChild);\n      } else {\n        throw new Error(\n          `Error: DocumentFragment.prototype.prepend() only accepts instances of Node or strings`\n        );\n      }\n    });\n  };\n}",
    term: "DocumentFragment.prototype.prepend",
    explain:
      "\n\n// Line 1: This line checks if the DocumentFragment prototype does not have the property 'prepend'.\n// Line 2: If the DocumentFragment prototype does not have the property 'prepend', this line creates a function called 'prepend' which is attached to the DocumentFragment prototype.\n// Line 3: This line creates an array called 'args' that contains all of the arguments passed to the 'prepend' function.\n// Line 4: This line creates a variable called 'firstChild' that holds a reference to the first child of the DocumentFragment.\n// Line 5: This line uses the 'forEach' method to iterate over all of the items in the 'args' array.\n// Line 6: This line checks if the current item in the 'args' array is an instance of the Node class.\n// Line 7: If the item is an instance of the Node class, this line inserts the node before the 'firstChild' of the DocumentFragment.\n// Line 8: This line checks if the current item in the 'args' array is a string or a number.\n// Line 9: If the item is a string or a number, this line creates a TextNode with the provided argument and inserts it before the 'firstChild' of the DocumentFragment.\n// Line 10: If the item is neither a Node instance nor a string/number, this line throws an error.",
    useCase:
      "\n\nDocumentFragment.prototype.prepend is used in Javascript to allow for the insertion of multiple elements into the DOM at once. This can be useful for performance when making multiple changes, as the browser only needs to perform a single DOM update. Additionally, this method allows developers to insert elements into the DOM before the start of the document, which can be useful in certain scenarios.",
  },
  {
    code: "\n\nif ( typeof Element !== 'function' ) {\n  Element = function( name ) {\n    this.name = name;\n  }\n\n  Element.prototype.render = function(){\n    return `<${this.name}></${this.name}>`;\n  }\n}",
    term: "Element",
    explain:
      "\n\n//This code checks to see if the Element function has been defined.\n//If not, it creates a new Element function with a parameter of name. \n//It then sets the prototype of the Element function to a render function, \n//which returns a string of the HTML element with the name passed in from the parameter.",
    useCase:
      "\n\nElement is used in JavaScript to access and manipulate HTML elements on a page. It enables developers to interact with the page’s Document Object Model (DOM) to make changes to the page’s structure, style, and content. With Element, developers can access specific HTML elements, change their attributes, and add and remove elements from the page. Element makes it easy to create complex web page interactions and animations.",
  },
  {
    code: "\n\n// Element.prototype.after\nif (!Element.prototype.after) {\n  Element.prototype.after = function(newNode) {\n    let nextSibling = this.nextSibling;\n    let parent = this.parentNode;\n    if (nextSibling) {\n      parent.insertBefore(newNode, nextSibling);\n    } else {\n      parent.appendChild(newNode);\n    }\n  };\n}",
    term: "Element.prototype.after",
    explain:
      "\n\n//Line 1: This line is creating a new property of Element, called after.\n//Line 2: This line checks to see if the after property already exists, and if it does not, it executes the code in the block.\n//Line 3: This line creates a new function called after and sets it to the after property of Element.\n//Line 4: This line creates a new variable called nextSibling to store the element's next sibling.\n//Line 5: This line creates a new variable called parent to store the element's parent node.\n//Line 6: This line checks to see if there is a next sibling. If there is, it executes the code in the block.\n//Line 7: This line inserts the newNode, before the nextSibling.\n//Line 8: This line is the else statement for line 6. If there is not a next sibling, it executes the code in the block.\n//Line 9: This line appends the newNode to the parent node.",
    useCase:
      "\n\nElement.prototype.after is used in JavaScript to insert a node or an HTML string after a specified element. This is useful when an element needs to be dynamically added to the DOM after an existing element. This method allows developers to quickly and easily add new elements to the DOM without having to write cumbersome code to locate the desired element and then locate the element after it.",
  },
  {
    code: '\n\n(function () {\n  // Check if the browser supports Element.prototype.animate\n  if (!Element.prototype.animate) {\n    // If not, add the prototype\n    Element.prototype.animate = function (keyframe, options) {\n      // Check if the keyframe argument is valid\n      if (!keyframe || typeof keyframe !== "object") {\n        throw new TypeError("First argument must be a valid object")\n      }\n\n      // Check if the options argument is valid\n      if (options && typeof options !== "object") {\n        throw new TypeError("Second argument must be a valid object")\n      }\n\n      // Create an animation\n      let animation = this.animate([], keyframe, options)\n\n      // Monitor the animation and dispatch events\n      return new Promise((resolve, reject) => {\n        animation.addEventListener(\'finish\', resolve)\n        animation.addEventListener(\'cancel\', reject)\n      })\n    }\n  }\n})();',
    term: "Element.prototype.animate",
    explain:
      '\n\n// (function () {\n// This line of code creates an anonymous self-executing function, meaning it will run immediately when the script is executed.\n\n//   if (!Element.prototype.animate) {\n// This line of code checks if the Element.prototype.animate method exists. If it does not exist, it will be added.\n\n//     Element.prototype.animate = function (keyframe, options) {\n// This line of code adds the Element.prototype.animate method to the Element prototype.\n\n//       if (!keyframe || typeof keyframe !== "object") {\n// This line of code checks if the keyframe argument is valid. If it is not valid, it will throw an error.\n\n//         throw new TypeError("First argument must be a valid object")\n// This line of code will throw an error if the keyframe argument is not valid.\n\n//       if (options && typeof options !== "object") {\n// This line of code checks if the options argument is valid. If it is not valid, it will throw an error.\n\n//         throw new TypeError("Second argument must be a valid object")\n// This line of code will throw an error if the options argument is not valid.\n\n//       let animation = this.animate([], keyframe, options)\n// This line of code creates an animation using the provided keyframe and options arguments.\n\n//       return new Promise((resolve, reject) => {\n// This line of code returns a new Promise object which will either resolve or reject based on the outcome of the animation.\n\n//         animation.addEventListener(\'finish\', resolve)\n// This line of code adds an event listener that will resolve the Promise if the animation finishes successfully.\n\n//         animation.addEventListener(\'cancel\', reject)\n// This line of code adds an event listener that will reject the Promise if the animation is cancelled.\n\n//       })\n// This line of code closes the Promise object.\n\n//     }\n// This line of code closes the Element.prototype.animate method.\n\n//   }\n// This line of code closes the if statement.\n\n// })();\n// This line of code closes the anonymous self-executing function.',
    useCase:
      "\n\nElement.prototype.animate is used to animate HTML elements in Javascript. It allows for the animation of specific properties of an element, such as its size, position, color, or opacity. It is a powerful tool for creating interactive, dynamic, and animated web experiences. It also gives developers the ability to create highly-customizable animations with just a few lines of code.",
  },
  {
    code: '\n\nif (!Element.prototype.append) {\n  Element.prototype.append = function append(children) {\n    if (children == null) {\n      return;\n    }\n    if (typeof children === "string") {\n      this.insertAdjacentHTML("beforeend", children);\n    } else {\n      if (Array.isArray(children)) {\n        for (var i = 0; i < children.length; i++) {\n          this.append(children[i]);\n        }\n      } else {\n        this.appendChild(children);\n      }\n    }\n  };\n}',
    term: "Element.prototype.append",
    explain:
      "\n\n// Line 1: \n// This line checks to see if the append method already exists in the Element prototype. If it doesn't, the code inside the if statement will execute.\n\n// Line 2: \n// This line adds the append method to the Element prototype.\n\n// Line 3: \n// This line checks to see if the children argument passed to the append method is null. If it is, the code inside the if statement will execute, which is to return without doing anything.\n\n// Line 4: \n// This line checks to see if the children argument passed to the append method is a string. If it is, the code inside the if statement will execute, which is to insert the HTML into the element before the end.\n\n// Line 5: \n// This line checks to see if the children argument passed to the append method is an array. If it is, the code inside the if statement will execute, which is to loop through the array and append each element to the element.\n\n// Line 6: \n// This line is the else clause to the previous if statement. It will execute if the children argument passed to the append method is not an array. The code inside the if statement will execute, which is to append the child element to the element.",
    useCase:
      "\n\nElement.prototype.append is used in Javascript to add an element to the end of a parent element. This is useful for creating and manipulating a dynamic HTML structure. It can also be used to insert content from other sources, such as text nodes, HTML strings, and document fragments. By using Element.prototype.append, developers can quickly and easily add elements to the DOM without having to hard-code them into the HTML.",
  },
  {
    code: "\n\n// Create a function Element.prototype.before\nElement.prototype.before = function(newElement){\n    // Store the element before which newElement is to be inserted\n    let currentElement = this;\n\t\n    // If the element has a parent node\n    if (currentElement.parentNode) {\n        // Store the parent node\n        let parentNode = currentElement.parentNode;\n        \n        // If the element has a previous sibling\n        if (currentElement.previousSibling){\n            // Insert the newElement before the currentElement's previous sibling\n            parentNode.insertBefore(newElement, currentElement.previousSibling);\n        } else {\n            // Otherwise, insert the newElement at the beginning of the parentNode\n            parentNode.insertBefore(newElement, currentElement);\n        }\n    }\n};",
    term: "Element.prototype.before",
    explain:
      "\n\n// This code creates a function, Element.prototype.before, which inserts an element before the current element.\n\n// 1. Create a function Element.prototype.before: This line creates a function called Element.prototype.before which will be used to insert an element before the current element.\n\n// 2. let currentElement = this: This line stores the element before which the new element will be inserted.\n\n// 3. if (currentElement.parentNode): This line checks if the element has a parent node.\n\n// 4. let parentNode = currentElement.parentNode: This line stores the parent node of the current element.\n\n// 5. if (currentElement.previousSibling): This line checks if the element has a previous sibling.\n\n// 6. parentNode.insertBefore(newElement, currentElement.previousSibling): If the element has a previous sibling, this line inserts the new element before the current element's previous sibling.\n\n// 7. parentNode.insertBefore(newElement, currentElement): Otherwise, this line inserts the new element at the beginning of the parent node.",
    useCase:
      "\n\nElement.prototype.before is used in Javascript to insert a node before the specified element. This method can be used to add new elements before an existing element in the DOM tree without having to remove the existing element. This makes it easier and faster to update the DOM tree.",
  },
  {
    code: "\n\nif (!Element.prototype.classList) {\n    Element.prototype.classList = {\n        add: function (className) {\n            if (!this.className.includes(className)) {\n                this.className += ' ' + className;\n            }\n        },\n        remove: function (className) {\n            if (this.className.includes(className)) {\n                this.className = this.className.replace(className, '').trim();\n            }\n        },\n        toggle: function (className) {\n            if (this.className.includes(className)) {\n                this.className = this.className.replace(className, '').trim();\n            } else {\n                this.className += ' ' + className;\n            }\n        },\n        contains: function (className) {\n            return this.className.includes(className);\n        }\n    };\n}",
    term: "Element.prototype.classList",
    explain:
      "\n\n// Line 1: This line checks whether the Element.prototype.classList is available or not.\n// Line 2: If Element.prototype.classList is not available then it adds the classList object to the Element.prototype.\n// Line 3: This line adds the className to the Element.prototype.classList object if it does not present.\n// Line 4: This line removes the className from the Element.prototype.classList object if it is present.\n// Line 5: This line checks if the className is present in the Element.prototype.classList object and if it is present then it will remove the className from the list.\n// Line 6: This line checks if the className is present in the Element.prototype.classList object and if it is not present then it will add the className to the list.\n// Line 7: This line checks if the className is present in the Element.prototype.classList object and return a boolean value.",
    useCase:
      "\n\nElement.prototype.classList is used in Javascript to provide an easy way to access and manipulate the list of classes for an element. It allows developers to add, remove, toggle and check for the presence of classes on an element. This is useful for quickly changing the styles of an element by adding, removing or toggling a class. It helps to keep code clean and maintainable by avoiding the need to use string manipulation to access and modify the list of classes.",
  },
  {
    code: "\n\nif (!Element.prototype.cloneNode) {\n  Element.prototype.cloneNode = function (deep) {\n    let newClone = this.cloneNode.call(this, deep);\n\n    let attrs = this.attributes;\n    if (attrs) {\n      for (let i = 0; i < attrs.length; i++) {\n        let attr = attrs[i];\n        newClone.setAttribute(attr.name, attr.value);\n      }\n    }\n\n    return newClone;\n  };\n}",
    term: "Element.prototype.cloneNode",
    explain:
      "\n\n//Line 1: This line checks to see if the Element.prototype.cloneNode method is not defined.\n//Line 2: If the Element.prototype.cloneNode is not defined, this line creates the method and provides a function to clone the node.\n//Line 3: This line creates a new clone of the node using the cloneNode.call method.\n//Line 4: This line creates a variable to store the attributes of the node.\n//Line 5: This line checks to see if the node has any attributes.\n//Line 6: This line creates a loop to iterate through the attributes of the node.\n//Line 7: This line creates a variable to store a single attribute.\n//Line 8: This line sets the attribute of the new clone to the value of the attribute from the original node.\n//Line 9: This line returns the newly cloned node.",
    useCase:
      "\n\nElement.prototype.cloneNode is used in Javascript to create a duplicate of an existing element and its children. This allows developers to easily create copies of elements with all the same attributes, styles, and event handlers. It can also be used to quickly create multiple elements with the same properties without having to manually define each one. It is a useful tool for manipulating the DOM, creating custom elements, and reducing the amount of code required to achieve a given effect.",
  },
  {
    code: "\n\nif (window.Element && !Element.prototype.closest) {\n    // Element.prototype.closest\n    Element.prototype.closest = \n    function(s) {\n        var el = this;\n        var ancestor = this;\n        if (!document.documentElement.contains(el)) return null;\n        do {\n            if (ancestor.matches(s)) return ancestor;\n            ancestor = ancestor.parentElement;\n        } while (ancestor !== null); \n        return null;\n    };\n}",
    term: "Element.prototype.closest",
    explain:
      "\n\n// Line 1: This line checks if the window object has the Element constructor and if the Element prototype does not have the closest method. \n// Line 2: This line adds a closest method to the Element prototype.\n// Line 3: This line sets a variable el to the current element.\n// Line 4: This line sets a variable ancestor to the current element.\n// Line 5: This line checks if the document element does not contain the current element and returns null if it does not.\n// Line 6: This line loops through the ancestors of the current element and checks for a matching selector. If a match is found, it returns the ancestor.\n// Line 7: This line updates the ancestor to the parent element.\n// Line 8: This line checks if the ancestor is not null and continues looping until the ancestor is null.\n// Line 9: This line returns null if no matching selector is found.",
    useCase:
      "\n\nElement.prototype.closest() is used in Javascript to find the closest ancestor of the current element that matches the specified selector, including itself. This method is useful for traversing up the DOM tree to find the closest matching ancestor for a given element. It can be used in situations where you need to find the closest parent of an element that matches a certain criteria, such as a particular class, ID, or attribute.",
  },
  {
    code: "\n\nif (Element.prototype.dataset === undefined) {\n  Element.prototype.dataset = {};\n  Object.defineProperty(Element.prototype, 'dataset', {\n    get: function () {\n      let element = this;\n      let attributes = this.attributes;\n      let map = {};\n      for (let i = 0; i < attributes.length; i++) {\n        let attribute = attributes[i];\n        if (attribute.name.substring(0, 5) === 'data-') {\n          let key = attribute.name.substring(5);\n          let value = attribute.value;\n          map[key] = value;\n        }\n      }\n      Object.defineProperty(element, 'dataset', {\n        value: map,\n        writable: true,\n        enumerable: true\n      });\n      return map;\n    }\n  });\n}",
    term: "Element.prototype.dataset",
    explain:
      '\n\n// Line 1: This line checks if the Element.prototype.dataset property is undefined. \n// Line 2: If it is, it is set to an empty object. \n// Line 3: This line sets the Element.prototype.dataset property to a getter function. \n// Line 4: This declares a variable to store the element being tested.\n// Line 5: This line declares a variable to store the attributes of the element.\n// Line 6: This line declares a variable to store the map of data-* attributes. \n// Line 7-10: This loop iterates through the attributes and checks if the attribute name starts with "data-". If it does, it adds the data to the map.\n// Line 11-14: This line defines the dataset property on the element with the value of the map, and makes it writable and enumerable. \n// Line 15: This returns the map of data-* attributes.',
    useCase:
      "\n\nElement.prototype.dataset is used to allow developers to store custom data on DOM elements. It provides a simple way to access and manipulate that data, making it easier to create dynamic webpages and applications. This feature is especially useful when working with HTML5 data attributes, as it allows developers to store and access custom data in a structured way.",
  },
  {
    code: "\n\nif (!Element.prototype.getAttributeNames) {\n    Element.prototype.getAttributeNames = function () {\n        let attrs = [];\n        for (let i = 0; i < this.attributes.length; i++) {\n            attrs.push(this.attributes[i].name);\n        }\n        return attrs;\n    };\n}",
    term: "Element.prototype.getAttributeNames",
    explain:
      "\n\n// Line 1: This line checks if the Element prototype doesn't already have a getAttributeNames() function. \n// If it doesn't, the code inside the if statement will be executed.\n\n// Line 2: This line defines a new function called getAttributeNames() that will be added to the Element prototype. \n\n// Line 3: This line declares an empty array called attrs that will be used to store the names of the element's attributes.\n\n// Line 4: This line uses a for loop to loop through all of the element's attributes.\n\n// Line 5: This line adds the name of the current attribute to the attrs array.\n\n// Line 6: This line returns the attrs array when the loop is finished.\n\n// Line 7: This line closes the if statement.",
    useCase:
      "\n\nElement.prototype.getAttributeNames is used in JavaScript to retrieve a list of all the attribute names of an element. This is useful for finding out what attributes are available for a particular element, as well as for iterating through the list and retrieving each attribute's value. It can also be used to check whether a specific attribute is present on an element or not.",
  },
  {
    code: "\n\n/**\n * Polyfill for Element.prototype.inert\n */\n(() => {\n  if ('inert' in Object.getOwnPropertyDescriptors(Element.prototype)) {\n    return;\n  }\n\n  /**\n   * Sets the Inert property of the HTMLElement\n   */\n  Object.defineProperty(Element.prototype, 'inert', {\n    enumerable: true,\n    configurable: true,\n    get() {\n      return this.hasAttribute('inert');\n    },\n    set(val) {\n      if (val) {\n        this.setAttribute('inert', '');\n      } else {\n        this.removeAttribute('inert');\n      }\n    }\n  });\n})();",
    term: "Element.prototype.inert",
    explain:
      "\n\n// Line 1: This line declares a function that is immediately invoked. This is a polyfill for Element.prototype.inert, which is used to enable or disable the ability of an element to be interacted with.\n\n// Line 4: This line checks if the 'inert' property already exists in the Element.prototype object. If it does, the function returns and does nothing.\n\n// Line 9: This line uses the Object.defineProperty() method to define the 'inert' property on the Element.prototype object. \n\n// Line 10: This line sets the enumerability of the 'inert' property to true.\n\n// Line 11: This line sets the configurability of the 'inert' property to true.\n\n// Line 12: This line defines a getter method for the 'inert' property. This getter method checks if the element has an 'inert' attribute.\n\n// Line 16: This line defines a setter method for the 'inert' property. This setter method adds or removes the 'inert' attribute depending on the value passed to the property.",
    useCase:
      "\n\nElement.prototype.inert is used to make an element on a web page unresponsive to user input, such as mouse clicks, keystrokes, or focus. This can be useful for creating UI elements that are not meant to be interacted with, or for making certain elements inaccessible under certain circumstances.",
  },
  {
    code: "\n\nif (!Element.prototype.matches) {\n\tElement.prototype.matches = \n\t\tElement.prototype.matchesSelector || \n\t\tElement.prototype.mozMatchesSelector ||\n\t\tElement.prototype.msMatchesSelector || \n\t\tElement.prototype.oMatchesSelector || \n\t\tElement.prototype.webkitMatchesSelector ||\n\t\tfunction(s) {\n\t\t\tvar matches = (this.document || this.ownerDocument).querySelectorAll(s);\n\t\t\tvar i = matches.length;\n\t\t\twhile (--i >= 0 && matches.item(i) !== this) {}\n\t\t\treturn i > -1;            \n\t\t};\n}",
    term: "Element.prototype.matches",
    explain:
      "\n\n//If the Element.prototype object does not have a 'matches' property\n// then add the 'matches' property to the Element.prototype \n//and assign it a function that checks if the Element matches \n//one of the other Element prototype properties (matchesSelector, mozMatchesSelector, msMatchesSelector, oMatchesSelector, or webkitMatchesSelector)\n//If none of the other Element prototype properties match the specified selector, \n//query the document or the ownerDocument for any elements matching the selector \n// and check if the Element matches the queried elements. \n//If the Element does match one of the queried elements, return true, otherwise return false.",
    useCase:
      "\n\nElement.prototype.matches is used in Javascript to determine if an element matches a selector. This is especially useful when trying to identify if a particular element matches a given selector without having to manually check each of its attributes. It is also useful for finding elements within a given document that match a certain selector.",
  },
  {
    code: "\n\nif (!Element.prototype.nextElementSibling) {\n    Element.prototype.nextElementSibling = function() {\n        let currentElement = this;\n        do {\n            currentElement = currentElement.nextSibling;\n        } while (currentElement && currentElement.nodeType !== 1);\n        return currentElement;\n    }\n}",
    term: "Element.prototype.nextElementSibling",
    explain:
      "\n\n// if (!Element.prototype.nextElementSibling): This line checks to see if the nextElementSibling property already exists on the Element prototype.\n\n// Element.prototype.nextElementSibling = function(): If the property does not already exist, this line defines a new function named nextElementSibling on the Element prototype.\n\n// let currentElement = this: This line creates a local variable named currentElement and sets it equal to the current element.\n\n// do { currentElement = currentElement.nextSibling: This line runs a loop that assigns the value of the nextSibling property of the currentElement to the currentElement variable.\n\n// } while (currentElement && currentElement.nodeType !== 1): This line checks the condition that the currentElement is not null and the nodeType of the currentElement is not equal to 1.\n\n// return currentElement: This line returns the value of the currentElement variable.",
    useCase:
      "\n\nElement.prototype.nextElementSibling is used to access the next element sibling of the given element. This is useful for traversing the DOM and manipulating siblings. It can be used to add or remove classes, or insert and delete elements from sibling elements. It also makes it easier to select and manipulate elements in a parent element.",
  },
  {
    code: '\n\n// Create a placeholder property for Element prototype\nElement.prototype.placeholder = {};\n\n// Create a getter for placeholder property\nObject.defineProperty(Element.prototype, "placeholder", {\n  get: function() {\n    // Get placeholder value from element\'s data-placeholder attribute\n    var attrPlaceholder = this.getAttribute("data-placeholder");\n\n    // If data-placeholder attribute is present, return its value\n    if (attrPlaceholder) {\n      return attrPlaceholder;\n    }\n\n    // Otherwise, return empty string\n    return "";\n  },\n  // Make placeholder property read-only\n  configurable: false\n});',
    term: "Element.prototype.placeholder",
    explain:
      "\n\n// This code creates a placeholder property on the Element prototype, which is the base prototype for all HTML elements. It creates a getter for this property which retrieves the value of the element's data-placeholder attribute. If the data-placeholder attribute is present, its value is returned, otherwise an empty string is returned. Finally, the placeholder property is made read-only.",
    useCase:
      "\n\nElement.prototype.placeholder is used to set or return the value of the placeholder attribute of an element. It allows developers to set a predefined value in an input field, which can then be replaced with user input when the field is interacted with. This can be useful for prompting users to enter information in the correct format, such as a phone number or email address.",
  },
  {
    code: "\n\nif (!Element.prototype.prepend) {\n  Element.prototype.prepend = function(el) {\n    let firstChild = this.firstChild;\n    this.insertBefore(el, firstChild);\n  };\n}",
    term: "Element.prototype.prepend",
    explain:
      '\n\n//Line 1: This line checks to see if the Element.prototype object already has a method called "prepend". If it does not, the code block that follows will execute.\n\n//Line 2: A new function is added as a method to Element.prototype called "prepend". The argument "el" will be used when this method is called.\n\n//Line 3: A variable called "firstChild" is declared, and is assigned the value of the first child of the element that calls this method.\n\n//Line 4: The method "insertBefore" is called on the element that calls the "prepend" method. This method takes two arguments, the first being the element to be inserted and the second being the element that it should be inserted before. In this case, the "el" argument passed to the "prepend" method is inserted before the "firstChild" variable.',
    useCase:
      "\n\nElement.prototype.prepend is used in Javascript to insert a node as the first child of a specified element. This is useful for adding new elements to the beginning of a page or rearranging existing elements. It is also useful for adding text to existing elements, as it allows text to be added to the beginning of an element instead of only at the end.",
  },
  {
    code: "\n\nif (!Object.prototype.hasOwnProperty.call(Element.prototype, 'previousElementSibling')) {\n    Object.defineProperty(Element.prototype, 'previousElementSibling', {\n        get() {\n            let currentNode = this.previousSibling;\n            do {\n                if (currentNode.nodeType === 1) {\n                    return currentNode;\n                }\n                currentNode = currentNode.previousSibling;\n            }\n            while (currentNode);\n        }\n    });\n}",
    term: "Element.prototype.previousElementSibling",
    explain:
      "\n\n//Line 1: This line checks if the Object prototype does not have a property called 'previousElementSibling'. \n//Line 2: If it does not, then the Object.defineProperty method is used to define a new property on the Element prototype object called 'previousElementSibling' and set it as a getter.\n//Line 3: This line sets the currentNode variable to the previousSibling of the element.\n//Line 4: This line is a do-while loop that will run until the currentNode variable is falsey.\n//Line 5: This line checks if the nodeType of the currentNode is equal to 1. If it is, then it will return the currentNode.\n//Line 6: This line sets the currentNode variable to the previousSibling of the currentNode.\n//Line 7: This line closes the do-while loop. \n//Line 8: This line closes the Object.defineProperty method.\n//Line 9: This line closes the if statement.",
    useCase:
      "\n\nElement.prototype.previousElementSibling is used to access the element that immediately precedes the specified element in the same tree level. It is useful for manipulating the DOM, as it allows developers to quickly traverse the DOM tree and manipulate elements in a specific order.",
  },
  {
    code: "\n\nif (!Element.prototype.remove) {\n  Element.prototype.remove = function() {\n    if (this.parentElement) {\n      this.parentElement.removeChild(this);\n    }\n  };\n}",
    term: "Element.prototype.remove",
    explain:
      "\n\n// Line 1: This line checks to see if the Element prototype object does not have the remove method. \n// Line 2: If the Element prototype object does not have the remove method, this line adds a remove method to the Element prototype object. \n// Line 3: This line checks to see if the element has a parent element.\n// Line 4: If the element does have a parent element, this line removes the element from its parent element.",
    useCase:
      "\n\nElement.prototype.remove is used in Javascript to remove an element from the DOM (Document Object Model). It is a convenient way to remove elements from the DOM without having to search for them using other methods such as querySelector or getElementById.",
  },
  {
    code: "\n\nif (!Element.prototype.replaceWith) {\n  Element.prototype.replaceWith = function(newNode) {\n    this.parentNode.replaceChild(newNode, this);\n  };\n}",
    term: "Element.prototype.replaceWith",
    explain:
      "\n\n// Line 1: This line checks if the Element prototype already has a replaceWith function.\n// Line 2: If the Element prototype does not have a replaceWith function, a new one is created.\n// Line 3: This line defines the new replaceWith function created. It takes one argument, newNode, and replaces the current element with the newNode.\n// Line 4: This line calls the replaceChild function on the parentNode of the current element, and passes in the newNode and the current element as arguments.",
    useCase:
      "\n\nElement.prototype.replaceWith is used in Javascript to replace an element in the DOM with a new element. This is often used to update the content of a page without having to reload the entire page. It can also be used to replace an element in the DOM with an entirely different type of element, making it a powerful tool for transforming a page on the fly.",
  },
  {
    code: "\n\n//Create a polyfill of Element.prototype.scroll\nif (Element.prototype.scroll === undefined) {\n    Element.prototype.scroll = function(x, y) {\n        //Check that x and y are valid numbers\n        if (typeof x === 'number' && typeof y === 'number') {\n            if (this.nodeType === 1) {\n                this.scrollLeft = x;\n                this.scrollTop = y;\n            }\n        }\n    };\n}",
    term: "Element.prototype.scroll",
    explain:
      "\n\n//Line 1: \n//This line creates a polyfill of Element.prototype.scroll. A polyfill is a piece of code that provides the technology that is missing from the browser.\n\n//Line 2: \n//This line checks whether Element.prototype.scroll is undefined. If it is, then the code within the if statement is executed.\n\n//Line 3: \n//This line creates a new function called scroll, which takes two parameters, x and y.\n\n//Line 4: \n//This line checks whether the parameters x and y are valid numbers. If they are, then the code within the if statement is executed.\n\n//Line 5: \n//This line checks whether the element is a node type 1. If it is, then the code within the if statement is executed.\n\n//Line 6 & 7: \n//These lines set the scrollLeft and scrollTop properties of the element to the values of x and y, respectively.",
    useCase:
      "\n\nElement.prototype.scroll is used in Javascript to scroll the content of an element horizontally or vertically. This method can be used to quickly scroll an element to the top, bottom, left, or right of its scrollable area. Additionally, it can be used to scroll an element to a specific position or to scroll an element by a certain amount. This method is useful for creating smooth scrolling effects or for quickly adjusting the scroll position of an element.",
  },
  {
    code: "\n\nif (!Element.prototype.scrollBy) {\n  Element.prototype.scrollBy = function(x, y) {\n    this.scrollLeft += x;\n    this.scrollTop += y;\n  };\n}",
    term: "Element.prototype.scrollBy",
    explain:
      "\n\n// Line 1: This checks to see if the scrollBy method is already defined on the Element prototype. If not, the code inside the if statement will be executed.\n\n// Line 2: This defines a scrollBy method on the Element prototype.\n\n// Line 3: This sets the scrollLeft property of the element to what it was before plus the value of x.\n\n// Line 4: This sets the scrollTop property of the element to what it was before plus the value of y.",
    useCase:
      "\n\nElement.prototype.scrollBy is used in JavaScript to scroll an element by a specified number of pixels. It can be used to scroll the page by a certain number of pixels, or to scroll a particular element by a certain number of pixels. It can be used to create smooth scrolling animations or to automatically scroll an element into view. It can also be used to scroll an element to the top or bottom of its scrollable area.",
  },
  {
    code: "\n\nif (!Element.prototype.scrollIntoView) {\n  // Get the top-level document object\n  var d = window.document;\n  // determine the current scroll position\n  function scrollY() {\n    var y;\n    if (window.pageYOffset) y = window.pageYOffset;\n    else if (d.documentElement && d.documentElement.scrollTop) y = d.documentElement.scrollTop;\n    else if (d.body) y = d.body.scrollTop;\n    return y;\n  }\n  // determine the current horizontal scroll position\n  function scrollX() {\n    var x;\n    if (window.pageXOffset) x = window.pageXOffset;\n    else if (d.documentElement && d.documentElement.scrollLeft) x = d.documentElement.scrollLeft;\n    else if (d.body) x = d.body.scrollLeft;\n    return x;\n  }\n  // Scroll the document\n  Element.prototype.scrollIntoView = function(){\n    // the element's bounding rectangle\n    var rect = this.getBoundingClientRect();\n    // the base scroll position\n    var sx = scrollX();\n    var sy = scrollY();\n    // the current viewport size\n    var vw = window.innerWidth;\n    var vh = window.innerHeight;\n    // the element's size, relative to the viewport\n    var tw = rect.width;\n    var th = rect.height;\n    // the calculated target scroll position\n    var tx = sx + rect.left;\n    var ty = sy + rect.top;\n    // the threshold for when the element should be aligned to the top of the viewport\n    var thresh = th - vh;\n    // adjust the target scroll position if necessary\n    if (ty > sy + thresh) ty = sy + thresh;\n    if (tx + tw > sx + vw) tx = sx + vw - tw;\n    // scroll the element into view\n    window.scrollTo(tx, ty);\n  };\n}",
    term: "Element.prototype.scrollIntoView",
    explain:
      "\n\n//Line 1: This line checks if the scrollIntoView prototype method exists on the Element object. If it does not exist, it will create the method. \n//Line 2: This line stores the top-level document object in the d variable.\n//Line 3: This line creates a function that determines the current vertical scroll position. \n//Line 4: This line checks if the pageYOffset property of the window object is set. If it is, it stores the value in the y variable.\n//Line 5: This line checks if the documentElement property of the document object is set and if the scrollTop property of the documentElement is set. If both are set, it stores the value in the y variable.\n//Line 6: This line checks if the body property of the document object is set. If it is, it stores the value in the y variable.\n//Line 7: This line returns the value stored in the y variable.\n//Line 8: This line creates a function that determines the current horizontal scroll position. \n//Line 9: This line checks if the pageXOffset property of the window object is set. If it is, it stores the value in the x variable.\n//Line 10: This line checks if the documentElement property of the document object is set and if the scrollLeft property of the documentElement is set. If both are set, it stores the value in the x variable.\n//Line 11: This line checks if the body property of the document object is set. If it is, it stores the value in the x variable.\n//Line 12: This line returns the value stored in the x variable.\n//Line 13: This line creates the scrollIntoView method on the Element prototype.\n//Line 14: This line stores the bounding rectangle of the element in the rect variable.\n//Line 15: This line stores the current horizontal scroll position in the sx variable.\n//Line 16: This line stores the current vertical scroll position in the sy variable.\n//Line 17: This line stores the width of the current viewport in the vw variable.\n//Line 18: This line stores the height of the current viewport in the vh variable.\n//Line 19: This line stores the width of the element, relative to the viewport, in the tw variable.\n//Line 20: This line stores the height of the element, relative to the viewport, in the th variable.\n//Line 21: This line stores the calculated target scroll position in the tx variable.\n//Line 22: This line stores the calculated target scroll position in the ty variable.\n//Line 23: This line stores the threshold for when the element should be aligned to the top of the viewport in the thresh variable.\n//Line 24: This line checks if the ty variable is greater than the sy variable plus the thresh variable. If it is, it sets the ty variable to the sy variable plus the thresh variable.\n//Line 25: This line checks if the tx variable plus the tw variable is greater than the sx variable plus the vw variable. If it is, it sets the tx variable to the sx variable plus the vw variable minus the tw variable.\n//Line 26: This line scrolls the element into view by calling the window.scrollTo() method with the tx and ty variables as arguments.",
    useCase:
      "\n\nElement.prototype.scrollIntoView is used in JavaScript to bring the element into the visible area of the browser window. It is a useful method when you want to ensure that a particular element is visible on the page, and can be used to scroll the element into the viewport when it is not currently visible. It can also be used in combination with other JavaScript functions to create a smooth scrolling effect.",
  },
  {
    code: "\n\nif(!Element.prototype.toggleAttribute) {\n  Element.prototype.toggleAttribute = function (name, force){\n    var val = this.getAttribute(name);\n    if(force === undefined) {\n      if (val === null){\n        this.setAttribute(name, '');\n        return true;\n      } else {\n        this.removeAttribute(name);\n        return false;\n      }\n    } else if (force) {\n      this.setAttribute(name, '');\n      return true;\n    } else {\n      this.removeAttribute(name);\n      return false;\n    }\n  };\n}",
    term: "Element.prototype.toggleAttribute",
    explain:
      "\n\n//Line 1: \n// This line checks if the Element.prototype.toggleAttribute function has been defined. \n\n//Line 2: \n// If the function has not been defined, the function is defined in the following lines.\n\n//Line 3: \n// This line creates a variable called 'val' that stores the value of the attribute with the name passed in as an argument.\n\n//Line 4: \n// This line checks if no 'force' argument was passed in. \n\n//Line 5: \n// If no 'force' argument was passed in, and the value of the attribute was null, then the attribute is set to an empty string and the function returns true.\n\n//Line 6: \n// If no 'force' argument was passed in, and the value of the attribute was not null, then the attribute is removed and the function returns false.\n\n//Line 7: \n// If a 'force' argument was passed in, and it is true, then the attribute is set to an empty string and the function returns true.\n\n//Line 8: \n// If a 'force' argument was passed in, and it is false, then the attribute is removed and the function returns false.",
    useCase:
      "\n\nElement.prototype.toggleAttribute is used in Javascript to enable an element to be toggled between two states. This method allows developers to quickly and easily switch an element between two states without having to manually set each state. By using toggleAttribute, developers can create a one-click toggle for elements, such as a checkbox or a switch. This method is particularly useful when creating complex user interfaces, as it makes it easier to quickly toggle between two different states.",
  },
  {
    code: "\n\n// Polyfill for Event in Javascript\nif (!window.Event) {\n  function Event(event, params) {\n    params = params || { bubbles: false, cancelable: false, detail: null };\n    const evt = document.createEvent('Event');\n    evt.initEvent(event, params.bubbles, params.cancelable, params.detail);\n    return evt;\n  }\n  window.Event = Event;\n}",
    term: "Event",
    explain:
      "\n\n//This line of code checks if the window object has an Event property. If it does not, then it creates a custom Event function. \nif (!window.Event) {\n\n//This line of code defines the Event function and gives it two parameters, event and params. The params parameter is optional and allows for additional parameters such as bubbling and cancelable. \n  function Event(event, params) {\n\n//This line of code sets the default values for the params parameter.\n    params = params || { bubbles: false, cancelable: false, detail: null };\n\n//This line of code creates a new event object.\n    const evt = document.createEvent('Event');\n\n//This line of code initializes the event object with the provided parameters.\n    evt.initEvent(event, params.bubbles, params.cancelable, params.detail);\n\n//This line of code returns the newly created event.\n    return evt;\n  }\n\n//This line of code assigns the Event function to the window object.\n  window.Event = Event;\n}",
    useCase:
      "\n\nEvent is used in Javascript to allow code to be executed when certain types of events occur in the browser window, such as when a user clicks a button, scrolls the page, or moves the mouse over an element. By using Event, developers can create interactive web applications that respond to user actions.",
  },
  {
    code: '\n\nif (!("focusin" in Event.prototype)) {\n  Object.defineProperty(Event.prototype, "focusin", {\n    configurable: true,\n    enumerable: true,\n    get() {\n      return this._focusin || (this.type === "focusin");\n    },\n    set(value) {\n      Object.defineProperty(this, "_focusin", { value });\n    },\n  });\n}',
    term: "Event.focusin",
    explain:
      '\n\n// Line 1: \n// This line checks if "focusin" is not a property of Event.prototype. \n\n// Line 2: \n// This line defines a new property "focusin" on the Event.prototype object.\n\n// Line 3-7: \n// These lines set the configurable, enumerable, get, and set functions for the "focusin" property. The get function checks if the type property of the event is equal to "focusin". The set function sets the value of the _focusin property.',
    useCase:
      "\n\nEvent.focusin is used in Javascript to detect when an element receives focus. This event is typically used to trigger an action when the user focuses on a specific form element or other interactive element on a page. It can be used to customize the user experience by delaying or preventing certain actions until a user is focused on a specific element.",
  },
  {
    code: "\n\n(function () {\n  let hash = window.location.hash;\n  if (hash === '') {\n    hash = '#';\n  }\n  const oldHash = hash;\n  \n  let delay = 250;\n  let pollingInterval;\n  \n  window.onhashchange = function (e) {\n    if (oldHash !== e.newURL.split('#')[1]) {\n      let event = new Event('hashchange');\n      event.oldURL = oldHash;\n      event.newURL = e.newURL;\n      window.dispatchEvent(event);\n    }\n    oldHash = e.newURL.split('#')[1];\n  };\n  \n  const pollHash = function () {\n    if (window.location.hash !== hash) {\n      hash = window.location.hash;\n      window.onhashchange({\n        newURL: window.location.href\n      });\n    }\n  };\n  \n  pollHash();\n  pollingInterval = window.setInterval(pollHash, delay);\n  \n  if (typeof window.addEventListener === 'function') {\n    window.addEventListener('beforeunload', function () {\n      window.clearInterval(pollingInterval);\n    }, false);\n  }\n  \n})();",
    term: "Event.hashchange",
    explain:
      "\n\n//(function () {\n//  Creates an anonymous function \n\n//  let hash = window.location.hash;\n//  Sets the variable 'hash' to the current window location hash\n\n//  if (hash === '') {\n//    hash = '#';\n//  }\n//  Checks if the variable 'hash' is empty, if it is sets it to '#'\n\n//  const oldHash = hash;\n//  Sets the constant variable 'oldHash' to the value of 'hash'\n\n//  let delay = 250;\n//  let pollingInterval;\n//  Sets the variable 'delay' to 250 and creates an empty variable 'pollingInterval'\n\n//  window.onhashchange = function (e) {\n//    if (oldHash !== e.newURL.split('#')[1]) {\n//      let event = new Event('hashchange');\n//      event.oldURL = oldHash;\n//      event.newURL = e.newURL;\n//      window.dispatchEvent(event);\n//    }\n//    oldHash = e.newURL.split('#')[1];\n//  };\n//  Creates an event listener for when the hash is changed, checks to see if the old hash is different, if it is creates a new event called 'hashchange' and sets the oldURL and newURL to the old and new hash respectively.\n\n//  const pollHash = function () {\n//    if (window.location.hash !== hash) {\n//      hash = window.location.hash;\n//      window.onhashchange({\n//        newURL: window.location.href\n//      });\n//    }\n//  };\n//  Creates a function to poll the hash, checks to see if the window location hash is different from the hash variable, if it is sets the hash variable to the new window location hash and calls the onhashchange event listener.\n\n//  pollHash();\n//  pollingInterval = window.setInterval(pollHash, delay);\n//  Calls the pollHash function and sets the pollingInterval to call the pollHash function every 250 milliseconds.\n\n//  if (typeof window.addEventListener === 'function') {\n//    window.addEventListener('beforeunload', function () {\n//      window.clearInterval(pollingInterval);\n//    }, false);\n//  }\n//  Checks if the window has an addEventListener function, if it does sets an event listener for beforeunload and clears the pollingInterval\n\n//})();\n//End of the anonymous function",
    useCase:
      "\n\nEvent.hashchange is used in Javascript to detect changes to the part of a url that follows the # symbol. This can be used to detect when the user navigates to a different page within a single-page application, or when the user changes the parameters of the page, such as when a user changes the sorting of a list. It can also be used to detect when the user has manually changed the url hash.",
  },
  {
    code: "\n\n(function() {\n    function EventSource(url) {\n        this.url = url;\n        this.readyState = 0;\n        this.onopen = function(){};\n        this.onmessage = function() {};\n        this.onerror = function() {};\n        this.poll();\n    }\n    \n    EventSource.prototype.CONNECTING = 0;\n    EventSource.prototype.OPEN = 1;\n    EventSource.prototype.CLOSED = 2;\n    \n    EventSource.prototype.poll = function() {\n        var self = this;\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', this.url);\n        xhr.onreadystatechange = function() {\n            if (this.readyState === 4 && this.status === 200) {\n                self.readyState = self.OPEN;\n                self.onopen();\n                self.onmessage({\n                    data: this.responseText\n                });\n            }\n            else {\n                self.onerror();\n            }\n        };\n        xhr.send();\n    };\n    \n    window.EventSource = EventSource;\n})();",
    term: "EventSource",
    explain:
      "\n\n// (function(){}) is an immediately invoked function expression (IIFE), which is used to create a new scope in which variables declared inside of it are not visible outside of it.\n\n// function EventSource(url) { ... } is a function constructor which is used to create EventSource objects with a specific URL.\n\n// this.url = url; is a property which assigns the URL passed as an argument to the instance of the EventSource object.\n\n// this.readyState = 0; is a property which initializes the readyState property with 0.\n\n// this.onopen = function(){}; is a property which sets the onopen property to a function that does nothing.\n\n// this.onmessage = function() {}; is a property which sets the onmessage property to a function that does nothing.\n\n// this.onerror = function() {}; is a property which sets the onerror property to a function that does nothing.\n\n// this.poll(); is a method which is called immediately after the EventSource object is created.\n\n// EventSource.prototype.CONNECTING = 0; is a prototype property of the EventSource constructor which assigns the CONNECTING constant a value of 0.\n\n// EventSource.prototype.OPEN = 1; is a prototype property of the EventSource constructor which assigns the OPEN constant a value of 1.\n\n// EventSource.prototype.CLOSED = 2; is a prototype property of the EventSource constructor which assigns the CLOSED constant a value of 2.\n\n// EventSource.prototype.poll = function() { ... }; is a prototype method of the EventSource constructor which is used to poll the server for any new data.\n\n// window.EventSource = EventSource; is used to set the EventSource constructor as a global object in the window object.",
    useCase:
      "?\n\nEventSource is used in Javascript as a way to enable server-sent events (SSEs). This allows for a real-time connection between the client and server so that the server can push data to the client without the client having to request it. This can be used for notifications, updates, or even streaming data.",
  },
  {
    code: "\n\nconst Float32ArrayPolyfill = (function() {\n\n  return {\n    from(arrayLike) {\n      if (!arrayLike.length) return new Float32Array(0);\n      const array = new Float32Array(arrayLike.length);\n\n      for (let i = 0; i < array.length; i++) {\n        array[i] = arrayLike[i];\n      }\n\n      return array;\n    },\n    of(...items) {\n      return new Float32Array(items);\n    }\n  };\n})();",
    term: "Float32Array",
    explain:
      "\n\n//1. const Float32ArrayPolyfill = (function() {\n//this line declares a constant variable named Float32ArrayPolyfill and sets it equal to an anonymous function.\n\n//2. return {\n//this line returns an object literal\n\n//3. from(arrayLike) {\n//this line declares the from method which accepts an arrayLike argument\n\n//4. if (!arrayLike.length) return new Float32Array(0);\n// this line checks to see if the arrayLike argument has a length of 0, if it does it will return a new Float32Array object with a length of 0\n\n//5. const array = new Float32Array(arrayLike.length);\n//this line declares a variable named array and sets it equal to a new Float32Array object with a length equal to the arrayLike argument's length\n\n//6. for (let i = 0; i < array.length; i++) {\n//this line declares a for loop which starts at 0 and iterates until it is less than the length of the array\n\n//7. array[i] = arrayLike[i];\n//this line sets the value of the array at index i equal to the value of the arrayLike argument at index i\n\n//8. return array;\n//this line returns the array\n\n//9. of(...items) {\n//this line declares the of method which accepts multiple items as arguments\n\n//10. return new Float32Array(items);\n//this line returns a new Float32Array object with the items passed in as arguments",
    useCase:
      "\n\nFloat32Array is used in Javascript because it stores data more efficiently than other data types. It is used to represent numbers that have a decimal point, such as 3.14159. Float32Array is also faster to read and write than other data types. It is especially useful when dealing with large amounts of data, such as 3D graphics or scientific calculations.",
  },
  {
    code: "\n\nif (!window.Float64Array) {\n  window.Float64Array = function Float64Array() {\n    // Create an empty array.\n    let array = new Array(arguments.length);\n\n    // Copy the arguments into the array.\n    for (let i = 0; i < arguments.length; i++) {\n      array[i] = arguments[i];\n    }\n\n    // Add the raw method.\n    array.BYTES_PER_ELEMENT = 8;\n    array.get = (index) => {\n      return array[index];\n    };\n    array.set = (index, value) => {\n      array[index] = value;\n    };\n    array.subarray = (begin, end) => {\n      return array.slice(begin, end);\n    };\n    array.buffer = () => {\n      return array;\n    };\n    array.length = () => {\n      return array.length;\n    };\n\n    return array;\n  };\n}",
    term: "Float64Array",
    explain:
      "\n\n// Line 1: This checks if window.Float64Array is not defined.\n// Line 2: If window.Float64Array is not defined, then a new function is created and assigned to window.Float64Array.\n// Line 3: An empty array is created.\n// Line 4: This loop is used to copy the arguments that are passed to the Float64Array function into the array.\n// Line 5: The BYTES_PER_ELEMENT property is set to 8.\n// Line 6: This is a function that gets the value at a specific index in the array.\n// Line 7: This is a function that sets the value at a specific index in the array.\n// Line 8: This is a function that gets a subarray of the array.\n// Line 9: This is a function that returns the array.\n// Line 10: This is a function that returns the length of the array.\n// Line 11: The array is returned.",
    useCase:
      "\n\nFloat64Array is used in Javascript because it allows for more precise calculations with decimal numbers than the regular Number type, which is limited to a precision of 16 decimal digits. Float64Array is also faster for certain operations than the regular Number type, which makes it a better choice for applications that require more precision or speed.",
  },
  {
    code: "\n\nif (!Object.hasOwnProperty(\"name\")) {\n  Object.defineProperty(Function.prototype, 'name', {\n    get: function () {\n      var matches = this.toString().match(/^\\s*function\\s*([^\\s(]+)/);\n      return matches ? matches[1] : '';\n    }\n  });\n}",
    term: "Function.name",
    explain:
      '\n\n// Line 1: \n// This line checks if the Object class has a property called "name". If not, it will execute the code block.\n\n// Line 2: \n// This line adds a new property called "name" to the Function prototype.\n\n// Line 3: \n// This line creates a getter method that checks the current function\'s toString() value and tries to match it to a regular expression pattern. If the pattern matches, it will return the matched value. Otherwise, it will return an empty string.',
    useCase:
      '\n\nFunction.name is used in Javascript to retrieve a function\'s name as a string. It is useful for debugging purposes, or when writing code that needs to be able to determine the name of a given function. This is especially important when working with anonymous functions, as the Function.name property will return the assigned name of the function, instead of a generic string such as "anonymous".',
  },
  {
    code: "\n\nif (!Function.prototype.bind) {\n  Function.prototype.bind = function(oThis) {\n    if (typeof this !== 'function') {\n      // closest thing possible to the ECMAScript 5\n      // internal IsCallable function\n      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n    }\n \n    var aArgs   = Array.prototype.slice.call(arguments, 1),\n        fToBind = this,\n        fNOP    = function() {},\n        fBound  = function() {\n          return fToBind.apply(this instanceof fNOP\n                 ? this\n                 : oThis,\n                 aArgs.concat(Array.prototype.slice.call(arguments)));\n        };\n \n    // fNOP.prototype = this.prototype;\n    fBound.prototype = new fNOP();\n \n    return fBound;\n  };\n}",
    term: "Function.prototype.bind",
    explain:
      "\n\n1.  if (!Function.prototype.bind) { // The if statement checks if the bind method is not present in the Function prototype\n\n2.  Function.prototype.bind = function(oThis) { // If the bind method is not present, it is added to the Function prototype\n\n3.  if (typeof this !== 'function') { // Checks if the function is not a function\n\n4.  throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable'); // If the function is not a function, throw a TypeError\n\n5.  var aArgs   = Array.prototype.slice.call(arguments, 1), // Create a variable aArgs and assign it the arguments passed to the function\n\n6.  fToBind = this, // Create a variable fToBind and assign it to the current function\n\n7.  fNOP    = function() {}, // Create a variable fNOP and assign it an empty function\n\n8.  fBound  = function() { // Create a variable fBound and assign it a function\n\n9.    return fToBind.apply(this instanceof fNOP // The function will return the result of the function fToBind applied to the arguments\n\n10.      ? this // If the condition is true, this will be assigned to the fToBind function\n\n11.      : oThis, // If the condition is false, the argument oThis will be assigned to the fToBind function\n\n12.      aArgs.concat(Array.prototype.slice.call(arguments))); // Concatenate the aArgs variable to the arguments\n\n13.  fBound.prototype = new fNOP(); // Assign the prototype of fBound to a new instance of fNOP\n\n14.  return fBound; // Return the function fBound",
    useCase:
      "\n\nFunction.prototype.bind is used in JavaScript to create a new function that, when called, has its this keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function is called. This allows for a more concise way of specifying a function to be called with a certain context and set of arguments.",
  },
  {
    code: '\n\n// define function if not defined\nif (!Function.prototype.hasOwnProperty("name")) {\n    Object.defineProperty(Function.prototype, "name", {\n        get: function(){\n            if("name" in this){\n                return this.name;\n            }\n            var match = this.toString().match(/^\\s*function\\s*([^(]*)\\(/);\n            return match && match[1].length > 0 ? match[1] : "";\n        }\n    })\n}',
    term: "Function.prototype.name",
    explain:
      '\n\n// Line 1: This line checks to see if the Function.prototype already has a "name" property. \n// Line 2: If it does not, then a new property is defined on the Function.prototype. \n// Line 3: The "name" property is a getter, so when it is accessed, a function is called. \n// Line 4: This line checks to see if the "name" property has already been set on the function. \n// Line 5: If it has, then the value of the "name" property is returned. \n// Line 6: If not, then a regex is used to try to extract the name of the function from the definition. \n// Line 7: If a name was extracted, then that is returned, otherwise an empty string is returned.',
    useCase:
      "\n\nFunction.prototype.name is used in Javascript to provide a way to access the name of a function. This is especially useful for debugging or logging purposes, as it allows developers to easily see what function is being called or referenced. It can also be used to help ensure that functions have been named correctly, as a missing or incorrect name can be easily spotted and corrected.",
  },
  {
    code: "\n\nif (!HTMLCanvasElement.prototype.toBlob) {\n    Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {\n        value: function (callback, type, quality) {\n\n            var binStr = atob(this.toDataURL(type, quality).split(',')[1]);\n            var len = binStr.length;\n            var arr = new Uint8Array(len);\n\n            for (var i = 0; i < len; i++) {\n                arr[i] = binStr.charCodeAt(i);\n            }\n\n            callback(new Blob([arr], {type: type || 'image/png'}));\n        }\n    });\n}",
    term: "HTMLCanvasElement.prototype.toBlob",
    explain:
      "\n\n// Line 1: if (!HTMLCanvasElement.prototype.toBlob) \n// This line checks if the HTMLCanvasElement prototype already has a toBlob method defined. \n\n// Line 2: Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {\n// This line defines a new property to the HTMLCanvasElement prototype called 'toBlob'.\n\n// Line 3: value: function (callback, type, quality) {\n// This line defines the value of the toBlob property as a function.\n\n// Lines 4-7: var binStr = atob(this.toDataURL(type, quality).split(',')[1]);\n//             var len = binStr.length;\n//             var arr = new Uint8Array(len);\n\n//             for (var i = 0; i < len; i++) {\n//                 arr[i] = binStr.charCodeAt(i);\n//             }\n// These lines create a binary string from the dataURL of the HTMLCanvasElement, and then loop through the string, character by character, to create a Uint8Array.\n\n// Line 8: callback(new Blob([arr], {type: type || 'image/png'}));\n// This line creates a new Blob object from the Uint8Array and passes it to the callback function. The type of the Blob is either the type passed in as an argument or 'image/png' if no type is passed in.",
    useCase:
      "\n\nHTMLCanvasElement.prototype.toBlob is used to create a Blob object representing the image contained in the canvas. This can be used to easily save the canvas image as a file, or to upload the image data to a server. It can also be used to convert the canvas image data into a data URL, which can be used to embed the image into an HTML document.",
  },
  {
    code: '\n\nif(typeof HTMLDocument === "undefined") { \n    HTMLDocument = Document; \n}',
    term: "HTMLDocument",
    explain:
      "\n\n// This code checks to see if the HTMLDocument object is defined. If it is not defined, then it assigns the Document object to the HTMLDocument object. This is done so that the HTMLDocument object can be used in the code, even if it is not defined.",
    useCase:
      "\n\nHTMLDocument is used in JavaScript to provide an interface for interacting with HTML documents. It provides methods to access and manipulate elements of the page, such as retrieving elements by their ID, creating and appending elements to the DOM, and setting and getting attributes. HTMLDocument also provides a range of event handlers that can be used to respond to user interactions with the page, such as click events.",
  },
  {
    code: "\n\n// polyfill for HTMLInputElement.prototype.valueAsDate\n\nif (HTMLInputElement && !HTMLInputElement.prototype.valueAsDate) {\n    HTMLInputElement.prototype.valueAsDate = function() {\n        if (this.type !== 'date' || this.value == '') {\n            return null;\n        }\n        let dateString = this.value;\n        let parts = dateString.split('-');\n        let year = parseInt(parts[0], 10);\n        let month = parseInt(parts[1], 10) - 1;\n        let day = parseInt(parts[2], 10);\n        let date = new Date(year, month, day);\n        return date;\n    }\n}",
    term: "HTMLInputElement.prototype.valueAsDate",
    explain:
      "\n\n// Line 1:\n// This line declares a polyfill for the HTMLInputElement.prototype.valueAsDate function, which allows developers to get the value of an HTML date input element as a date object. \n\n// Line 2:\n// This line checks to see if the HTMLInputElement and HTMLInputElement.prototype.valueAsDate functions are defined. If they are not, then the code will execute. \n\n// Line 3:\n// This line creates a new function, which will act as the HTMLInputElement.prototype.valueAsDate function. \n\n// Line 4:\n// This line checks to see if the type of the input element is 'date' and if the value of the input element is not an empty string. \n\n// Line 5:\n// This line declares a variable that stores the value of the input element as a string.\n\n// Line 6:\n// This line splits the string into parts and stores the parts in an array. \n\n// Line 7:\n// This line parses the first element in the array as an integer. This is the year. \n\n// Line 8:\n// This line parses the second element in the array as an integer, subtracting 1 from the value. This is the month. \n\n// Line 9:\n// This line parses the third element in the array as an integer. This is the day. \n\n// Line 10:\n// This line creates a new Date object using the year, month, and day values. \n\n// Line 11:\n// This line returns the date object.",
    useCase:
      '\n\nHTMLInputElement.prototype.valueAsDate is used to get and set the value of an <input> element with type="date" as a Date object. This allows the user to select or enter a date in a consistent format, and the date can be easily manipulated and accessed in JavaScript. This feature is especially useful when working with form data, as it makes it easier to format the date and access it in a consistent way.',
  },
  {
    code: "\n\n/**\n * Polyfill HTMLPictureElement\n */\n\n(function() {\n  if (window.HTMLPictureElement) {\n    return;\n  }\n\n  let extend = function(src, dest) {\n    for (let key in src) {\n      if (src.hasOwnProperty(key)) {\n        dest[key] = src[key];\n      }\n    }\n  };\n\n  function HTMLPictureElement() {\n    this.__init();\n  }\n\n  HTMLPictureElement.prototype = {\n    __init: function() {\n      this.__imgList = [];\n    },\n    __addImg: function(el) {\n      this.__imgList.push(el);\n    },\n    __getBestImg: function() {\n      let bestImg;\n      let windowWidth = window.innerWidth;\n      for (let i = 0; i < this.__imgList.length; i++) {\n        let img = this.__imgList[i];\n        let breakpoint = img.getAttribute('data-breakpoint');\n        if (breakpoint) {\n          let minWidth = parseInt(breakpoint.split('-')[0]);\n          if (windowWidth > minWidth) {\n            bestImg = img;\n          }\n        }\n      }\n      return bestImg;\n    },\n    __updateSrc: function() {\n      let bestImg = this.__getBestImg();\n      if (bestImg) {\n        let src = bestImg.getAttribute('data-src');\n        this.__img.setAttribute('src', src);\n      }\n    },\n    setAttribute: function(name, value) {\n      if (name === 'src') {\n        this.__img = new Image();\n        this.__img.setAttribute('src', value);\n        this.appendChild(this.__img);\n      }\n    },\n    appendChild: function(el) {\n      if (el.nodeName === 'IMG') {\n        this.__addImg(el);\n        this.__updateSrc();\n      }\n    }\n  };\n\n  extend(HTMLElement.prototype, HTMLPictureElement.prototype);\n\n  window.HTMLPictureElement = HTMLPictureElement;\n  window.customElements.define('picture-element', HTMLPictureElement);\n})();",
    term: "HTMLPictureElement",
    explain:
      "\n\n//This code is a polyfill for the HTMLPictureElement, which allows developers to use the <picture> element in browsers that don't already support it.\n\n//Line 1: \n//This line declares a function that will polyfill HTMLPictureElement.\n\n//Line 2:\n//This line checks if the window object has a HTMLPictureElement property, and if it does, it returns. This is to make sure that the polyfill isn't executed if the browser already has support for HTMLPictureElement.\n\n//Line 3:\n//This line declares a function called extend that takes two parameters, src and dest. This function is used to extend the prototype of the HTMLPictureElement.\n\n//Line 4:\n//This line declares a function called HTMLPictureElement, which is the constructor for the polyfill.\n\n//Line 5:\n//This line assigns the prototype of HTMLPictureElement to an object literal containing functions for initialization, adding images, getting the best image, updating the source, setting attributes, and appending children.\n\n//Line 6-20:\n//These lines define the functions on the object literal. The __init function initializes the __imgList array. The __addImg function adds an element to the __imgList array. The __getBestImg function finds the best image based on the window's width. The __updateSrc function updates the source of the image. The setAttribute function sets the source attribute of the image. The appendChild function adds an image element to the __imgList array.\n\n//Line 21-23:\n//These lines extend the HTMLElement prototype with the functions defined on the HTMLPictureElement prototype.\n\n//Line 24-25:\n//These lines assign the HTMLPictureElement constructor to the window object and define the 'picture-element' custom HTML element.",
    useCase:
      "\n\nThe HTMLPictureElement is used in JavaScript to allow developers to create responsive images that can adjust to different screen sizes and resolution levels. It provides an easy way to create responsive images, allowing developers to define multiple sources for an image and having the browser choose the most appropriate source based on the available screen size and resolution. This helps reduce page loading times and allows images to be displayed more quickly and efficiently on different devices.",
  },
  {
    code: '\n\nif (HTMLSelectElement.prototype.selectedOptions === undefined) {\n\tHTMLSelectElement.prototype.selectedOptions = {\n\t\tget () {\n\t\t\treturn this.querySelectorAll("option:checked")\n\t\t}\n\t}\n}',
    term: "HTMLSelectElement.prototype.selectedOptions",
    explain:
      '\n\n//This line checks if the HTMLSelectElement.prototype.selectedOptions property is undefined. \nif (HTMLSelectElement.prototype.selectedOptions === undefined) {\n\n//If yes, it adds a getter function to the HTMLSelectElement.prototype.selectedOptions. \n\tHTMLSelectElement.prototype.selectedOptions = {\n\t\tget () {\n\n//The getter function returns a NodeList of all the checked options in the select element. \n\t\t\treturn this.querySelectorAll("option:checked")\n\t\t}\n\t}\n}',
    useCase:
      "\n\nHTMLSelectElement.prototype.selectedOptions is used in JavaScript to access the list of options in a select element that have been selected by the user. This is useful for reading user choices and providing feedback to the user about their selections.",
  },
  {
    code: "\n\nif(window.HTMLTemplateElement === undefined) {\n  window.HTMLTemplateElement = class HTMLTemplateElement {\n    constructor() {\n      this.content = document.createDocumentFragment();\n    }\n    get innerHTML() {\n      let container = document.createElement('div');\n      container.appendChild(this.content);\n      return container.innerHTML;\n    }\n    set innerHTML(htmlString) {\n      this.content.innerHTML = htmlString;\n    }\n  }\n}",
    term: "HTMLTemplateElement",
    explain:
      "\n\n// Line 1: This checks if the window object has a HTMLTemplateElement property. If it does not have one, the following code is executed. \n// Line 2: This creates a class called HTMLTemplateElement and assigns it to the window object.\n// Line 3: This is the constructor of the class, which creates a document fragment and assigns it to the content property of the class.\n// Line 4: This is a getter method, which returns the innerHTML of the document fragment.\n// Line 5: This creates a div element, appends the document fragment to it, and then returns the innerHTML of the div element.\n// Line 6: This is a setter method, which sets the innerHTML of the document fragment.",
    useCase:
      "\n\nHTMLTemplateElement is used in Javascript in order to provide a way to create an inert, easily-clonable DOM subtree. This allows developers to create a reusable template that can be used to quickly populate a portion of the DOM with structured data. This is helpful for creating and manipulating large amounts of HTML quickly, with minimal coding.",
  },
  {
    code: '\n\nif (typeof Int16Array === "undefined") {\n  window.Int16Array = function (length) {\n    let arr = [];\n\n    for (let i = 0; i < length; i++){\n      arr.push(0);\n    }\n\n    arr.BYTES_PER_ELEMENT = 2;\n    arr.buffer = new ArrayBuffer(length * arr.BYTES_PER_ELEMENT);\n\n    arr.set = function (array, offset) {\n      if (array instanceof Int16Array) {\n        offset = offset || 0;\n        for (let i = 0; i < array.length; i++) {\n          arr[i + offset] = array[i];\n        }\n      } else {\n        for (let i = 0; i < array.length; i++) {\n          arr[i] = array[i];\n        }\n      }\n    };\n\n    arr.get = function (index) {\n      if (index >= arr.length) {\n        throw `Index out of range: ${index}`;\n      }\n      return arr[index];\n    }\n\n    arr.subarray = function (begin, end) {\n      const start = Math.max(0, begin || 0);\n      const fin = Math.min(arr.length, end || arr.length);\n      const sub = [];\n      for (let i = start; i < fin; i++) {\n        sub.push(arr[i]);\n      }\n      return sub;\n    }\n\n    return arr;\n  }\n}',
    term: "Int16Array",
    explain:
      '\n\n// Line 1: This line checks if the type of Int16Array is "undefined". If so, it runs the code within the function.\n// Line 2: This line creates a function called Int16Array that takes in one parameter, length.\n// Line 3: This line creates an empty array called arr.\n// Line 4 - 8: This loop iterates through the length of the array and pushes a 0 value into each index of the array.\n// Line 9: This line assigns arr a BYTES_PER_ELEMENT property with a value of 2.\n// Line 10: This line assigns arr a buffer property with a value of an ArrayBuffer with a length of the array multiplied by the BYTES_PER_ELEMENT.\n// Line 11 - 16: This line creates a set method on the array, which takes in an array and an offset. If the array is an Int16Array, it sets the value of each index in the array to the value at the offset. If not, it sets each index of the array to the value of the corresponding index of the array.\n// Line 17 - 22: This line creates a get method on the array, which takes in an index. If the index is greater than or equal to the length of the array, it throws an error. Otherwise, it returns the value at the index.\n// Line 23 - 28: This line creates a subarray method on the array, which takes in a begin and end value. It creates a sub array with the values from the begin index to the end index and returns it.\n// Line 29: This line returns the array.',
    useCase:
      "\n\nInt16Array is used in Javascript because it is an array-like object which stores 16-bit signed integers and provides methods for manipulating the content of the array. This makes it ideal for storing and manipulating large amounts of data that require precise calculations and accuracy. It is also more efficient than other array types due to its smaller size, making it faster to access and process.",
  },
  {
    code: '\n\n//create a function for the Int32Array polyfill\nfunction Int32Array(length) {\n  //ensure the length is a valid number\n  if (Number.isInteger(length)) {\n    //create the array and set the length\n    this.array = new Array(length);\n    //loop through the array setting each element to 0\n    for (let i = 0; i < length; i++) {\n      this.array[i] = 0;\n    }\n  } else {\n    //if the length is not a valid number, throw an error\n    throw new Error("Length must be a valid number");\n  }\n}\n\n//create a method to get the length of the array\nInt32Array.prototype.getLength = function () {\n  return this.array.length;\n};\n\n//create a method to get the element at a given index\nInt32Array.prototype.getElementAtIndex = function (index) {\n  //ensure the index is a valid number\n  if (Number.isInteger(index)) {\n    //ensure the index is within the array\n    if (index >= 0 && index < this.array.length) {\n      return this.array[index];\n    } else {\n      //if the index is not within the array, throw an error\n      throw new Error("Index is out of bounds");\n    }\n  } else {\n    //if the index is not a valid number, throw an error\n    throw new Error("Index must be a valid number");\n  }\n};\n\n//create a method to set the element at a given index\nInt32Array.prototype.setElementAtIndex = function (index, val) {\n  //ensure the index is a valid number\n  if (Number.isInteger(index)) {\n    //ensure the index is within the array\n    if (index >= 0 && index < this.array.length) {\n      //ensure the value is a valid number\n      if (Number.isInteger(val)) {\n        //set the element at the given index to the given value\n        this.array[index] = val;\n      } else {\n        //if the value is not a valid number, throw an error\n        throw new Error("Value must be a valid number");\n      }\n    } else {\n      //if the index is not within the array, throw an error\n      throw new Error("Index is out of bounds");\n    }\n  } else {\n    //if the index is not a valid number, throw an error\n    throw new Error("Index must be a valid number");\n  }\n};',
    term: "Int32Array",
    explain:
      "\n\n//This code creates a function for a Int32Array polyfill. It ensures that the length is a valid number, creates an array with the given length, and sets each element to 0. It also creates methods to get the length of the array, get the element at a given index, and set the element at a given index. The functions ensure that the index and value are valid numbers, and that the index is within the array. If either of these conditions are not met, an error is thrown.",
    useCase:
      "\n\nInt32Array is used in Javascript to store 32-bit signed integers. It is useful for manipulating data in a more efficient way because it stores data in a fixed-length format, which reduces the amount of memory used and allows for faster access to data. It is also useful for performing mathematical operations on large sets of data, as the integers take up less space than other data types like strings.",
  },
  {
    code: "\n\n//creates a new Int8Array object\nconst Int8Array = function(length) {\n  let array = new Array(length);\n  for (let i = 0; i < length; i++) {\n    array[i] = 0;\n  }\n  array.BYTES_PER_ELEMENT = 1;\n  array.get = function(index) {\n    return this[index];\n  };\n  array.set = function(index, value) {\n    this[index] = value;\n  };\n  array.fill = function(value, start, end) {\n    let start_ = start || 0;\n    let end_ = end || this.length;\n    for (let i = start_; i < end_; i++) {\n      this[i] = value;\n    }\n  };\n  array.slice = function(start, end) {\n    let start_ = start || 0;\n    let end_ = end || this.length;\n    let result = new Int8Array(end_ - start_);\n    for (let i = start_; i < end_; i++) {\n      result[i - start_] = this[i];\n    }\n    return result;\n  };\n  return array;\n};",
    term: "Int8Array",
    explain:
      "\n\n// Line 1: \n// Creates a new Int8Array function which takes in an argument of length and returns an array. \n\n// Line 2: \n// Creates a new array of length specified by the argument. \n\n// Line 3: \n// Loops through the length of the array, setting the value of each index to 0. \n\n// Line 4: \n// Sets the BYTES_PER_ELEMENT property of the array to 1. \n\n// Line 5: \n// Creates a get method which takes in an index as an argument and returns the value stored at that index. \n\n// Line 6: \n// Creates a set method which takes in an index and a value as arguments and sets the value at the index to the value specified. \n\n// Line 7: \n// Creates a fill method which takes in a value, start, and end as arguments and sets the value of each index between the start and end arguments to the value specified. \n\n// Line 8: \n// Creates a slice method which takes in a start and end argument and returns a new Int8Array of the same length as the difference between the start and end arguments.",
    useCase:
      "\n\nInt8Array is used in Javascript because it is an array-like view of a typed array in which elements are stored in 8-bit signed integers. It is used for efficient storage, manipulation, and communication of typed arrays of data. Int8Array is a great choice for working with binary data, and it can be used to represent integers from -128 to 127. Additionally, Int8Array provides significant performance gains over other typed array types, as it requires less space than other types and can be more quickly processed by the JavaScript engine.",
  },
  {
    code: "\n\n// Create a class for the IntersectionObserver\nclass IntersectionObserver {\n  // Define constructor to set options\n  constructor(callback, options = {}) {\n    // Set observer options \n    this._callback = callback;\n    this._options = options;\n    // Add all the intersection targets to an array\n    this._targets = [];\n  }\n  \n  // Define add function to add targets\n  add(target) {\n    this._targets.push(target);\n  }\n  \n  // Define remove function to remove targets\n  remove(target) {\n    const index = this._targets.indexOf(target);\n    if (index > -1) {\n      this._targets.splice(index, 1);\n    }\n  }\n  \n  // Define observe function to observe targets\n  observe() {\n    // Get the intersection root\n    let root;\n    // If the option specifies a root\n    if (this._options.root) {\n      // Set the root\n      root = this._options.root;\n    } else {\n      // Set the root to the document\n      root = document;\n    }\n    \n    // For each of the targets\n    this._targets.forEach((target) => {\n      // Calculate the intersection of target and root\n      const intersection = this._calculateIntersection(target, root);\n      // Call the callback function\n      this._callback(target, intersection);\n    });\n  }\n  \n  // Define a function to calculate the intersection of two elements\n  _calculateIntersection(target, root) {\n    // Get the bounding box of target and root\n    const targetRect = target.getBoundingClientRect();\n    const rootRect = root.getBoundingClientRect();\n    // Set the intersection to false\n    let intersection = false;\n    // Calculate the intersection\n    if (targetRect.top <= rootRect.bottom &&\n      targetRect.right >= rootRect.left &&\n      targetRect.bottom >= rootRect.top &&\n      targetRect.left <= rootRect.right) {\n      intersection = true;\n    }\n    // Return the intersection\n    return intersection;\n  }\n}",
    term: "IntersectionObserver",
    explain:
      "\n\n// Line by Line Explanation:\n// 1. This line of code creates a class called IntersectionObserver.\n// 2. This line sets up a constructor for the class and sets the callback and options as parameters.\n// 3. This line creates an empty array for the targets.\n// 4. This line defines the add() function which adds a target to the array.\n// 5. This line defines the remove() function which removes a target from the array.\n// 6. This line defines the observe() function which calls the callback function with the target and intersection.\n// 7. This line checks if the option specifies a root, if so then sets the root to the root specified in the option. Otherwise, it sets the root to the document.\n// 8. This line loops over the targets and calls the _calculateIntersection() function with the target and root.\n// 9. This line gets the bounding boxes of the target and root.\n// 10. This line sets the intersection to false by default.\n// 11. This line checks if the target and root intersect and sets the intersection to true if they do.\n// 12. This line returns the intersection.",
    useCase:
      "\n\nIntersectionObserver is used in Javascript to detect when an element comes into or out of the viewport. This is useful for lazy loading images, infinite scrollers, tracking viewability, and more. It's a lightweight and efficient way to detect when an element is visible in the viewport, allowing developers to trigger actions based on the visibility of an element.",
  },
  {
    code: "\n\n(function() {\n  // Check if IntersectionObserver is supported\n  if ('IntersectionObserver' in window) {\n    return;\n  }\n\n  // Polyfill\n  function IntersectionObserverEntry(entry) {\n    this.time = Date.now();\n    this.boundingClientRect = entry.getBoundingClientRect();\n    this.intersectionRatio = entry.intersectionRatio;\n    this.intersectionRect = entry.intersectionRect;\n    this.isIntersecting = !!entry.intersectionRect;\n    this.rootBounds = entry.rootBounds;\n    this.target = entry.target;\n    this.name = '';\n  }\n\n  window.IntersectionObserverEntry = IntersectionObserverEntry;\n})();",
    term: "IntersectionObserverEntry",
    explain:
      "\n\n// Line 1: This creates an anonymous function which is immediately invoked\n// Line 2: This checks if the browser has native support for IntersectionObserver, if it does then it exits the function\n// Line 3: This creates a function called IntersectionObserverEntry which takes an entry parameter\n// Line 4-10: This sets all the properties of an IntersectionObserverEntry object\n// Line 11: This assigns the IntersectionObserverEntry function to window",
    useCase:
      "\n\nIntersectionObserverEntry is used in JavaScript to observe when an element or set of elements enter or exit the viewport of the browser. This can be used for tasks like lazy loading images or triggering animations when an element is visible on the page. It is an efficient way to detect when an element is visible in the viewport, without having to manually check for visibility on scroll or resize events.",
  },
  {
    code: "\n\n// Create a function that accepts two parameters:\n// - locale: which is the locale to use for formatting\n// - options: which is an object defining the options for the DateTimeFormat\nfunction polyfillIntlDateTimeFormat(locale, options) {\n  // Check if the locale parameter is a valid value\n  if (typeof locale !== 'string') {\n    throw new TypeError('locale must be a string');\n  }\n\n  // Check if the options parameter is a valid value\n  if (typeof options !== 'object' || options === null) {\n    throw new TypeError('options must be an object');\n  }\n\n  // Set the initial values for the variables\n  // that will be used in the function\n  let date = new Date();\n  let weekday = '';\n  let month = '';\n  let day = '';\n  let year = '';\n  let hour = '';\n  let minute = '';\n  let second = '';\n\n  // Get the weekday name, in the given locale\n  switch (locale) {\n    case 'en-US':\n      weekday = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][date.getDay()];\n      break;\n\n    case 'es-ES':\n      weekday = ['domingo', 'lunes', 'martes', 'miércoles', 'jueves', 'viernes', 'sábado'][date.getDay()];\n      break;\n\n    case 'fr-FR':\n      weekday = ['dimanche', 'lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi', 'samedi'][date.getDay()];\n      break;\n\n    // Add more locales here\n\n    default:\n      throw new TypeError('locale must be a valid value');\n  }\n\n  // Get the month name, in the given locale\n  switch (locale) {\n    case 'en-US':\n      month = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'][date.getMonth()];\n      break;\n\n    case 'es-ES':\n      month = ['enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio', 'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre'][date.getMonth()];\n      break;\n\n    case 'fr-FR':\n      month = ['janvier', 'février', 'mars', 'avril', 'mai', 'juin', 'juillet', 'août', 'septembre', 'octobre', 'novembre', 'décembre'][date.getMonth()];\n      break;\n\n    // Add more locales here\n\n    default:\n      throw new TypeError('locale must be a valid value');\n  }\n\n  // Get the day of the month\n  day = date.getDate();\n\n  // Get the year\n  year = date.getFullYear();\n\n  // Get the hour\n  hour = ('0' + date.getHours()).slice(-2);\n\n  // Get the minute\n  minute = ('0' + date.getMinutes()).slice(-2);\n\n  // Get the second\n  second = ('0' + date.getSeconds()).slice(-2);\n\n  // Construct the date string, using the options provided\n  let dateString = '';\n  if (options.weekday === 'short') {\n    dateString += weekday.slice(0, 3) + ', ';\n  } else if (options.weekday === 'long') {\n    dateString += weekday + ', ';\n  }\n\n  if (options.month === 'short') {\n    dateString += month.slice(0, 3) + ' ';\n  } else if (options.month === 'long') {\n    dateString += month + ' ';\n  }\n\n  if (options.day === 'numeric') {\n    dateString += day + ', ';\n  }\n\n  if (options.year === 'numeric') {\n    dateString += year + ' ';\n  }\n\n  if (options.hour === 'numeric') {\n    dateString += hour + ':';\n  }\n\n  if (options.minute === 'numeric') {\n    dateString += minute + ':';\n  }\n\n  if (options.second === 'numeric') {\n    dateString += second;\n  }\n\n  // Return the generated date string\n  return dateString;\n}",
    term: "Intl.DateTimeFormat",
    explain:
      "\n\n// This function creates a polyfill for the Intl.DateTimeFormat() function. It takes two parameters:\n// - locale: which is the locale to use for formatting\n// - options: which is an object defining the options for the DateTimeFormat.\n// It will then check if the locale and options parameters are valid values, before setting the initial values for the variables that will be used in the function. It will then use a switch statement to get the weekday and month names in the given locale. It will then get the day of the month, year, hour, minute and second, before constructing the date string using the options provided. Lastly, it will return the generated date string.",
    useCase:
      "\n\nIntl.DateTimeFormat is used in JavaScript to provide language-sensitive date and time formatting. It enables developers to format dates and times according to a user’s locale, allowing for more accurate and appropriate formatting of date and time values in web applications. It also allows for the formatting of date and time values according to a user’s preferred time zone and calendar, which can be particularly useful when dealing with international users.",
  },
  {
    code: "\n\n// Polyfill for Intl.DateTimeFormat.prototype.formatToParts\nIntl.DateTimeFormat.prototype.formatToParts = function(date) {\n\t// define the parts of a date\n\tconst parts = {\n\t\tyear: date.getFullYear(),\n\t\tmonth: date.getMonth(),\n\t\tday: date.getDate(),\n\t\thours: date.getHours(),\n\t\tminutes: date.getMinutes(),\n\t\tseconds: date.getSeconds(),\n\t\ttimezone: date.getTimezoneOffset()\n\t};\n\n\t// return the parts of the date\n\treturn parts; \n};",
    term: "Intl.DateTimeFormat.prototype.formatToParts",
    explain:
      "\n\n//This line of code is creating a polyfill for the Intl.DateTimeFormat.prototype.formatToParts function. This function will take in a date as an argument and will define the parts of the date (year, month, day, hours, minutes, seconds, and timezone). Finally, it will return the parts of the date.",
    useCase:
      "\n\nIntl.DateTimeFormat.prototype.formatToParts is used in Javascript to provide a way to format a Date object into a string that is organized into distinct parts. This is useful in situations where the individual parts of a date need to be accessed, such as when formatting a date for a specific locale or when displaying a date in a specific format. formatToParts can also be used to parse a string into its individual parts, which is useful when dealing with user input or data from an external source.",
  },
  {
    code: "\n\n// polyfill for Intl.DateTimeFormat.~timeZone.all\nif (!Intl.DateTimeFormat.prototype.timeZone) {\n  Intl.DateTimeFormat.prototype.timeZone = {\n    all: function(date) {\n      let tz = date.getTimezoneOffset() / 60;\n      let sign = tz > 0 ? '+' : '-';\n      let absTz = Math.abs(tz);\n      let hrs = Math.floor(absTz);\n      let min = ((absTz - hrs) * 60).toFixed(2).padStart(2, '0');\n      let timeZone = `UTC${sign}${hrs}:${min}`;\n      return timeZone;\n    }\n  };\n}",
    term: "Intl.DateTimeFormat.~timeZone.all",
    explain:
      "\n\n// Line 1:\n// This line is a polyfill (a code that replicates a feature found in some other browsers) for Intl.DateTimeFormat.~timeZone.all.\n\n// Line 2:\n// This line uses an if statement to check whether the Intl.DateTimeFormat.prototype.timeZone is already present. If it is not present, the code block below will be executed.\n\n// Line 3:\n// This line assigns an anonymous function to the Intl.DateTimeFormat.prototype.timeZone object. \n\n// Line 4:\n// This line declares a variable tz which is equal to the getTimezoneOffset() value divided by 60. It is used to get the timezone offset in hours.\n\n// Line 5:\n// This line declares a variable sign which is either '+' or '-' depending on the value of tz.\n\n// Line 6:\n// This line declares a variable absTz which is equal to the absolute value of tz.\n\n// Line 7:\n// This line declares a variable hrs which is equal to the floor value of absTz.\n\n// Line 8:\n// This line declares a variable min which is equal to the decimal part of absTz multiplied by 60 and it is padded with 0s to make it two digits.\n\n// Line 9:\n// This line declares a variable timeZone which is equal to the UTC timezone string with the sign and hrs and min variables.\n\n// Line 10:\n// This line returns the timeZone variable.",
    useCase:
      "\n\nIntl.DateTimeFormat.timeZone.all is used in Javascript to access the list of all available time zones in the International DateTimeFormat API. This list can be used to format and display dates and times in the desired time zone. This helps to ensure that dates and times are presented in a consistent manner across different time zones and locales.",
  },
  {
    code: "\n\nif (!Intl.DateTimeFormat || !Intl.DateTimeFormat.prototype.timeZone) {\n  Intl.DateTimeFormat.prototype.timeZone = {\n    golden: {\n      get longName() {\n        const offset = -25200;\n        const hours = Math.trunc(offset / 3600);\n        const minutes = Math.abs(offset % 3600);\n        return `GMT${hours < 0 ? '-' : '+'}${Math.abs(hours)}:${minutes < 10 ? '0' : ''}${minutes}`;\n      },\n      get shortName() { \n        return 'MST';\n      }\n    }\n  };\n}",
    term: "Intl.DateTimeFormat.~timeZone.golden",
    explain:
      "\n\n//Line 1: This line checks if the Intl.DateTimeFormat and Intl.DateTimeFormat.prototype.timeZone exist. If they don't it will go to the next line. \n\n//Line 2: This line adds the timeZone object to the DateTimeFormat prototype. \n\n//Line 3: This line creates a longName property to the timeZone object, which is a function. \n\n//Line 4: This line creates a variable called offset to store the time difference between the current time and the time in the golden time zone. \n\n//Line 5: This line creates a variable called hours which stores the number of hours in the offset variable. \n\n//Line 6: This line creates a variable called minutes which stores the number of minutes in the offset variable. \n\n//Line 7: This line returns a string with the GMT time for the golden time zone based on the offset variable. \n\n//Line 8: This line creates a shortName property to the timeZone object, which is a function. \n\n//Line 9: This line returns the short name for the golden time zone. \n\n//Line 10: This line closes the timeZone object. \n\n//Line 11: This line closes the if statement.",
    useCase:
      "\n\nIntl.DateTimeFormat.~timeZone.golden is used in JavaScript to format dates and times according to the user's time zone. This helps ensure that dates and times are displayed accurately for the user, regardless of where in the world they are located. This feature is especially useful for applications that are accessed by users from different parts of the world.",
  },
  {
    code: "\n\nif (!Intl.DisplayNames) {\n    Intl.DisplayNames = class {\n        constructor(locales, options) {\n            this.locale = locales;\n            this.type = options.type;\n            this.fallback = options.fallback;\n        }\n\n        of(code) {\n            //implementation\n            return code;\n        }\n    }\n}",
    term: "Intl.DisplayNames",
    explain:
      "\n\n// Line 1:\n// This line checks if the Intl.DisplayNames object already exists. If it does not, the code will run the rest of the code.\n\n// Line 2:\n// This line creates the Intl.DisplayNames object.\n\n// Line 3:\n// This line defines a constructor for the Intl.DisplayNames object. The constructor takes 2 parameters: 'locales' and 'options'.\n\n// Line 4:\n// This line sets the 'locale' property of the Intl.DisplayNames object to the 'locales' parameter.\n\n// Line 5:\n// This line sets the 'type' property of the Intl.DisplayNames object to the 'options.type' parameter.\n\n// Line 6:\n// This line sets the 'fallback' property of the Intl.DisplayNames object to the 'options.fallback' parameter.\n\n// Line 8:\n// This line defines a function for the Intl.DisplayNames object called 'of'. This function takes one parameter, 'code'. \n\n// Line 9:\n// This line defines the implementation of the 'of' function. It returns the 'code' parameter.",
    useCase:
      "\n\nIntl.DisplayNames is used in Javascript to provide an interface for accessing localized names for languages, scripts, regions, currencies, and timezones. It allows developers to access localized names of these elements in a user's locale, which is essential for creating a localized user experience.",
  },
  {
    code: '\n\nif (!Intl.ListFormat) {\n    Intl.ListFormat = class {\n        constructor(locales, options) {\n            this.locales = locales;\n            this.options = options;\n        }\n\n        format(list) {\n            let formattedString = "";\n            let lastItem = list.pop();\n            list.forEach(item => {\n                formattedString += `${item}, `;\n            });\n            if (list.length > 0) {\n                formattedString += `${this.options.conjuction} `;\n            }\n            formattedString += lastItem;\n            return formattedString;\n        }\n    }\n}',
    term: "Intl.ListFormat",
    explain:
      '\n\n1. "if (!Intl.ListFormat)" - This line is a conditional statement checking if the Intl.ListFormat property is not true. Intl.ListFormat is an internationalization API that formats lists according to the locale and options provided.\n\n2. "Intl.ListFormat = class" - This line creates a class for the Intl.ListFormat object.\n\n3. "constructor(locales, options)" - This is the constructor for the class. It takes two parameters, locales and options, which will be used to format the list according to the locale and options provided.\n\n4. "format(list)" - This is the method for formatting the list. It takes a list as a parameter, and returns a formatted string.\n\n5. "let formattedString = """ - This line defines a variable to store the formatted string.\n\n6. "let lastItem = list.pop()" - This line removes the last item from the list and stores it in a variable.\n\n7. "list.forEach(item => {" - This line iterates through the list and appends each item to the formatted string.\n\n8. "if (list.length > 0)" - This line checks if the list has more than one item, and if so, adds a conjunction to the formatted string.\n\n9. "formattedString += lastItem" - This line adds the last item to the formatted string.\n\n10. "return formattedString" - This line returns the formatted string.',
    useCase:
      "\n\nIntl.ListFormat is used in Javascript to format lists of items in a language-sensitive way. It takes an array of items and returns a localized string that can be used to display the list of items. It also allows developers to customize the output string in a variety of ways, including specifying the delimiter, the style of the output string, and the order of the items. Intl.ListFormat is especially useful when dealing with multilingual applications that need to display lists of items in different languages.",
  },
  {
    code: '\n\nif(!Intl.Locale){\n  Intl.Locale = function(locale) {\n    this.localeString = locale;\n  }\n  \n  Intl.Locale.prototype.getLanguage = function () {\n    return this.localeString.substring(0,2);\n  };\n  \n  Intl.Locale.prototype.getScript = function () {\n    if(this.localeString.length > 2 && this.localeString[2] === "-"){\n      return this.localeString.substr(3,4); \n    }\n    return "";\n  };\n  \n  Intl.Locale.prototype.getRegion = function () {\n    if(this.localeString.length > 5 && this.localeString[5] === "-"){\n      return this.localeString.substr(6,2); \n    }\n    return "";\n  };\n  \n  Intl.Locale.prototype.getVariant = function () {\n    if(this.localeString.length > 8 && this.localeString[8] === "-"){\n      return this.localeString.substr(9); \n    }\n    return "";\n  };\n  \n  Intl.Locale.prototype.toString = function () {\n    return this.localeString;\n  };\n}',
    term: "Intl.Locale",
    explain:
      "\n\n// This code creates an Intl.Locale constructor, which is used to create a Locale object that can be used to get the language, script, region and variant of a locale string. \n// Line 1: checks if Intl.Locale is defined. \n// Line 2: defines Intl.Locale constructor, which takes a locale string as a parameter. \n// Line 3: defines a getLanguage() method which returns the first two letters of the locale string.\n// Line 4: defines a getScript() method which returns the 4 letters after the second dash in the locale string.\n// Line 5: defines a getRegion() method which returns the 2 letters after the fifth dash in the locale string. \n// Line 6: defines a getVariant() method which returns the letters after the eighth dash in the locale string. \n// Line 7: defines a toString() method which returns the locale string.",
    useCase:
      "\n\nIntl.Locale is used in Javascript to provide language-sensitive functions for formatting data such as dates, numbers, and currencies. It is a powerful tool for developers to create applications that can be used in multiple languages. It also allows developers to manage different regional settings and formatting conventions. By using Intl.Locale, developers can ensure that their applications are compliant with international standards and can be used in any language.",
  },
  {
    code: "\n\nconst IntlNumberFormat = (locales, options) => {\n  const isObject = (obj) => {\n    return Object.prototype.toString.call(obj) === '[object Object]';\n  };\n  const isString = (str) => {\n    return typeof str === 'string';\n  };\n\n  // Get locale data\n  const localeData = (locale) => {\n    const {\n      decimal,\n      group,\n      negative,\n      percent,\n    } = options;\n\n    // Define currency format\n    const currencyFormat = {\n      style: 'currency',\n      currency: options.currency || 'USD',\n    };\n\n    // If no locale is provided, set default one\n    const defaultLocale = 'en-US';\n    const defaultData = {\n      decimal: '.',\n      group: ',',\n      negative: '-',\n      percent: '%',\n    };\n\n    // Set up locale data\n    let data = {};\n    if (isObject(locale)) {\n      data = locale;\n    } else if (isString(locale)) {\n      data = {\n        decimal,\n        group,\n        negative,\n        percent,\n      }\n      data.locale = locale;\n    } else if (!locales) {\n      data = defaultData;\n      data.locale = defaultLocale;\n    }\n\n    // Set up currency format\n    if (options.style === 'currency') {\n      data = { ...data, ...currencyFormat };\n    }\n\n    return data;\n  };\n\n  // Get formatting options\n  const getOptions = (localeData) => {\n    const {\n      decimal,\n      group,\n      negative,\n      style,\n    } = localeData;\n\n    let {\n      currency,\n    } = localeData;\n\n    const formatOptions = {\n      minimumFractionDigits: 0,\n      maximumFractionDigits: 0,\n      minimumIntegerDigits: 1,\n      useGrouping: true,\n      style: style || 'decimal',\n    };\n\n    if (style === 'currency') {\n      currency = currency || 'USD';\n    }\n\n    return {\n      decimal,\n      group,\n      negative,\n      currency,\n      formatOptions,\n    };\n  };\n\n  // Format number\n  const formatNumber = (number, options) => {\n    const {\n      decimal,\n      group,\n      negative,\n      currency,\n      formatOptions,\n    } = options;\n\n    let formattedNumber = '';\n\n    // Set up options\n    const numberOptions = {\n      ...formatOptions,\n      useGrouping: true,\n    };\n\n    // Handle negative number\n    if (number < 0) {\n      numberOptions.signDisplay = 'always';\n      formattedNumber = negative;\n    }\n\n    // Format number\n    if (style === 'currency') {\n      numberOptions.currencyDisplay = 'symbol';\n      numberOptions.currency = currency;\n      formattedNumber += new Intl.NumberFormat(locales, numberOptions).format(number);\n    } else {\n      numberOptions.minimumFractionDigits = 0;\n      numberOptions.maximumFractionDigits = 0;\n      formattedNumber += new Intl.NumberFormat(locales, numberOptions).format(number);\n    }\n\n    return formattedNumber;\n  };\n\n  // Format number\n  const numberFormat = (number) => {\n    const localeData = localeData(locales);\n    const options = getOptions(localeData);\n\n    return formatNumber(number, options);\n  };\n\n  return numberFormat;\n};",
    term: "Intl.NumberFormat",
    explain:
      "\n\n// This code defines a function, IntlNumberFormat, that takes two parameters, locales and options. \n// The function first declares two helper functions, isObject and isString, to check the type of the parameters. \n// It then defines the function localeData, which takes one parameter, locale, and sets up the locale data. \n// Next, the getOptions function is defined, which takes the locale data as its parameter and sets up the formatting options. \n// Finally, the formatNumber function is defined, which takes two parameters, number and options, and formats the number according to the specified options. \n// The function then returns the numberFormat function, which uses the localeData and getOptions functions to format the number.",
    useCase:
      "\n\nIntl.NumberFormat is used in JavaScript to format numbers according to the locale of the user. It allows developers to display numbers in a localized format, which can be useful for displaying prices, percentages, and other numerical data. Intl.NumberFormat can also be used to format numbers with the correct currency symbols and other formatting options like decimal places.",
  },
  {
    code: "\n\n// This polyfill is based on the Unicode CLDR Plural Rules (v35)\n\nconst IntlPluralRules = {\n    supportedLocalesOf: (locales) => {\n        // Validate the locales argument\n        if (typeof locales === 'string') {\n            locales = [locales];\n        } else if (!Array.isArray(locales)) {\n            throw new TypeError('invalid argument');\n        }\n\n        const supportedLocales = [];\n\n        // Check each locale against the supported plural rules\n        locales.forEach((locale) => {\n            if (IntlPluralRules.pluralRules[locale]) {\n                supportedLocales.push(locale);\n            }\n        });\n\n        return supportedLocales;\n    },\n\n    // Plural rules for each locale in the Unicode CLDR\n    pluralRules: {\n        \"en\": (n) => {\n            return n === 1 ? 'one' : 'other';\n        },\n        \"fr\": (n) => {\n            return (n >= 0 && n < 2) ? 'one' : 'other';\n        },\n        \"de\": (n) => {\n            return n !== 1 ? 'other' : 'one';\n        },\n        \"es\": (n) => {\n            return n !== 1 ? 'other' : 'one';\n        },\n        // Add more locale rules here\n    }\n};",
    term: "Intl.PluralRules",
    explain:
      "\n\n// This line of code is defining a polyfill for the Intl.PluralRules API which is used to determine the plural form of a given number in a particular language. \n\n// Line 1: \n// This line declares the constant IntlPluralRules which will hold the polyfill for the Intl.PluralRules API. \n\n// Line 2: \n// This line declares a supportedLocalesOf method which takes a single argument, locales, and returns an array of supported locales based on the plural rules provided.\n\n// Line 3:\n// This line checks to see if the argument passed to the supportedLocalesOf method is a string or an array. If it is neither, an error is thrown.\n\n// Line 4: \n// This line declares an empty array, supportedLocales, which will hold the supported locales.\n\n// Line 5-11: \n// This block of code iterates through each locale in the argument and checks it against the pluralRules object. If the locale is supported, it is pushed to the supportedLocales array.\n\n// Line 12: \n// This line returns the array of supported locales.\n\n// Line 13-20: \n// This block of code declares an object, pluralRules, which holds the plural rules for each supported locale. Each entry in the object contains a function which takes a single argument, n, and returns the appropriate plural form for that number in that language.",
    useCase:
      "\n\nIntl.PluralRules is used in JavaScript to provide language-sensitive plural formatting for numbers. This provides a way for users to format numbers according to the rules of any language, so that an application can display numbers in the way that is most appropriate for the language the user speaks. This is important for international applications, as different languages have different rules for how numbers should be formatted.",
  },
  {
    code: "\n\n//create a new prototype called RelativeTimeFormat\nRelativeTimeFormat.prototype = {\n  constructor: RelativeTimeFormat,\n\n  //define language-sensitive relative time format function\n  format: function (date, unit) {\n    //determine the difference in time between the current time and the given date\n    var diff = Math.abs(new Date() - date),\n      //determine the years passed since the given date\n      years = Math.floor(diff / 31536000000),\n      //determine the months passed since the given date\n      months = Math.floor((diff % 31536000000) / 2592000000),\n      //determine the days passed since the given date\n      days = Math.floor((diff % 2592000000) / 86400000),\n      //determine the hours passed since the given date\n      hours = Math.floor((diff % 86400000) / 3600000),\n      //determine the minutes passed since the given date\n      minutes = Math.floor((diff % 3600000) / 60000);\n\n    //declare a variable to store the returned relative time string\n    var relativeTimeString;\n\n    //determine the relative time string by the given unit\n    switch (unit) {\n      case 'year':\n        relativeTimeString = years + ' year' + (years > 1 ? 's' : '') + ' ago';\n        break;\n\n      case 'month':\n        relativeTimeString = months + ' month' + (months > 1 ? 's' : '') + ' ago';\n        break;\n\n      case 'day':\n        relativeTimeString = days + ' day' + (days > 1 ? 's' : '') + ' ago';\n        break;\n\n      case 'hour':\n        relativeTimeString = hours + ' hour' + (hours > 1 ? 's' : '') + ' ago';\n        break;\n\n      case 'minute':\n        relativeTimeString = minutes + ' minute' + (minutes > 1 ? 's' : '') + ' ago';\n        break;\n    }\n\n    //return the relative time string\n    return relativeTimeString;\n  },\n};",
    term: "Intl.RelativeTimeFormat",
    explain:
      "\n\n//This code creates a new prototype called RelativeTimeFormat. This will allow an object to access and use the properties and methods of the prototype. It then defines a language-sensitive relative time format function which determines the relative time string of a given date and unit. This is done by calculating the difference in time between the current time and the given date in years, months, days, hours, and minutes, and then returning the relative time string based on the given unit.",
    useCase:
      '\n\nIntl.RelativeTimeFormat is used in JavaScript to provide language-sensitive relative time formatting. It allows developers to format relative dates and times such as "yesterday" or "in 5 minutes" in a way that is tailored to the user\'s locale. This helps to ensure that the time formatting is appropriate and understandable by users in different languages and cultures.',
  },
  {
    code: "\n\n// polyfill for Intl.getCanonicalLocales\n\nconst getCanonicalLocales = (locales) => {\n   const canonicalLocales = [];\n   const seen = new Set();\n\n   locales.forEach((locale) => {\n      const normalizedLocale = locale.replace(/[-_]/, '-').toLowerCase();\n      const [baseLocale] = normalizedLocale.split('-');\n\n      if (!seen.has(normalizedLocale)) {\n        seen.add(normalizedLocale);\n        canonicalLocales.push(normalizedLocale);\n      }\n\n      if (baseLocale !== normalizedLocale && !seen.has(baseLocale)) {\n        seen.add(baseLocale);\n        canonicalLocales.push(baseLocale);\n      }\n   });\n \n   return canonicalLocales;\n};",
    term: "Intl.getCanonicalLocales",
    explain:
      '\n\n// Line 1\n// This line of code declares a function called "getCanonicalLocales" which takes a parameter of "locales".\n\n// Line 2\n// This line of code declares a variable called "canonicalLocales" and sets it to an empty array.\n\n// Line 3\n// This line of code declares a variable called "seen" and sets it to an instance of the Set data structure.\n\n// Line 4\n// This line of code calls the "forEach" method on the "locales" parameter, which executes the provided function once for each element in the array.\n\n// Line 5\n// This line of code declares a variable called "normalizedLocale" and sets it to the result of the "locale" parameter\'s "replace" method, which replaces all instances of either "_" or "-" with "-". It then converts the result to lowercase.\n\n// Line 6\n// This line of code declares a variable called "baseLocale" and sets it to the first element of the "normalizedLocale" variable, which was returned by the "split" method.\n\n// Line 7\n// This line of code checks if the "seen" variable (which is a Set data structure) does not have the "normalizedLocale" variable. If it doesn\'t, it adds it to the "seen" variable and pushes it to the "canonicalLocales" array.\n\n// Line 8\n// This line of code checks if the "baseLocale" variable is not the same as the "normalizedLocale" variable and if the "seen" variable (which is a Set data structure) does not have the "baseLocale" variable. If it doesn\'t, it adds it to the "seen" variable and pushes it to the "canonicalLocales" array.\n\n// Line 9\n// This line of code returns the "canonicalLocales" array.',
    useCase:
      "\n\nIntl.getCanonicalLocales is used in JavaScript to ensure consistency in the language or locale codes used across different JavaScript engines. For example, it can be used to convert a locale code that is not valid or accepted in the ECMAScript Internationalization API into an equivalent, valid one. It can also be used to convert different dialects of a language into a single, canonical language code. Intl.getCanonicalLocales is an important part of the Internationalization API and helps to ensure accurate and consistent results across different JavaScript engines.",
  },
  {
    code: "\n\n// define a function to act as a polyfill of JSON\nconst JSON = {\n  parse: function(text, reviver) {\n    let j;\n    function walk(holder, key) {\n      const k;\n      const v;\n      const value = holder[key];\n      if (value && typeof value === 'object') {\n        for (k in value) {\n          if (Object.hasOwnProperty.call(value, k)) {\n            v = walk(value, k);\n            if (v !== undefined) {\n              value[k] = v;\n            } else {\n              delete value[k];\n            }\n          }\n        }\n      }\n      return reviver.call(holder, key, value);\n    }\n    text = String(text);\n    rx_dangerous.lastIndex = 0;\n    if (rx_dangerous.test(text)) {\n      text = text.replace(rx_dangerous, function(a) {\n        return '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n      });\n    }\n    if (rx_one.test(text.replace(rx_two, '@').replace(rx_three, ']').replace(rx_four, ''))) {\n      j = eval('(' + text + ')');\n      return typeof reviver === 'function' ? walk({ '': j }, '') : j;\n    }\n    throw new SyntaxError('JSON.parse');\n  },\n  stringify: function(value, replacer, space) {\n    let i;\n    let gap = '';\n    let indent = '';\n    let rep;\n    let k;\n    let v;\n    let length;\n    if (typeof replacer === 'function') {\n      rep = replacer;\n    } else if (Array.isArray(replacer)) {\n      length = replacer.length;\n      rep = function(key, value) {\n        let i = 0;\n        if (Object.prototype.toString.apply(replacer) === '[object Array]') {\n          for (; i < length; i += 1) {\n            if (replacer[i] === key) {\n              return value;\n            }\n          }\n        }\n        return key;\n      };\n    }\n    if (space) {\n      if (typeof space === 'number') {\n        for (i = 0; i < space; i += 1) {\n          indent += ' ';\n        }\n      } else if (typeof space === 'string') {\n        indent = space;\n      }\n    }\n    if (typeof rep === 'function') {\n      value = rep.call(holder, key, value);\n    }\n    switch (typeof value) {\n      case 'string':\n        return quote(value);\n      case 'number':\n        return isFinite(value) ? String(value) : 'null';\n      case 'boolean':\n      case 'null':\n        return String(value);\n      case 'object':\n        if (!value) {\n          return 'null';\n        }\n        if (typeof value.toJSON === 'function') {\n          return stringify(value.toJSON());\n        }\n        gap += indent;\n        partial = [];\n        if (Array.isArray(value)) {\n          length = value.length;\n          for (i = 0; i < length; i += 1) {\n            partial[i] = str(i, value) || 'null';\n          }\n          v = partial.length === 0 ? '[]' : gap ? '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' : '[' + partial.join(',') + ']';\n          gap = mind;\n          return v;\n        }\n        if (rep && typeof rep === 'object') {\n          length = rep.length;\n          for (i = 0; i < length; i += 1) {\n            if (typeof rep[i] === 'string') {\n              k = rep[i];\n              v = str(k, value);\n              if (v) {\n                partial.push(quote(k) + (gap ? ': ' : ':') + v);\n              }\n            }\n          }\n        } else {\n          for (k in value) {\n            if (Object.prototype.hasOwnProperty.call(value, k)) {\n              v = str(k, value);\n              if (v) {\n                partial.push(quote(k) + (gap ? ': ' : ':') + v);\n              }\n            }\n          }\n        }\n        v = partial.length === 0 ? '{}' : gap ? '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' : '{' + partial.join(',') + '}';\n        gap = mind;\n        return v;\n    }\n  }\n};\n\n// define constants to use in the polyfill\nconst rx_one = /^[\\],:{}\\s]*$/;\nconst rx_two = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g;\nconst rx_three = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;\nconst rx_four = /(?:^|:|,)(?:\\s*\\[)+/g;\nconst rx_dangerous = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n\n// define helper functions\nfunction quote(string) {\n  const rx_escapable = /[\\\\\"\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n  rx_escapable.lastIndex = 0;\n  return rx_escapable.test(string) ? '\"' + string.replace(rx_escapable, function(a) {\n    const c = meta[a];\n    return typeof c === 'string' ? c : '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n  }) + '\"' : '\"' + string + '\"';\n}\nfunction str(key, holder) {\n  let i;\n  let k;\n  const v;\n  const length;\n  const mind = gap;\n  const partial;\n  if (typeof value === 'object' && value !== null) {\n    if (typeof value.toJSON === 'function') {\n      value = value.toJSON(key);\n    } else if (Array.isArray(value)) {\n      partial = [];\n      length = value.length;\n      for (i = 0; i < length; i += 1) {\n        partial[i] = str(i, value) || 'null';\n      }\n      v = partial.length === 0 ? '[]' : gap ? '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' : '[' + partial.join(',') + ']';\n      gap = mind;\n      return v;\n    }\n    if (rep && typeof rep === 'object') {\n      length = rep.length;\n      for (i = 0; i < length; i += 1) {\n        if (typeof rep[i] === 'string') {\n          k = rep[i];\n          v = str(k, value);\n          if (v) {\n            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n          }\n        }\n      }\n    } else {\n      for (k in value) {\n        if (Object.prototype.hasOwnProperty.call(value, k)) {\n          v = str(k, value);\n          if (v) {\n            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n          }\n        }",
    term: "JSON",
    explain:
      "\n      }\n    }\n    v = partial.length === 0 ? '{}' : gap ? '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' : '{' + partial.join(',') + '}';\n    gap = mind;\n    return v;\n  }\n}\n\n// Line 1: Define a function to act as a polyfill of JSON\n// This line defines a function to act as a polyfill of the JavaScript Object Notation (JSON) which is used to store and exchange data. \n\n// Line 2: Constants to use in the polyfill\n// This line defines four constants (rx_one, rx_two, rx_three, rx_four) which will be used in the polyfill.\n\n// Line 3: Define helper functions\n// This line defines helper functions (quote, str) which will be used in the polyfill.\n\n// Line 4: Define a constant to use in the polyfill\n// This line defines a constant (rx_dangerous) which will be used in the polyfill.",
    useCase:
      "\n\nJSON (JavaScript Object Notation) is often used in JavaScript because it is a lightweight data-interchange format that is easy to read and write for humans, and easy for machines to parse and generate. It is also language independent, so it can be used in any language, including JavaScript. JSON can be used to store and transfer data between a server and a web application, making it a great choice for data-driven web applications.",
  },
  {
    code: "\n\n// Polyfill for Map\nif (!window.Map) {\n  window.Map = function Map() {\n    let items = {};\n\n    this.set = function (key, value) {\n      items[key] = value;\n    };\n    this.delete = function (key) {\n      if (items.hasOwnProperty(key)) {\n        delete items[key];\n        return true;\n      }\n      return false;\n    };\n    this.has = function (key) {\n      return items.hasOwnProperty(key);\n    };\n    this.get = function (key) {\n      return items[key];\n    };\n    this.clear = function () {\n      items = {};\n    };\n    this.size = function () {\n      return Object.keys(items).length;\n    };\n  };\n}",
    term: "Map",
    explain:
      "\n//Line 1:\n//This line checks if the window object already has a Map property. If it doesn't, it will execute the code in the subsequent block.\n\n//Line 2:\n//This line sets a Map property on the window object and assigns it a function.\n\n//Line 3:\n//This line declares a variable items and assigns it an empty object.\n\n//Line 4-7:\n//These lines create the set() method on the Map object which takes a key and a value as arguments and assigns the value to the items object using the key.\n\n//Line 8-12:\n//These lines create the delete() method which takes a key as an argument and deletes it from the items object if it exists.\n\n//Line 13-16:\n//These lines create the has() method which checks if a given key is present in the items object.\n\n//Line 17-20:\n//These lines create the get() method which returns the value associated with the given key in the items object.\n\n//Line 21-24:\n//These lines create the clear() method which sets the items object to an empty object.\n\n//Line 25-28:\n//These lines create the size() method which returns the number of keys present in the items object.",
    useCase:
      "\n\nMap is used in Javascript because it provides an efficient way to store key-value pairs and look up values quickly. The Map object can be used as a simple data structure to store key-value pairs, or as a sophisticated data structure to perform complex lookups. Maps also provide a better alternative to objects when keys are unknown until run time, or when there is a need to store a collection of unique values.",
  },
  {
    code: "\n\nif (!Math.acosh) {\n  Math.acosh = function(x) {\n    if (x < 1) {\n      return NaN;\n    }\n    return Math.log(x + Math.sqrt(x * x - 1));\n  };\n}",
    term: "Math.acosh",
    explain:
      "\n\n//Line 1: This line checks if the function Math.acosh already exists. If it does not exist, it will execute the code in the following block.\n\n//Line 2: This line starts the function Math.acosh which takes one parameter, x.\n\n//Line 3: This line checks if the value of x is less than 1. If it is, it will return NaN, which stands for Not a Number.\n\n//Line 4: This line returns the logarithm of x plus the square root of x squared minus 1.",
    useCase:
      "\n\nMath.acosh is used in Javascript to calculate the inverse hyperbolic cosine of a number. It is useful in situations where an angle or a trigonometric ratio needs to be determined from a given value of the hyperbolic cosine. It is also used in scientific and engineering applications, such as finding the force of gravity at a certain height, or calculating the angle of refraction of a beam of light.",
  },
  {
    code: "\n\nif (!Math.asinh) {\n    Math.asinh = function(x) {\n        if (x === -Infinity) {\n            return x;\n        } else {\n            return Math.log(x + Math.sqrt(x * x + 1));\n        }\n    }\n}",
    term: "Math.asinh",
    explain:
      "\n\n// Line 1: if (!Math.asinh) {\n// This line checks whether Math.asinh already exists or not. If it already exists, the code inside the if statement will not be executed. \n\n// Line 2: Math.asinh = function(x) {\n// This line defines a function that takes the parameter x and assigns it to Math.asinh. \n\n// Line 3: if (x === -Infinity) {\n// This line checks whether the value of x is equal to negative infinity. \n\n// Line 4: return x;\n// This line returns the value of x if the condition in line 3 is true. \n\n// Line 5:} else {\n// This line will only execute if the condition in line 3 is false.\n\n// Line 6: return Math.log(x + Math.sqrt(x * x + 1));\n// This line returns the logarithm of x plus the square root of x squared plus 1.",
    useCase:
      "\n\nMath.asinh is used in Javascript to calculate the inverse hyperbolic sine of a given number. It is useful for a variety of mathematical operations, such as calculating angles and trigonometric functions. It is also commonly used in physics calculations to determine the velocity and acceleration of objects in motion.",
  },
  {
    code: "\n\nif (!Math.atanh) {\n  Math.atanh = function(x) {\n    if (x === -1) {\n      return -Infinity;\n    } else if (x === 1) {\n      return Infinity;\n    } else if (x < -1 || x > 1) {\n      return NaN;\n    }\n\n    return 0.5 * Math.log((1 + x) / (1 - x));\n  }\n}",
    term: "Math.atanh",
    explain:
      "\n\nLine 1: This line checks whether atanh function exists in the Math object. If it doesn't exist, the code moves to the next line.\n\nLine 2: This line creates a function called atanh and assigns it to Math object.\n\nLine 3: This line checks whether the parameter passed to the function is -1. If it is, the function returns -Infinity.\n\nLine 4: This line checks whether the parameter passed to the function is 1. If it is, the function returns Infinity.\n\nLine 5: This line checks whether the parameter passed to the function is less than -1 or greater than 1. If it is, the function returns NaN.\n\nLine 6: This line returns the result of 0.5 multiplied by the natural log of (1 + x) divided by (1 - x).",
    useCase:
      "\n\nMath.atanh is used in Javascript to calculate the inverse hyperbolic tangent of a number. This is useful when you need to calculate the angle of a triangle given the length of its sides, or when you need to calculate the angle at which a projectile will reach its highest point given its initial velocity. It is also useful when you need to determine the angle of a line given its slope.",
  },
  {
    code: "\n\nMath.cbrt=function(x){\n  let y = Math.pow(Math.abs(x), 1/3);\n  return x < 0 ? -y : y;\n};",
    term: "Math.cbrt",
    explain:
      "\n\n// Math.cbrt is a function that takes in one parameter, x.\n// The next line calculates the value of y using the absolute value of x and the cube root formula.\n// The last line returns the value of y if x is greater than 0 and returns the negative of y if x is less than 0.",
    useCase:
      "\n\nMath.cbrt is used in Javascript to calculate the cube root of a number. Cube roots are used in many mathematical equations and calculations, such as polynomials and other equations that involve exponents or radicals. It is also used in some computer graphics and animation programs to calculate the size and shape of 3D objects.",
  },
  {
    code: "\n\nif (!Math.clz32) {\n  Math.clz32 = function(x) {\n    var value = Number(x) >>> 0;\n    if (value === 0) return 32;\n    var result = 0;\n    if (value >= 0xFFFFFFFF) { result += 32; value >>>= 32; }\n    if (value >= 0xFFFF) { result += 16; value >>>= 16; }\n    if (value >= 0xFF) { result += 8; value >>>= 8; }\n    if (value >= 0xF) { result += 4; value >>>= 4; }\n    if (value >= 0x3) { result += 2; value >>>= 2; }\n    return result + (value >>> 1);\n  }\n}",
    term: "Math.clz32",
    explain:
      '\n\n// Line 1: \n// If Math.clz32 is not defined, \n\n// Line 2: \n// define a Math.clz32 function that takes in a parameter x \n\n// Line 3: \n// Set a variable "value" to the parameter x converted to a number and shifted right by 0 bits\n\n// Line 4: \n// If the value of the variable is 0, return 32 \n\n// Line 5: \n// Set a variable "result" to 0\n\n// Line 6: \n// If the value of the variable is greater than or equal to 0xFFFFFFFF (4294967295 in decimal), add 32 to the result and shift the value of the variable right by 32 bits\n\n// Line 7: \n// If the value of the variable is greater than or equal to 0xFFFF (65535 in decimal), add 16 to the result and shift the value of the variable right by 16 bits\n\n// Line 8: \n// If the value of the variable is greater than or equal to 0xFF (255 in decimal), add 8 to the result and shift the value of the variable right by 8 bits\n\n// Line 9: \n// If the value of the variable is greater than or equal to 0xF (15 in decimal), add 4 to the result and shift the value of the variable right by 4 bits\n\n// Line 10:\n// If the value of the variable is greater than or equal to 0x3 (3 in decimal), add 2 to the result and shift the value of the variable right by 2 bits\n\n// Line 11: \n// Return the result plus the value of the variable shifted right by 1 bit',
    useCase:
      "\n\nMath.clz32 is used in Javascript to count the number of leading zero bits in a 32-bit integer. This is useful for a variety of tasks such as determining the number of leading zeros in a binary representation of a number, or for determining the position of the highest set bit in a number. This can be used for efficient arithmetic operations or for optimizing code.",
  },
  {
    code: "\n\nif (!Math.cosh) {\n  Math.cosh = function (x) {\n    return  (Math.exp(x) + Math.exp(-x)) / 2;\n  }\n}",
    term: "Math.cosh",
    explain:
      "\n\n// Line 1: This line checks whether the Math object has a cosh method, and if not, it creates one.\n// Line 2: This line defines the cosh method for the Math object. It uses the exponential function (exp) to calculate the hyperbolic cosine of a given number.",
    useCase:
      "\n\nMath.cosh is used in Javascript to calculate the hyperbolic cosine of a number. It is useful for applications such as calculating angles in trigonometry and complex numbers.",
  },
  {
    code: "\n\nif (!Math.expm1) {\n    Math.expm1 = function (x) {\n        let y = 1;\n        let n = 50;\n        let factorial = 1;\n        for (let i = 1; i <= n; i++) {\n            factorial *= i;\n            y += Math.pow(x, i) / factorial;\n        }\n        return Math.round(y * 10000000) / 10000000;\n    }\n}",
    term: "Math.expm1",
    explain:
      "\n\n// Line 1: This line checks if the Math.expm1 function already exists. If it does not exist, the code will go into the if statement.\n\n// Line 2: This line declares the Math.expm1 function.\n\n// Line 3: This line declares a variable called y and sets it equal to 1.\n\n// Line 4: This line declares a variable called n and sets it equal to 50.\n\n// Line 5: This line declares a variable called factorial and sets it equal to 1.\n\n// Line 6: This line creates a for loop that will iterate from 1 to n.\n\n// Line 7: This line multiplies the factorial variable by the current iteration of the loop.\n\n// Line 8: This line adds the result of the Math.pow() function divided by the factorial variable to the y variable.\n\n// Line 9: This line returns the value of y multiplied by 10000000 and rounded to the nearest integer.",
    useCase:
      "\n\nMath.expm1 is used in Javascript to calculate the value of e^x - 1, where e is Euler's number (approximately equal to 2.718281828459045). This is useful for calculations that require precision and accuracy, such as calculating the natural logarithm of a number.",
  },
  {
    code: "\n\nif (!Math.fround) {\n  Math.fround = function(x) {\n    if (x === 0) {\n      return x;\n    }\n    \n    if (!Number.isFinite(x)) {\n      return x;\n    }\n\n    var e = Math.floor(Math.log2(Math.abs(x)));\n    var m = Math.pow(2, e - 23);\n    var n = (1 + m) * x;\n    var r = Math.floor(n) & 0x7FFFFF;\n    return (r / m) * Math.pow(2, e - 24);\n  };\n}",
    term: "Math.fround",
    explain:
      "\n\n// Line 1: if (!Math.fround) {\n// This line checks to see if the Math.fround function already exists. If it does not, the code within the if statement will be executed. \n\n// Line 2: Math.fround = function(x) {\n// This line assigns a function to the Math.fround property. The function will take one parameter, x.\n\n// Line 3: if (x === 0) {\n// This line checks to see if the parameter x is equal to 0. If it is, the code within this if statement will be executed.\n\n// Line 4: return x;\n// This line returns the parameter x if it is equal to 0.\n\n// Line 5: if (!Number.isFinite(x)) {\n// This line checks to see if the parameter x is a finite number. If it is not, the code within this if statement will be executed.\n\n// Line 6: return x;\n// This line returns the parameter x if it is not a finite number.\n\n// Line 7: var e = Math.floor(Math.log2(Math.abs(x)));\n// This line declares a variable e and assigns it the value of the Math.floor function applied to the Math.log2 function applied to the Math.abs function applied to the parameter x.\n\n// Line 8: var m = Math.pow(2, e - 23);\n// This line declares a variable m and assigns it the value of the Math.pow function applied to 2 and the result of subtracting 23 from the variable e.\n\n// Line 9: var n = (1 + m) * x;\n// This line declares a variable n and assigns it the value of adding 1 to the variable m and multiplying it by the parameter x.\n\n// Line 10: var r = Math.floor(n) & 0x7FFFFF;\n// This line declares a variable r and assigns it the value of the Math.floor function applied to the variable n and a bitwise AND operation with the hexadecimal number 0x7FFFFF.\n\n// Line 11: return (r / m) * Math.pow(2, e - 24);\n// This line returns the result of dividing the variable r by the variable m and multiplying it by the Math.pow function applied to 2 and subtracting 24 from the variable e.",
    useCase:
      "\n\nMath.fround is used in Javascript to round a number to its nearest 32-bit single precision float representation. This is important because it ensures that the number is accurately represented in the system and is useful when working with certain types of calculations. Additionally, it allows for a more efficient use of memory since single precision numbers take up less space than double precision numbers.",
  },
  {
    code: "\n\nMath.hypot = function() {\n  let y = 0;\n  for (let i=0; i < arguments.length; i++) {\n    if (arguments[i] === Infinity || arguments[i] === -Infinity) {\n      return Infinity;\n    }\n    y += arguments[i] * arguments[i];\n  }\n  return Math.sqrt(y);\n}",
    term: "Math.hypot",
    explain:
      "\n\n// Math.hypot is a function that finds the Euclidean norm of a set of numbers.\n\n// Line 1: This defines a function called Math.hypot, which is assigned to the Math object.\n\n// Line 2: This declares a variable y and sets it to 0.\n\n// Line 3: This loop iterates over all the given arguments.\n\n// Line 4: This checks if any of the given arguments is either Infinity or -Infinity. If so, it returns Infinity.\n\n// Line 5: This line adds the square of the current argument to the y variable.\n\n// Line 6: This returns the square root of y.",
    useCase:
      "\n\nMath.hypot is used in Javascript to calculate the length of the hypotenuse of a right triangle using the Pythagorean theorem. This can be used to calculate the distance between two points, the size of a triangle, or any other calculation that requires the hypotenuse of a right triangle.",
  },
  {
    code: "\n\nfunction imul(a, b) {\n  var ah = (a >>> 16) & 0xffff;\n  var al = a & 0xffff;\n  var bh = (b >>> 16) & 0xffff;\n  var bl = b & 0xffff;\n  // the shift by 0 fixes the sign on the high part\n  // the final |0 converts the unsigned value into a signed value\n  return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);\n}",
    term: "Math.imul",
    explain:
      "\n\n// function imul(a, b): Declares a function named imul that takes two integer arguments, a and b.\n\n// var ah = (a >>> 16) & 0xffff: Declares a variable named ah and assigns it the value of a right-shifted by 16 bits and then bitwise ANDed with 0xffff. This results in the high 16 bits of the 32-bit a.\n\n// var al = a & 0xffff: Declares a variable named al and assigns it the value of a bitwise ANDed with 0xffff. This results in the low 16 bits of the 32-bit a.\n\n// var bh = (b >>> 16) & 0xffff: Declares a variable named bh and assigns it the value of b right-shifted by 16 bits and then bitwise ANDed with 0xffff. This results in the high 16 bits of the 32-bit b.\n\n// var bl = b & 0xffff: Declares a variable named bl and assigns it the value of b bitwise ANDed with 0xffff. This results in the low 16 bits of the 32-bit b.\n\n// return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0): Returns the result of multiplying al, the low 16 bits of a, and bl, the low 16 bits of b, and adding it to the result of multiplying ah, the high 16 bits of a, and bl, the low 16 bits of b, and then adding that to the result of multiplying al, the low 16 bits of a, and bh, the high 16 bits of b and then left-shifting that result by 16 bits and then right-shifting it by 0 bits before bitwise ORing it with 0. This calculation results in a 32-bit value.",
    useCase:
      "\n\nMath.imul is used in Javascript to efficiently multiply two integers and return the result as an integer. This is important, as it allows for faster calculations when working with large values, as well as providing better accuracy when working with small values. It also helps to reduce overflow errors, since the result is automatically rounded to the nearest integer.",
  },
  {
    code: "\n\nif (!Math.log10) {\n  Math.log10 = function (x) {\n    return Math.log(x) * Math.LOG10E;\n  };\n}",
    term: "Math.log10",
    explain:
      "\n\n// This code checks if a log10 function is defined in Math. \n// If it is not, a new log10 function is defined that returns the natural log of x multiplied by the base 10 logarithm of E.",
    useCase:
      "\n\nMath.log10 is used in Javascript to calculate the logarithmic value to the base 10 of a number. It is typically used in engineering and scientific calculations where logarithmic values are essential. This function is also useful for finding the number of digits in a number.",
  },
  {
    code: "\n\nMath.log1p = function(x) {\n  if (x <= -1) {\n    return NaN;\n  } else if (Math.abs(x) > 1e-4) {\n    return Math.log(1 + x);\n  } else {\n    var y = x, sum = x;\n    var i = 1;\n    while (Math.abs(y) > 1e-4) {\n      y *= x / ++i;\n      sum += y;\n    }\n    return sum;\n  }\n};",
    term: "Math.log1p",
    explain:
      "\n\n// Math.log1p = function(x) \n// This line is creating the function log1p and assigning it to the Math object.\n\n// if (x <= -1) {\n// This line is checking to see if the argument passed in is less than or equal to -1.\n\n// return NaN;\n// This line is returning the value NaN (Not a Number) if the argument is less than or equal to -1.\n\n// else if (Math.abs(x) > 1e-4) {\n// This line is checking to see if the absolute value of the argument is greater than 1e-4 (0.0001).\n\n// return Math.log(1 + x);\n// This line is returning the value of the natural logarithm of 1 plus the argument passed in.\n\n// var y = x, sum = x;\n// This line is declaring two variables, y and sum, and assigning the argument passed in to both.\n\n// var i = 1;\n// This line is declaring a variable, i, and assigning it a value of 1.\n\n// while (Math.abs(y) > 1e-4) {\n// This line is creating a while loop that will continue while the absolute value of the variable y is greater than 1e-4 (0.0001).\n\n// y *= x / ++i;\n// This line is multiplying the variable y by the argument passed in, divided by the incremented value of the variable i.\n\n// sum += y;\n// This line is adding the value of the variable y to the variable sum.\n\n// return sum;\n// This line is returning the value of the variable sum once the while loop has finished.\n\n// };\n// This line is ending the function.",
    useCase:
      "\n\nMath.log1p is used in Javascript to calculate the natural logarithm of a number plus one. This is useful because it allows for the calculation of the natural logarithm of a number that is very close to zero without having to deal with the numerical issues that come with taking the logarithm of a number that is very close to zero. This makes it a useful tool for dealing with values that may otherwise be difficult to work with.",
  },
  {
    code: "\n\nif (!Math.log2) {\n  Math.log2 = function(x) {\n    return Math.log(x) * Math.LOG2E;\n  };\n}",
    term: "Math.log2",
    explain:
      "\n\n//Line 1: \n//This line checks to see if there is a Math.log2 function already defined. \n\n//Line 2: \n//If Math.log2 is not defined, this line creates a new function that takes one argument, x.\n\n//Line 3:\n//This line returns the natural logarithm of x times the constant Math.LOG2E.",
    useCase:
      "\n\nMath.log2 is used in Javascript to calculate the base 2 logarithm of a number. This is useful for algorithms that require the use of logarithms in order to work more efficiently and accurately. For example, binary search algorithms are based on logarithmic calculations, and Math.log2 can be used to perform these calculations quickly and accurately.",
  },
  {
    code: "\n\nfunction mathSign(value) {\n   if (value === 0) {\n      return 0\n   } else if (value > 0) {\n      return 1\n   } else {\n      return -1\n   }\n}",
    term: "Math.sign",
    explain:
      '\n\n// Line 1: This line declares a function called "mathSign" with one parameter called "value".\n// Line 2: This line evaluates if the value of the parameter "value" is equal to 0. If the condition is true, then the function returns the value 0. \n// Line 3: This line evaluates if the value of the parameter "value" is greater than 0. If the condition is true, then the function returns the value 1. \n// Line 4: This line evaluates if the value of the parameter "value" is not equal to 0 and not greater than 0. If the condition is true, then the function returns the value -1.',
    useCase:
      "\n\nMath.sign is used in Javascript to determine the sign of a number. It will return a number indicating whether the value is positive, negative, or zero. This is a useful function for determining the direction of a number and for making decisions based on the sign of a number. It is also useful for setting up mathematical equations that involve the sign of a number.",
  },
  {
    code: "\n\nMath.sinh = Math.sinh || function(x) {\n    var y = Math.exp(x);\n    return (y - 1 / y) / 2;\n};",
    term: "Math.sinh",
    explain:
      "\n\n//Line 1: This line assigns the Math.sinh function to the Math object, or if Math.sinh already exists, it is not changed.\n//Line 2: This line creates a variable y and assigns it to the value of e to the power of x.\n//Line 3: This line returns the result of (y - 1 / y) / 2, which is the hyperbolic sine of x.",
    useCase:
      "\n\nMath.sinh is used in JavaScript to calculate the hyperbolic sine of a given number. The hyperbolic sine function is an important mathematical function that is used in many areas of mathematics, such as calculus and trigonometry. It is also used in many real-world applications, such as astronomy, engineering, and physics. By using Math.sinh, developers can quickly and easily calculate the hyperbolic sine of a given number without having to manually calculate the result.",
  },
  {
    code: "\n\nMath.tanh = function(x) {\n    var y = Math.exp(2 * x);\n    return (y - 1) / (y + 1);\n};",
    term: "Math.tanh",
    explain:
      '\n\n// line 1: This line defines a new function called "Math.tanh" with one parameter called "x".\n// line 2: This line creates a new variable called "y" and assigns it the value of Math.exp(2 * x). Math.exp() is a built-in JavaScript function that returns the exponential of a number. In this case, it is the exponential of 2 times the parameter "x".\n// line 3: This line returns the value of (y - 1) / (y + 1) which is the result of the tanh function.',
    useCase:
      "\n\nMath.tanh is used in Javascript to calculate the hyperbolic tangent of a number. It is often used in machine learning applications such as neural networks and deep learning, as well as in signal processing applications such as audio and image processing. The hyperbolic tangent is an important mathematical function that is used to map a real number to a value between -1 and 1. This range makes it useful for representing a wide variety of data, from binary values (on/off, true/false) to weighted values (such as ratings), and is especially useful for representing probabilities.",
  },
  {
    code: "\n\nif (!Math.trunc) {\n\tMath.trunc = function (value) {\n\t\treturn value < 0 ? Math.ceil(value) : Math.floor(value);\n\t};\n}",
    term: "Math.trunc",
    explain:
      '\n\n// This line checks to see if a Math.trunc function already exists. If it does not, one is created.\nif (!Math.trunc) {\n\n// This line defines the Math.trunc function. It takes one argument, "value", which will be rounded either up or down depending on whether it is positive or negative.\n\tMath.trunc = function (value) {\n\t\treturn value < 0 ? Math.ceil(value) : Math.floor(value);\n\t};\n}',
    useCase:
      "\n\nMath.trunc is used in Javascript to remove the decimal part of a number and return the integer part. This is useful when you need to perform calculations with only whole numbers, or when you want to round a number down to its nearest integer.",
  },
  {
    code: "\n\nif (!MediaQueryList.prototype.addEventListener) {\n  MediaQueryList.prototype.addEventListener = function (eventName, callback) {\n    if (eventName === 'change') {\n      var that = this;\n      this.listener = function () {\n        callback.call(that);\n      }\n      this._setListener();\n    }\n  }\n}",
    term: "MediaQueryList.prototype.addEventListener",
    explain:
      '\n\n// Line 1: This line checks if the prototype of MediaQueryList has an "addEventListener" property. If it does not have it, the code inside the if statement will be executed.\n// Line 2: This line creates an "addEventListener" property for the MediaQueryList prototype with a function as value. The function takes two parameters, eventName and callback.\n// Line 3: This line checks if the eventName is equal to "change". If it is, then the code inside the if statement will be executed.\n// Line 4: This line creates a variable called "that" that references the MediaQueryList object.\n// Line 5: This line creates a "listener" property for the MediaQueryList object and sets it to a function that calls the callback function with the MediaQueryList object as the context.\n// Line 6: This line calls the "_setListener" method which is responsible for setting up the listener.',
    useCase:
      "\n\nMediaQueryList.prototype.addEventListener is used in Javascript to allow developers to easily respond to changes in a media query. This allows developers to detect when the size of the viewport has changed, so they can adjust the layout of their application accordingly. This is especially useful for responsive websites, as it allows the website to respond to the user's viewport size and adjust accordingly.",
  },
  {
    code: "\n\nif(!window.MediaQueryList.prototype.removeEventListener){\n\twindow.MediaQueryList.prototype.removeEventListener = function(type, listener){\n\t\tif (this.listeners[type] && this.listeners[type].length > 0){\n\t\t\tlet newListeners = this.listeners[type].filter(f => f !== listener);\n\t\t\tthis.listeners[type] = newListeners;\n\t\t}\n\t}\n}",
    term: "MediaQueryList.prototype.removeEventListener",
    explain:
      "\n\n//This line is checking to see if the MediaQueryList.prototype object has a removeEventListener method. If it does not, then the following code will be executed.\nif(!window.MediaQueryList.prototype.removeEventListener){\n\n// This line adds the removeEventListener method to the MediaQueryList.prototype object\n\twindow.MediaQueryList.prototype.removeEventListener = function(type, listener){\n\n// This line checks to see if the listeners object has a type property, and if it does, if the length of that property is greater than 0.\n\t\tif (this.listeners[type] && this.listeners[type].length > 0){\n\n// This line creates a new array of listeners that excludes the listener that is being removed. \n\t\t\tlet newListeners = this.listeners[type].filter(f => f !== listener);\n\n// This line sets the value of the type property of the listeners object to the new array of listeners.\n\t\t\tthis.listeners[type] = newListeners;\n\t\t}\n\t}\n}",
    useCase:
      "\n\nMediaQueryList.prototype.removeEventListener is used in Javascript to remove an event listener from a MediaQueryList. This allows for the removal of the media query listener from the specified MediaQueryList instance so that it will no longer be triggered when the media query matches. This is useful for cleaning up after using a media query listener and preventing any unnecessary updates or triggers.",
  },
  {
    code: "\n\n// Polyfill for MutationObserver\n\n(function (global) {\n  \n  // MutationObserver Polyfill\n  // ***\n  // \n  // This is a polyfill for the MutationObserver interface. It is based on the \n  // implementation in the [Mutation Summary library](https://github.com/rafaelw/mutation-summary). \n  //\n  // The interface is based on the [WebKit MutationObserver](https://www.w3.org/TR/dom/#mutation-observers) \n  // interface. The main difference is that the native implementation supports \n  // both childList and attributes mutations whereas this polyfill only supports \n  // childList mutations.\n\n  // The MutationSummary constructor\n  function MutationSummary(opts) {\n    this.connected = false;\n    this.options = opts; \n    this.observerOptions = opts.observerOptions || {\n      childList: true, \n      subtree: true\n    };\n    this.rootNode = opts.rootNode;\n    this.callback = opts.callback;\n    this.elementFilter = Array.prototype.concat.apply([], opts.queries).map(normalizeElementString);\n    this.calcReordered = opts.queries.some(function(query) {\n      return query.characterDataOnly;\n    });\n\n    // This object stores the observers\n    this.observerSummaries = [];\n\n    // This flag is used to track whether a node's children have already been\n    // tracked by the observers\n    this.alreadyTracked = false;\n\n    // This flags keep track of changes tracked by the observers\n    this.changesToReport = {\n      added: [],\n      removed: []\n    };\n\n    // This flag allows us to detect any changes made from the callback\n    this.pendingChanges = false;\n\n    this.connected = true;\n    this.observeChanges();\n  }\n\n  // Static function for resetting the status property of the MutationSummary\n  MutationSummary.resetStatus = function() {\n    this.connected = false;\n    this.observerSummaries.forEach(function(summary) {\n      if (summary.observer) {\n        summary.observer.disconnect();\n      }\n    });\n    this.observerSummaries = [];\n    this.alreadyTracked = false;\n    this.changesToReport = {\n      added: [],\n      removed: []\n    };\n    this.pendingChanges = false;\n  };\n\n  // Static function for disconnecting from the MutationSummary\n  MutationSummary.disconnect = function() {\n    this.resetStatus();\n    this.connected = false;\n  };\n\n  // Connect to the MutationSummary and begin observing for changes\n  MutationSummary.prototype.observeChanges = function() {\n    // Check if the MutationSummary is already connected\n    if (!this.connected) {\n      return;\n    }\n\n    // Create the observers\n    this.createSummaries();\n\n    // Connect the observers\n    this.observerSummaries.forEach(function(summary) {\n      summary.observer.observe(summary.target, summary.options);\n    });\n  };\n\n  // Disconnect from the MutationSummary and stop observing for changes\n  MutationSummary.prototype.disconnect = function() {\n    MutationSummary.disconnect.call(this);\n  };\n\n  // Create observer summaries\n  MutationSummary.prototype.createSummaries = function() {\n    // Check if the MutationSummary is already connected\n    if (!this.connected) {\n      return;\n    }\n\n    // Create the observer summaries\n    if (this.observerSummaries.length) {\n      // If the summaries already exist, disconnect them\n      this.observerSummaries.forEach(function(summary) {\n        summary.observer.disconnect();\n      });\n      this.observerSummaries = [];\n    }\n\n    // Go through each query and create an observer for each one\n    this.options.queries.forEach(function(query) {\n      var target = this.rootNode;\n      var options = this.observerOptions;\n      if (query.elementFilter) {\n        target = this.rootNode.querySelectorAll(query.elementFilter);\n        options.attributeFilter = query.attributeFilter;\n      }\n      this.observerSummaries.push({\n        target: target, \n        options: options\n      });\n    }, this);\n  };\n\n  // Callback to be called on mutations\n  MutationSummary.prototype.onMutations = function(summaries) {\n    // Check if the MutationSummary is still connected\n    if (!this.connected) {\n      return;\n    }\n    // If the callback is being called as a result of changes made from the\n    // callback, then we don't want to process those changes\n    if (this.pendingChanges) {\n      this.pendingChanges = false;\n      return;\n    }\n    // Get the mutations for each summary\n    summaries.forEach(function(summary) {\n      this.getMutations(summary);\n    }, this);\n    // If the changes are for a single element, then we can just pass the\n    // single element in the callback. Otherwise, we need to pass the entire\n    // set of changes\n    var changes = this.changesToReport.added.length ? \n      this.changesToReport.added : \n      this.changesToReport;\n    this.callback(changes);\n    // Reset the changes\n    this.resetChanges();\n  };\n\n  // Get the mutations for the given summary\n  MutationSummary.prototype.getMutations = function(summary) {\n    summary.takeRecords().forEach(function(record) {\n      if (this.alreadyTracked) {\n        // If we've already tracked the changes, then we just need to check\n        // to see if any elements were added or removed\n        this.checkElementFilter(record);\n      } else {\n        // Otherwise, we need to check each element in the record to see if\n        // it matches the filter\n        this.checkElementList(record.addedNodes, 'added');\n        this.checkElementList(record.removedNodes, 'removed');\n      }\n    }, this);\n  };\n\n  // Check the element list for any elements that match the filter\n  MutationSummary.prototype.checkElementList = function(elementList, type) {\n    for (var i = 0, len = elementList.length; i < len; i++) {\n      this.checkElementFilter(elementList[i], type);\n    }\n  };\n\n  // Check if the given element matches the filter\n  MutationSummary.prototype.checkElementFilter = function(node, type) {\n    if (!node.nodeType === 1) {\n      return;\n    }\n    type = type || 'added';\n    var elementId = node.id || node.getAttribute('id');\n    var matchesFilter = this.elementFilter.indexOf(elementId) > -1;\n    if (matchesFilter) {\n      if (this.calcReordered && type === 'added') {\n        // If we need to track reordered elements, then we should check to \n        // see if the element has been moved\n        this.checkReordered(node);\n      } else {\n        // Otherwise, just add it to the changes\n        this.addChange(node, type);\n      }\n    }\n  };\n\n  // Check to see if the element has been reordered\n  MutationSummary.prototype.checkReordered = function(node) {\n    // If the element has no previous element, then it's definitely been \n    // added\n    if (!node.previousElementSibling) {\n      this.addChange(node, 'added');\n    } else {\n      // Otherwise, check to see if it's in the same position as it was\n      // before\n      var previousIndex = this.getNodeIndex(node.previousElementSibling);\n      var currentIndex = this.getNodeIndex(node);\n      if (previousIndex !== currentIndex) {\n        this.addChange(node, 'added');\n      }\n    }\n  };\n\n  // Get the index of the given node relative to its siblings\n  MutationSummary.prototype.getNodeIndex = function(node) {\n    var index = 0;\n    while (node = node.previousElementSibling) {\n      index++;\n    }\n    return index;\n  };\n\n  // Add the given node to the changes to be reported\n  MutationSummary.prototype.addChange = function(node, type) {\n    this.changesToReport[type].push(",
    term: "MutationObserver",
    explain:
      "node);\n  };\n\n  // Reset the changes to be reported\n  MutationSummary.prototype.resetChanges = function() {\n    this.changesToReport = {\n      added: [],\n      removed: []\n    };\n  };\n\n  // Normalize an element string\n  function normalizeElementString(str) {\n    return str.replace(/^#/, '');\n  }\n\n  global.MutationSummary = MutationSummary;\n\n})(this);\n\n// This code is a polyfill for the MutationObserver interface. It creates a MutationSummary constructor which takes in a set of options and creates a new MutationSummary instance. The options include a rootNode, a callback, and queries. The rootNode is the root node which the MutationSummary will observe for changes. The callback is the function which will be called every time a mutation is observed. The queries are used to specify which elements the MutationSummary should observe and which attributes it should listen for changes on. \n\n// The code then sets up some default values, such as connected set to false, and an observerOptions property set to {childList: true, subtree: true}. It then creates a new MutationSummary and sets the connected property to true. \n\n// The code then defines two static functions, resetStatus and disconnect, which are used to reset and disconnect from the MutationSummary. \n\n// Finally, the code defines the observeChanges and disconnect functions, which are used to connect and disconnect from the MutationSummary, as well as the onMutations and getMutations functions, which are used to get the mutations for the given summary. It also defines some helper functions, such as checkElementFilter, checkElementList, checkReordered, and getNodeIndex, which are used to check if the given element matches the filter and to get the index of the given node relative to its siblings.",
    useCase:
      "\n\nMutationObserver is used in JavaScript to detect and react to changes in the DOM (Document Object Model). It allows developers to observe and respond to changes in the DOM, such as when elements are added, removed, or modified. This provides a powerful way to create dynamic and interactive websites and applications. It also allows developers to write code that reacts to changes in the DOM in an efficient and performant manner.",
  },
  {
    code: "\n\nif (Navigator.prototype.geolocation === undefined) { \n  Navigator.prototype.geolocation = { \n    getCurrentPosition: function(successHandler, errorHandler, options) { \n      //Create a dummy position object \n      let position = { \n        coords: { \n          latitude: 0, \n          longitude: 0 \n        } \n      };\n      successHandler(position);\n    }\n  };\n}",
    term: "Navigator.prototype.geolocation",
    explain:
      "\n\n// This line checks if the geolocation property is undefined on the Navigator prototype\nif (Navigator.prototype.geolocation === undefined) { \n\n// This line adds a geolocation property to the Navigator prototype with a getCurrentPosition method\n  Navigator.prototype.geolocation = { \n    getCurrentPosition: function(successHandler, errorHandler, options) { \n\n// This line creates a dummy position object with a latitude and longitude value of 0\n      let position = { \n        coords: { \n          latitude: 0, \n          longitude: 0 \n        } \n      };\n\n// This line calls the successHandler and passes the dummy position object as an argument \n      successHandler(position);\n    }\n  };\n}",
    useCase:
      "\n\nNavigator.prototype.geolocation is used in Javascript to access the Geolocation API, which allows web applications to access a user's location information. This information can then be used to display relevant content or provide services tailored to the user's location. It can also be used to help track user activity or analyze user behavior.",
  },
  {
    code: "\n\n// Check if the browser supports Node.prototype.contains\nif (!Node.prototype.contains) {\n  // Define contains method\n  Node.prototype.contains = function (node) {\n    // While node given is not the one we are looking for\n    while (node !== null) {\n      // If given node matches the node we are looking for\n      if (node === this) {\n        // Return true\n        return true;\n      }\n      // Check the parent node\n      node = node.parentNode;\n    }\n    // Return false if a match is not found\n    return false;\n  };\n}",
    term: "Node.prototype.contains",
    explain:
      "\n\n// This code checks if the browser supports Node.prototype.contains. \n// If not, it defines the contains method which enables the browser to check if a given node matches the node it is looking for. \n// The contains method loops through the parent node until a match is found or until it reaches the top of the node tree. \n// If a match is found, it returns true, otherwise it returns false.",
    useCase:
      "\n\nNode.prototype.contains is used in Javascript to determine if a given node is a descendant of another node. This method can be used to check if a child node is contained within its parent node, or if a node contains a particular element. It is useful for traversing a DOM tree and can be used to check if a node is a descendant of a parent node, or if a node is a sibling.",
  },
  {
    code: "\n\nif (!Node.prototype.isSameNode) {\n  Node.prototype.isSameNode = function(node) {\n    return this === node;\n  }\n}",
    term: "Node.prototype.isSameNode",
    explain:
      "\n\n// Line 1: This line checks if the Node prototype object has the isSameNode method. \n// If it does not, then the following code is executed.\n\n// Line 2: This line adds the isSameNode method to the Node prototype object. \n// The method takes in a node as a parameter and returns true if the two nodes are the same.",
    useCase:
      "\n\nNode.prototype.isSameNode is used in Javascript to compare two nodes to determine if they are the same. This method returns a boolean value, true if the nodes are the same, and false if they are not. This helps developers to quickly and easily determine if two nodes are equal.",
  },
  {
    code: "\n\nif(NodeList.prototype.@@iterator === undefined){\n  NodeList.prototype[Symbol.iterator] = function(){\n    let _this = this;\n    let _index = 0;\n    return {\n      next(){\n        if(_index < _this.length){\n          return {\n            value: _this[_index++],\n            done: false\n          };\n        }\n        else{\n          return {\n            done: true\n          };\n        }\n      }\n    };\n  };\n}",
    term: "NodeList.prototype.@@iterator",
    explain:
      "\n\n// if NodeList.prototype.@@iterator is equal to undefined \n// then assign a function to NodeList.prototype[Symbol.iterator]\n// this function takes no arguments\n// it creates a variable called _this and assigns it to this\n// it creates a variable called _index and assigns it to 0\n// it then returns an object\n// this object has a next function which takes no arguments\n// if _index is less than the length of _this, return an object\n// this object has a value property which is the value of _this at the index of _index and increment _index\n// the object has a done property which is set to false\n// else return an object with done set to true",
    useCase:
      "\n\nNodeList.prototype.@@iterator is used in Javascript to provide an iterator for NodeList objects. This allows developers to easily loop through NodeList objects and access their contents using the for...of syntax. It also helps improve the performance of NodeList operations, as the iterator will only traverse the list once instead of multiple times.",
  },
  {
    code: "\n\nif (window.NodeList && !NodeList.prototype.forEach) {\n  NodeList.prototype.forEach = function(callback, thisArg) {\n    thisArg = thisArg || window;\n    for (var i = 0; i < this.length; i++) {\n      callback.call(thisArg, this[i], i, this);\n    }\n  };\n}",
    term: "NodeList.prototype.forEach",
    explain:
      "\n\n//line 1: \n//This line checks if the window object has a NodeList property and if there is no forEach method in the NodeList prototype. \n\n//line 2: \n//This line adds a forEach method to the NodeList prototype. \n\n//line 3: \n//This line sets the thisArg variable to either the window object or the argument passed in. \n\n//line 4: \n//This line creates a for loop that iterates over the NodeList and passes each element, the index of the element, and the NodeList itself to the callback function. \n\n//line 5: \n//This line calls the callback function with the thisArg variable as the context, the current element, the index of the element, and the NodeList itself. ",
    useCase:
      "\n\nNodeList.prototype.forEach is used in Javascript because it provides the ability to iterate over all the elements in a NodeList, which is a collection of nodes returned from a DOM query. It allows developers to execute a function on each of the elements in the NodeList, making it easier to apply certain changes or logic to multiple elements quickly and easily.",
  },
  {
    code: "\n\nif(Number.EPSILON === undefined) {\n    Number.EPSILON = Math.pow(2, -52);\n}",
    term: "Number.EPSILON",
    explain:
      "\n\n// This line of code checks if Number.EPSILON is undefined. If it is, it assigns Number.EPSILON to the value of Math.pow(2, -52). This is done to define the smallest value possible for a number in JavaScript.",
    useCase:
      "\n\nNumber.EPSILON is used in JavaScript to represent the smallest possible number that can be represented in the language. This is important for accurately comparing two numbers, especially when precise calculations are required. It helps to ensure that any comparison between two numbers is as precise as possible, and that any calculations involving fractions are handled accurately.",
  },
  {
    code: "\n\nif (!Number.Epsilon) {\n  Number.Epsilon = Math.pow(2, -52);\n}",
    term: "Number.Epsilon",
    explain:
      "\n\n// Line 1: This line is a conditional statement that checks if the constant Number.Epsilon has been defined.\n// Line 2: If the constant Number.Epsilon is not defined, this line will define it as the result of the Math.pow() function, which takes a base and an exponent and returns the result of raising the base to the power of the exponent. In this case, 2 is the base and -52 is the exponent, so the result is a very small number (2^-52).",
    useCase:
      "\n\nNumber.Epsilon is used in JavaScript to represent the difference between the largest possible number that can be represented in the JavaScript Number type and the number that is one greater. It is a very small number (approximately 2.220446049250313e-16) and is used in calculations to ensure that the result is accurate to the smallest degree possible. It is also used to determine if two numbers are equal, as adding or subtracting Number.Epsilon to either number will not change the result.",
  },
  {
    code: "\n\nif (Number.MAX_SAFE_INTEGER === undefined) {\n    Number.MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n}",
    term: "Number.MAX_SAFE_INTEGER",
    explain:
      "\n\n// Line 1: This line checks if the constant Number.MAX_SAFE_INTEGER has been defined. If it has not been defined then the code moves to line 2. \n// Line 2: This line sets the constant Number.MAX_SAFE_INTEGER to the value of Math.pow(2, 53) - 1. This is the highest value that can be represented accurately in JavaScript.",
    useCase:
      "\n\nNumber.MAX_SAFE_INTEGER is used in Javascript to ensure that arithmetic operations performed with numbers within the range of this constant are accurate. It defines the maximum safe integer in JavaScript which is (2^53 - 1). This number is the maximum safe integer that can be reliably used in mathematical operations in JavaScript, as numbers larger than this may lose precision when being operated on.",
  },
  {
    code: "\n\nif (!Number.MIN_SAFE_INTEGER) {\n\tNumber.MIN_SAFE_INTEGER = -Math.pow(2, 53) - 1;\n}",
    term: "Number.MIN_SAFE_INTEGER",
    explain:
      "\n\nLine 1: This line performs a logical check to see if the Number.MIN_SAFE_INTEGER variable has been previously declared. If it has not been declared, the code will proceed to line 2.\n\nLine 2: If the Number.MIN_SAFE_INTEGER variable has not been declared, then this line sets its value to the maximum safe integer value that can be represented in JavaScript. This value is calculated by subtracting 1 from the result of 2 raised to the power of 53. The result is the lowest safe integer that can be represented in JavaScript.",
    useCase:
      "\n\nNumber.MIN_SAFE_INTEGER is used in Javascript as it provides a consistent lower bound for safe integer operations. This is important as the native Number type in Javascript can only represent numbers up to a certain precision, which can lead to unexpected results when dealing with very large or very small numbers. By providing a consistent lower bound, Number.MIN_SAFE_INTEGER helps ensure that any operations involving numbers outside of the safe range will be properly handled.",
  },
  {
    code: "\n//\nfunction isFinite(value) {\n  if (value === Infinity || value === -Infinity || typeof value !== 'number') {\n    return false;\n  }\n  return !Number.isNaN(value);\n}",
    term: "Number.isFinite",
    explain:
      "\n\n//This function will check if the given value is finite or not.\n//Line 1: The function is named isFinite and takes a value as a parameter.\n//Line 2: If the value is equal to Infinity, negative Infinity, or not a number, it will return false.\n//Line 3: If the value is not one of the above, it will check to see if it is not NaN (not a number) and return the result.",
    useCase:
      "\n\nNumber.isFinite is used in JavaScript to determine whether a given value is a finite number. It is a convenient method for validating user input and ensuring that the values are within the valid range. It is also useful for preventing overflows and underflows by checking if a number is too small or too large.",
  },
  {
    code: "\n\nNumber.isInteger = Number.isInteger || function(value) {\n  return typeof value === 'number' && \n         isFinite(value) && \n         Math.floor(value) === value;\n};",
    term: "Number.isInteger",
    explain:
      '\n\n// 1. Number.isInteger = Number.isInteger || \n// This line creates a function called isInteger and assigns it to the Number object. This line also uses the logical OR operator (||) to check if the function already exists and if it does, it assigns it to the Number object.\n\n// 2. function(value) {\n// This line defines a function that takes in a single argument, which is referred to as "value".\n\n// 3. return typeof value === \'number\' && \n// This line returns the type of the "value" argument and checks whether it is a number.\n\n// 4. isFinite(value) && \n// This line checks if the argument "value" is a finite number.\n\n// 5. Math.floor(value) === value;\n// This line uses the Math.floor() method to round down the "value" argument to the nearest integer and then checks if it is equal to the original argument.',
    useCase:
      "\n\nNumber.isInteger is used in JavaScript to determine whether a value is an integer or not. This is helpful when validating user input, as it can quickly determine if a value is an integer or not without having to manually check for a decimal point. It is also useful for ensuring that mathematical operations are being performed on integer values, as it can prevent errors from occurring due to working with non-integer values.",
  },
  {
    code: "\n\nif (Number.isNaN === undefined) {\n  Number.isNaN = function (value) {\n    return typeof value === 'number' && isNaN(value);\n  };\n}",
    term: "Number.isNaN",
    explain:
      "\n\n// line 1: This line checks if the Number.isNaN function is defined or not.\n// line 2: If Number.isNaN is undefined, then this line defines the function.\n// line 3: This line is the body of the Number.isNaN function. It checks if the value given as an argument is a number and is NaN (not a number).",
    useCase:
      "\n\nNumber.isNaN is used in JavaScript to determine whether a value is NaN (Not-a-Number). It is important to know that JavaScript's typeof operator considers NaN to be a number, so this method can be used to differentiate between a number and NaN.",
  },
  {
    code: "\n\nif(Number.isSafeInteger === undefined){\n  Number.isSafeInteger = function(n){\n    return typeof n === 'number' && \n      Math.round(n) === n && \n      n >= Number.MIN_SAFE_INTEGER &&\n      n <= Number.MAX_SAFE_INTEGER;\n  };\n}",
    term: "Number.isSafeInteger",
    explain:
      "\n\n// Line 1: This line is checking if the Number.isSafeInteger function is already defined. \n// If it is not, the code will proceed to the next line. \n\n// Line 2: This line is defining the Number.isSafeInteger function. It will be used to check if a number is a safe integer.\n\n// Line 3: This line is checking if the input number is of type number.\n\n// Line 4: This line is checking if the input number is equal to itself after rounding.\n\n// Line 5: This line is checking if the input number is greater than or equal to the minimum safe integer.\n\n// Line 6: This line is checking if the input number is less than or equal to the maximum safe integer.",
    useCase:
      "\n\nNumber.isSafeInteger is used in Javascript to determine whether a given value is a safe Integer. This is important because some numbers, when represented as floating point numbers, can produce inaccurate results due to rounding errors. By using Number.isSafeInteger, developers can ensure that they are working with a number that can be accurately represented and is not susceptible to these errors.",
  },
  {
    code: "\n\nif (!Number.parseFloat) {\n  Number.parseFloat = function(n) {\n    return parseFloat(n);\n  };\n}",
    term: "Number.parseFloat",
    explain:
      "\n\n// Line 1: This checks to see if the parseFloat() function is available on the Number object. If it is not available, \n// then it will proceed to the next line.\n\n// Line 2: This creates the parseFloat() function on the Number object, if it was not previously available. It is a \n// function that takes in a number as a parameter and returns the parsed float value.",
    useCase:
      "\n\nNumber.parseFloat is used in JavaScript to convert a string into a floating-point number. This function is useful for ensuring that a value entered by a user is a valid number, as it will return NaN if the string provided is not a valid number. It is also useful when dealing with decimal numbers, as it can convert the string into a decimal number, rather than an integer.",
  },
  {
    code: "\n\nif (!Number.parseInt) {\n    Number.parseInt = function(value, radix) {\n        if (radix == null) {\n            radix = 10;\n        }\n        var string = \"\" + value;\n        var result = +string.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n        if ((!isFinite(result) || result < -90 || result > 90) ||\n            (radix < 2 || radix > 36)) {\n            return NaN;\n        }\n        return parseInt(result, radix);\n    }\n}",
    term: "Number.parseInt",
    explain:
      "\n\n// Line 1:\n// This line checks if the Number.parseInt function is already defined. If it isn't, then the code in the code block will be executed. \n\n// Line 2:\n// This line defines the Number.parseInt function. The value and radix parameters are passed as arguments.\n\n// Line 3:\n// This line assigns the radix parameter a default value of 10, if it is not provided.\n\n// Line 4:\n// This line assigns the string variable the value of the argument passed to the function.\n\n// Line 5:\n// This line uses the replace() method to remove any whitespace characters from the start and end of the string. It then assigns the resulting string to the result variable.\n\n// Line 6:\n// This line checks if the result is a valid number, if it is less than -90 or greater than 90, or if the radix is less than 2 or greater than 36. If any of these conditions are true, the function returns NaN.\n\n// Line 8:\n// This line calls the built-in parseInt() function, passing it the result and the radix as arguments. The result of this function call is then returned.",
    useCase:
      "\n\nNumber.parseInt is used in Javascript to convert a string or a number represented as a string into an integer. This is useful for ensuring that numbers are properly formatted before they are used in calculations or other operations.",
  },
  {
    code: "\n\nif (typeof Object.assign != 'function') {\n    Object.assign = function(target) {\n        'use strict';\n        if (target == null) {\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        target = Object(target);\n        for (var index = 1; index < arguments.length; index++) {\n            var source = arguments[index];\n            if (source != null) {\n                for (var key in source) {\n                    if (Object.prototype.hasOwnProperty.call(source, key)) {\n                        target[key] = source[key];\n                    }\n                }\n            }\n        }\n        return target;\n    };\n}",
    term: "Object.assign",
    explain:
      "\n\n// Line 1: Check if Object.assign is a function.\n// Reason: Object.assign is a function to copy the values of all enumerable own properties from one or more source objects to a target object. \n\n// Line 2-17: If Object.assign is not a function, then define a new function.\n// Reason: Define a new function for Object.assign if it is not a function.\n\n// Line 3: Declare a target variable.\n// Reason: Declare a target variable which will be an object.\n\n// Line 4: Use strict mode.\n// Reason: Use strict mode so that variables must be declared before use.\n\n// Line 5: Check if the target is undefined or null.\n// Reason: Check if the target is undefined or null.\n\n// Line 6: Make sure the target is an object.\n// Reason: Make sure the target is an object.\n\n// Line 7: Create a loop to iterate through the arguments.\n// Reason: Create a loop to iterate through the arguments.\n\n// Line 8: Declare a source variable.\n// Reason: Declare a source variable which will be an object.\n\n// Line 9: Check if the source is undefined or null.\n// Reason: Check if the source is undefined or null.\n\n// Line 10-15: Loop through the source object and copy the properties and values to the target object.\n// Reason: Loop through the source object and copy the properties and values to the target object.\n\n// Line 16: Return the target object.\n// Reason: Return the target object.",
    useCase:
      "\n\nObject.assign is used in JavaScript to merge the contents of two or more objects together into a single object. This can be useful for copying the values of one object to another, or for combining multiple objects into a single object to be used. It can also be useful when you need to create a new object based on the properties of existing objects.",
  },
  {
    code: "\n\nif (!Object.create) {\n  Object.create = function(o) {\n    if (arguments.length > 1) {\n      throw new Error ('Object.create implementation only accepts the first parameter.');\n    }\n    function F() {}\n    F.prototype = o;\n    return new F();\n  };\n}",
    term: "Object.create",
    explain:
      "\n\n//This line checks if the Object.create method has already been defined. If it hasn't, the subsequent code block will be executed. \nif (!Object.create) {\n\n//This line creates a function called Object.create that takes one parameter, o.\nObject.create = function(o) {\n\n//This line checks if the number of arguments passed to Object.create is greater than 1. If it is, an error will be thrown.\nif (arguments.length > 1) {\n  throw new Error ('Object.create implementation only accepts the first parameter.');\n}\n\n//This line creates a function called F.\nfunction F() {}\n\n//This line sets the prototype of F to o.\nF.prototype = o;\n\n//This line returns a new instance of F. \nreturn new F();\n};\n}",
    useCase:
      "\n\nObject.create is used to create an object with the prototype of a given object. It allows for more precise control over how an object is created and what its prototype will be. This is especially useful in inheritance-based programming, as it allows for the creation of objects that have the same properties and behaviors of another object. This is useful for implementing inheritance-based design patterns, such as the prototype pattern, or creating objects with shared functionality.",
  },
  {
    code: "\n\nObject.defineProperties = Object.defineProperties || function(obj, props) {\n  for (var prop in props) {\n    Object.defineProperty(obj, prop, props[prop]);\n  }\n  return obj;\n};",
    term: "Object.defineProperties",
    explain:
      "\n\n//Line 1: This line is checking whether the Object.defineProperties function is already defined. If it is not, it assigns the function definition on the right side of the operator to Object.defineProperties. \n//Line 2: This is the start of the function definition. The function takes two arguments: obj and props.\n//Line 3: This line is a for loop that iterates through each property in the props object.\n//Line 4: This line calls the Object.defineProperty function to define a new property on the obj object. The property's name is taken from the prop variable and its value is taken from the props object.\n//Line 5: This line returns the obj object.",
    useCase:
      "\n\nObject.defineProperties is used in JavaScript to add new or modify existing properties directly on an object. It allows for the addition of getters and setters to an object, which can be used to control how the property is accessed and set. It also allows for the addition of new properties to an object, and can be used to define multiple properties at once on an object. This makes it a useful tool for creating custom objects with specific properties and behaviors.",
  },
  {
    code: "\n\nif (!Object.defineProperty) {\n    Object.defineProperty = function (obj, prop, descriptor) {\n        if (descriptor.get) {\n            obj.__defineGetter__(prop, descriptor.get);\n        }\n        if (descriptor.set) {\n            obj.__defineSetter__(prop, descriptor.set);\n        }\n        if (!descriptor.configurable) {\n            obj[prop] = descriptor.value;\n        }\n    }\n}",
    term: "Object.defineProperty",
    explain:
      "\n\n//Line 1\n//This line checks if the Object.defineProperty function is available in the current environment. If it is not available, the code within the if statement will be executed.\n\n//Line 2\n//This line creates a function called Object.defineProperty and assigns it to the Object object.\n\n//Line 3\n//This line checks if the descriptor passed to the function has a get property. If it does, the code within the if statement will be executed.\n\n//Line 4\n//This line assigns the descriptor's get property to the obj's __defineGetter__ property.\n\n//Line 5\n//This line checks if the descriptor passed to the function has a set property. If it does, the code within the if statement will be executed.\n\n//Line 6\n//This line assigns the descriptor's set property to the obj's __defineSetter__ property.\n\n//Line 7\n//This line checks if the descriptor passed to the function has a configurable property set to false. If it does, the code within the if statement will be executed.\n\n//Line 8\n//This line assigns the descriptor's value to the obj's property.",
    useCase:
      "\n\nObject.defineProperty is used in Javascript to define a new property on an object, or modify an existing property on an object. It allows for precise control over how the property is defined, including its enumerability, configurability, and writability. Additionally, it allows for the use of accessor properties, which are properties that don't actually store a value but instead execute a getter and setter function when accessed.",
  },
  {
    code: "\n\nif (!Object.entries) {\n  Object.entries = function(obj) {\n    var ownProps = Object.keys(obj),\n        i = ownProps.length,\n        resArray = new Array(i); // preallocate the Array\n    while (i--)\n      resArray[i] = [ownProps[i], obj[ownProps[i]]];\n  \n    return resArray;\n  };\n}",
    term: "Object.entries",
    explain:
      "\n\n// Line 1: \n// This is a conditional statement that checks if a function called Object.entries() exists. \n\n// Line 2:\n// If Object.entries does not exist, then this line of code creates a new function called Object.entries which takes in one parameter called obj.\n\n// Line 3:\n// This line creates a variable called ownProps which stores an array of strings that represent the keys of the object.\n\n// Line 4:\n// This line creates a variable called i and sets its value to the length of the array stored in ownProps.\n\n// Line 5:\n// This line creates a new array called resArray and sets its length to the value of the variable i.\n\n// Line 6-8:\n// This loop iterates through the array stored in ownProps, and assigns the key and the value of the obj to an element in the resArray. \n\n// Line 9:\n// This line returns the resArray.",
    useCase:
      "\n\nObject.entries is used in Javascript to convert an object into an array of key-value pairs. It allows developers to quickly and easily access the keys and values of an object. This is especially useful for looping through objects to access their properties or for performing tasks on each item in an object.",
  },
  {
    code: "\n\nif (!Object.freeze) {\n\tObject.freeze = function (obj) {\n\t\t// Retrieve the property names defined on obj\n\t\tvar propNames = Object.getOwnPropertyNames(obj);\n\n\t\t// Freeze properties before freezing self\n\t\tpropNames.forEach(function (name) {\n\t\t\tvar prop = obj[name];\n\n\t\t\t// Freeze prop if it is an object\n\t\t\tif (typeof prop == 'object' && prop !== null) {\n\t\t\t\tObject.freeze(prop);\n\t\t\t}\n\t\t});\n\n\t\t// Freeze self (no-op if already frozen)\n\t\treturn Object.seal(obj);\n\t};\n}",
    term: "Object.freeze",
    explain:
      "\n\n//This code checks to see if the `Object.freeze` method exists, and if it doesn't then it creates a new function that will freeze an object.\n\n//Line 1:\n//Checks if the `Object.freeze` method already exists. If it doesn't then the code inside the `if` statement will be executed.\n\n//Line 2:\n//Creates a new function called `Object.freeze` that takes in a parameter called `obj`.\n\n//Line 3:\n//Retrieves the property names of the object passed in as the parameter within the `Object.freeze` function.\n\n//Line 4-8:\n//Iterates through each of the property names and checks if the type of the property is an object and if it isn't `null`. If it is, then it calls the `Object.freeze` method on the property.\n\n//Line 9:\n//Seal the object passed in as the parameter within the `Object.freeze` function. This will freeze the object so that its properties cannot be changed.",
    useCase:
      "\n\nObject.freeze is used in JavaScript to prevent any existing properties from being changed or removed from an object. This prevents the object from being modified and helps keep data secure and consistent. This method is useful for preventing accidental or malicious changes to an object, and is often used for configuration objects or objects that are shared between multiple users or applications.",
  },
  {
    code: "\n\n\nconst fromEntries = (arr) => \n  arr.reduce((acc, [key, val]) => (acc[key] = val, acc), {})",
    term: "Object.fromEntries",
    explain:
      "\n\n//1. const fromEntries = (arr) => \n// This line declares a constant called fromEntries and sets it equal to a function that takes one parameter called arr.\n\n//2. arr.reduce((acc, [key, val]) => \n//This line calls the reduce method on the arr parameter. The reduce method takes two arguments, an accumulator (acc) and an array containing two elements, the first of which is the key and the second of which is the value.\n\n//3. (acc[key] = val, acc)\n// This line sets the value of the key in the accumulator to the value passed in, and then returns the accumulator.\n\n//4. {}\n// This line is the initial value for the accumulator. It is an empty object.",
    useCase:
      "\n\nObject.fromEntries is used in JavaScript to convert an iterable (such as an Array or Map) of key-value pairs into an object. This can be useful when you need to convert existing data into an object, or when you are working with an API that returns an array of data and you need to parse it into an object.",
  },
  {
    code: "\n\nif (!Object.getOwnPropertyDescriptor) {\n  Object.getOwnPropertyDescriptor = function(obj, prop) {\n    const descriptor = {\n      enumerable: Object.prototype.propertyIsEnumerable.call(obj, prop),\n      configurable: true\n    };\n    let getter = obj.__lookupGetter__(prop);\n    let setter = obj.__lookupSetter__(prop);\n\n    if (getter || setter) {\n      if (getter) {\n        descriptor.get = getter;\n      }\n\n      if (setter) {\n        descriptor.set = setter;\n      }\n    } else {\n      descriptor.value = obj[prop];\n    }\n\n    return descriptor;\n  };\n}",
    term: "Object.getOwnPropertyDescriptor",
    explain:
      "\n\n// Line 1: \n// If the browser does not have the Object.getOwnPropertyDescriptor method, then create the function.\n\n// Line 2: \n// Create an object descriptor, which will be returned by the function. The descriptor will have two properties, enumerable and configurable, both of which will be set to true.\n\n// Line 3:\n// Get the getter and setter for the specified property if they exist.\n\n// Line 4-7:\n// If the getter or setter exist, then create an object descriptor with the get and set properties set to the getter and setter.\n\n// Line 8-10:\n// If the getter or setter don't exist, then the value of the property will be used.",
    useCase:
      "\n\nObject.getOwnPropertyDescriptor is used to retrieve the property descriptor of an object for a given property. It provides information about the property such as whether it is writable, enumerable, configurable and its value. This method is useful for inspecting an object's properties, or for creating a duplicate of an existing object with the same property descriptors. It can also be used to modify the behavior of existing objects by changing their property descriptors.",
  },
  {
    code: "\n\n// polyfill for Object.getOwnPropertyDescriptors\nif (!Object.getOwnPropertyDescriptors) {\n\n\tObject.getOwnPropertyDescriptors = function(obj) {\n\t\tconst descriptors = {};\n\n\t\tObject.getOwnPropertyNames(obj).forEach(function(propName) {\n\t\t\tdescriptors[propName] = Object.getOwnPropertyDescriptor(obj, propName);\n\t\t});\n\n\t\treturn descriptors;\n\t};\n}",
    term: "Object.getOwnPropertyDescriptors",
    explain:
      "\n\n// This code is creating a polyfill for the Object.getOwnPropertyDescriptors function which is used to get the property descriptors of an object.\n// Line 1: This line is declaring an if statement to check if the Object.getOwnPropertyDescriptors function already exists.\n// Line 2: If the function doesn't exist, the code in the block will be executed. It assigns the Object.getOwnPropertyDescriptors function to an anonymous function.\n// Line 3: This line declares a descriptor object, which will be used to store the property descriptors of the object.\n// Line 4: This line calls the Object.getOwnPropertyNames function to get an array of all the property names of the object.\n// Line 5: This line calls the forEach method on the array of property names, and runs the callback function for each property name. The callback function assigns the property descriptor of each property to the descriptor object.\n// Line 6: This line returns the descriptor object.",
    useCase:
      "\n\nObject.getOwnPropertyDescriptors is used in Javascript to get the full descriptors of all properties which are directly on a given object. It returns an object containing all own property descriptors of an object. This is useful as it allows you to access the properties of an object in a more efficient way than using Object.keys or Object.getOwnPropertyNames. It also allows you to get more detailed information about a particular property, such as its value, writability, and enumerability.",
  },
  {
    code: "\n\n/* polyfill implementation of Object.getOwnPropertyNames() */\nif (!Object.prototype.hasOwnProperty('getOwnPropertyNames')) {\n    Object.getOwnPropertyNames = function (obj) {\n        let arr = [];\n        for (let key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                arr.push(key);\n            }\n        }\n        return arr;\n    };\n}",
    term: "Object.getOwnPropertyNames",
    explain:
      "\n\n// This code is creating a polyfill implementation of the Object.getOwnPropertyNames() method.\n\n// Line 1: This line is declaring a condition to check if the Object.prototype already has the getOwnPropertyNames() method.\n// Line 2: If the condition is false, then it assigns the getOwnPropertyNames() function to the Object prototype.\n// Line 3: It creates an empty array to store the property names of the object.\n// Line 4: It iterates through the object and adds the property names that the object has to the array.\n// Line 5: It returns the array with the property names.",
    useCase:
      "\n\nObject.getOwnPropertyNames() is used in JavaScript to retrieve an array of all the properties (including non-enumerable ones) of a given object. It can be used to loop through the object's properties, as well as to check if a certain property exists in an object. It is especially useful for debugging and understanding the various properties of an object.",
  },
  {
    code: "\n\nif (!Object.getOwnPropertySymbols) {\n  Object.getOwnPropertySymbols = function(obj) {\n    var props = Object.getOwnPropertyNames(obj);\n    var symbols = [];\n    for (var i = 0; i < props.length; i++) {\n      var property = props[i];\n      if (typeof obj[property] === 'symbol') {\n        symbols.push(obj[property]);\n      }\n    }\n    return symbols;\n  };\n}",
    term: "Object.getOwnPropertySymbols",
    explain:
      "\n\n// Line 1: This line checks if the Object.getOwnPropertySymbols function already exists. If it does not exist, the code will continue to the next line. \n// Line 2: This line defines the Object.getOwnPropertySymbols function. \n// Line 3: This line creates an array with all of the properties of the object passed in as an argument. \n// Line 4: This line creates an empty array to store the symbols found in the object. \n// Line 5: This loop iterates through all of the properties of the object. \n// Line 6: This line stores the current property in the loop in the property variable. \n// Line 7: This line checks if the property is a symbol. \n// Line 8: If the property is a symbol, it is added to the symbols array. \n// Line 9: This line returns the array of symbols. \n// Line 10: This line closes the if statement.",
    useCase:
      "\n\nObject.getOwnPropertySymbols is used to retrieve the symbol properties of an object. Symbols are a new data type introduced in ES6 which allow for unique, immutable properties that are not accessible via normal object key lookup. This can be useful for creating private data that can be associated with an object and accessed via a unique symbol.",
  },
  {
    code: "\n\nif (typeof Object.getPrototypeOf != \"function\") {\n    Object.getPrototypeOf = function(object) {\n        if (object === null) {\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n        return object.__proto__ || object.constructor.prototype;\n    };\n}",
    term: "Object.getPrototypeOf",
    explain:
      "\n\n// Line 1: This line checks if the Object.getPrototypeOf function exists. If it does not exist, then it will go to the next line.\n\n// Line 2: This line creates a function called Object.getPrototypeOf that takes in an object as a parameter.\n\n// Line 3: This line checks if the object is null. If it is, then it will throw an error.\n\n// Line 4: This line returns the object's prototype or the object's constructor's prototype.",
    useCase:
      "\n\nObject.getPrototypeOf is used in Javascript to retrieve the prototype (i.e. the internal [[Prototype]] property) of an object. This can be useful for inspecting the prototype chain of an object, or for comparing the prototype of one object to the prototype of another. This method is also useful for determining the type of an object, as the prototype of an object is used to determine its type.",
  },
  {
    code: "\n\nif (!Object.is) {\n  Object.is = function(x, y) {\n    if (x === y) {\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      return x !== x && y !== y;\n    }\n  };\n}",
    term: "Object.is",
    explain:
      "\n\n// Line 1: This line checks if an is method is already defined in the Object object. If not, it will move to the next line. \n// Line 2: This line defines the is method in the Object object, which will compare two values and return a boolean value. \n// Line 3: This line checks if the two values are strictly equal (using the triple equals operator). If so, it will move to the next line. \n// Line 4: This line checks if either of the two values are 0 and if so, it will compare the two values using 1/x and 1/y. \n// Line 5: This line checks if the two values are not strictly equal (using the triple not-equals operator). If so, it will move to the next line. \n// Line 6: This line checks if either of the two values are NaN and if so, it will return true. \n// Line 7: This line closes the if/else statement. \n// Line 8: This line closes the Object.is function. \n// Line 9: This line closes the if statement.",
    useCase:
      "\n\nObject.is is used in Javascript to determine whether two values are the same or not. It is a more accurate comparison than the standard equality operator (==) as it takes into account special cases, such as NaN and -0, that the operator does not. It is useful for checking for exact equality of two values in certain situations, such as when testing for the same object reference.",
  },
  {
    code: "\n\nif (!Object.isExtensible) {\n    Object.isExtensible = function (obj) {\n        if (Object(obj) !== obj) {\n            throw new TypeError('Object.isExtensible can only be called on Objects.');\n        }\n        if (Object.isExtensible(Object.getPrototypeOf(obj))) {\n            var props = Object.getOwnPropertyNames(obj);\n            for (var i = 0; i < props.length; i++) {\n                var propDesc = Object.getOwnPropertyDescriptor(obj, props[i]);\n                if (propDesc && (propDesc.configurable === false || propDesc.writable === false)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    };\n}",
    term: "Object.isExtensible",
    explain:
      "\n\n// Line 1: This line checks if Object.isExtensible is defined. If it is not defined, the function in the following lines will be used as the definition of Object.isExtensible.\n// Line 2: This line defines the function Object.isExtensible with one argument, obj.\n// Line 3: This line checks if obj is an Object, and if it is not, it throws a TypeError.\n// Line 4: This line checks if the prototype of obj is extensible.\n// Line 5: This line gets the list of own properties of obj.\n// Line 6: This loop iterates over the list of own properties of obj.\n// Line 7: This line gets the property descriptor of the current property.\n// Line 8: This line checks if the property is configurable or writable. If it is not, the function returns false.\n// Line 9: This line returns true if the property is configurable and writable.\n// Line 10: This line returns false if the prototype of obj is not extensible.",
    useCase:
      "\n\nObject.isExtensible is used in JavaScript to determine if an object can have additional properties added to it. It returns a Boolean (true or false) depending on the object's extensibility. This is useful for preventing accidental changes to an object, as well as for determining if a given object can be extended.",
  },
  {
    code: "\n\nif (!Object.isFrozen) {\n    Object.isFrozen = function(obj) {\n        if (obj === null || typeof obj !== 'object') return true;\n        if (Object.isExtensible(obj)) return false;\n        let props = Object.getOwnPropertyNames(obj);\n        for (let i = 0; i < props.length; i++) {\n            let desc = Object.getOwnPropertyDescriptor(obj, props[i]);\n            if (desc.writable || desc.configurable) {\n                return false;\n            }\n        }\n        return true\n    }\n}",
    term: "Object.isFrozen",
    explain:
      "\n\n// Line 1: if (!Object.isFrozen) { \n// Checks if a method named 'isFrozen' does not exist on the Object object. \n\n// Line 2: Object.isFrozen = function(obj) {\n// If a method named 'isFrozen' does not exist, a new function is created and set on the Object object. The function takes an object as an argument. \n\n// Line 3: if (obj === null || typeof obj !== 'object') return true;\n// Checks if the object argument is either null or not an object. If it is, it returns true. \n\n// Line 4: if (Object.isExtensible(obj)) return false;\n// Checks if the object argument is extensible. If it is, it returns false. \n\n// Line 5: let props = Object.getOwnPropertyNames(obj);\n// Creates a variable named 'props' that stores an array of strings representing the names of all the own properties of the object argument. \n\n// Line 6-9: for (let i = 0; i < props.length; i++) {\n//            let desc = Object.getOwnPropertyDescriptor(obj, props[i]);\n//            if (desc.writable || desc.configurable) {\n//                return false;\n//            }\n// Iterates over the array of property names and for each property, gets its descriptor object. If either the writable or configurable property of the descriptor object is true, it returns false. \n\n// Line 10: return true\n// If none of the properties of the object argument are writable or configurable, it returns true.",
    useCase:
      "\n\nObject.isFrozen is used in JavaScript to determine if an object is frozen or not. A frozen object is one that has been made non-extensible, and whose properties are all non-writable and non-configurable. This helps to ensure that the object cannot be modified in any way, ensuring that its data remains immutable.",
  },
  {
    code: "\n\nif (!Object.isSealed) {\n  Object.isSealed = function (object) {\n    if (Object(object) !== object) {\n      throw new TypeError('Object.isSealed can only be called on Objects.');\n    }\n    return !!Object.isExtensible(object) && Object.getOwnPropertyNames(object).every(function (p) {\n      return Object.getOwnPropertyDescriptor(object, p).configurable === false;\n    });\n  };\n}",
    term: "Object.isSealed",
    explain:
      '\n\n// Line 1: \n// This line checks if "Object.isSealed" is already defined. If it is not, the rest of the code will be executed.\n\n// Line 2:\n// This line defines the function "Object.isSealed".\n\n// Line 3:\n// This line checks if the given argument is an Object. If it is not, it will throw a TypeError.\n\n// Line 4:\n// This line returns a boolean value which is the result of two conditions. \n// First, it checks if the object is extensible. \n// Second, it checks if all of the object\'s properties are non-configurable.\n\n// Line 5: \n// This line checks if the given property of the object is configurable.',
    useCase:
      "\n\nObject.isSealed is used to determine if an object is sealed or not. Sealing an object prevents new properties from being added to it and marks all existing properties as non-configurable. Object.isSealed is useful for ensuring that an object cannot be modified after it has been created, which can be useful for maintaining the integrity of data.",
  },
  {
    code: "\n\nif (!Object.keys) {\n  Object.keys = (function () {\n    'use strict';\n    var hasOwnProperty = Object.prototype.hasOwnProperty,\n        hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString'),\n        dontEnums = [\n          'toString',\n          'toLocaleString',\n          'valueOf',\n          'hasOwnProperty',\n          'isPrototypeOf',\n          'propertyIsEnumerable',\n          'constructor'\n        ],\n        dontEnumsLength = dontEnums.length;\n \n    return function (obj) {\n      if (typeof obj !== 'function' && (typeof obj !== 'object' || obj === null)) {\n        throw new TypeError('Object.keys called on non-object');\n      }\n \n      var result = [], prop, i;\n \n      for (prop in obj) {\n        if (hasOwnProperty.call(obj, prop)) {\n          result.push(prop);\n        }\n      }\n \n      if (hasDontEnumBug) {\n        for (i = 0; i < dontEnumsLength; i++) {\n          if (hasOwnProperty.call(obj, dontEnums[i])) {\n            result.push(dontEnums[i]);\n          }\n        }\n      }\n      return result;\n    };\n  }());\n}",
    term: "Object.keys",
    explain:
      "\n\n// Line 1:\n// This line checks to see if the Object.keys method is already defined. If it is not, then the function that follows is used to define it.\n\n// Line 2 - 14: \n// This block of code is used to define the Object.keys method if it does not already exist. It starts by creating variables that will be used within the function, which includes hasOwnProperty to check if an object has a specific property, hasDontEnumBug to see if the object has a 'toString' property, dontEnums which is an array containing a list of properties, and dontEnumsLength which is the length of the dontEnums array. \n\n// Line 16 - 18:\n// This block of code checks the type of the object passed into the function and throws an error if it is not a function or object type.\n\n// Line 20 - 25:\n// This block of code is used to loop through the object and push any of the properties that are found into the result array. \n\n// Line 27 - 33:\n// This block of code is used to check if the object has a 'toString' property. If it does, then it will be added to the result array.\n\n// Line 35:\n// This line returns the result array which contains the properties of the object.",
    useCase:
      "\n\nObject.keys is used in Javascript to retrieve an array of the given object's own enumerable property names. This can be useful for iterating over an object's properties, or for creating an array of property names from an object instance.",
  },
  {
    code: "\n\nObject.preventExtensions = function(obj) {\n  if (typeof obj !== 'object') {\n    throw new TypeError('Object.preventExtensions can only be called on Objects.');\n  }\n\n  return Object.seal(Object.freeze(obj));\n};",
    term: "Object.preventExtensions",
    explain:
      "\n\n// Object.preventExtensions = function(obj): This line creates a function called \"preventExtensions\" that takes a parameter \"obj\".\n\n// if (typeof obj !== 'object'): This line checks if the type of obj is not an object.\n\n// throw new TypeError('Object.preventExtensions can only be called on Objects.'): This line throws a TypeError if the type of obj is not an object.\n\n// return Object.seal(Object.freeze(obj)): This line returns an object that is sealed and frozen. The object is sealed to prevent any new properties from being added to it, and frozen to prevent any existing properties from being changed.",
    useCase:
      "\n\nObject.preventExtensions is used in Javascript to prevent new properties from being added to an object. This allows developers to control the size and shape of their objects, as well as the properties that are available on them. This helps them ensure that their code is more stable and predictable.",
  },
  {
    code: "\n\n// Polyfill for Object.seal\nif (!Object.seal) {\n  Object.seal = function (obj) {\n    // Retrieve the property names defined on object\n    var props = Object.getOwnPropertyNames(obj);\n    // Freeze properties before freezing self\n    props.forEach(function(name) {\n      var prop = obj[name];\n      // Freeze prop if it is an object\n      if (typeof prop == 'object' && prop !== null) {\n        Object.seal(prop);\n      }\n    });\n    // Freeze self\n    return Object.freeze(obj);\n  };\n}",
    term: "Object.seal",
    explain:
      "\n\n// Line 1:\n// This line is setting up a polyfill for the Object.seal function, which is a function that allows you to seal an object so that it cannot be modified or extended.\n\n// Line 2:\n// This line is using an if-statement to check if the Object.seal function already exists in the environment. If it does not exist, then the polyfill will be used.\n\n// Line 3:\n// This line is declaring the Object.seal polyfill.\n\n// Line 4:\n// This line is using Object.getOwnPropertyNames() to retrieve all the properties that have been defined on the object that is being passed in.\n\n// Line 5-8:\n// This block is looping through each of the retrieved properties and freezing them if they are an object.\n\n// Line 9:\n// This line is using Object.freeze() to freeze the object itself. This ensures that the object is immutable and cannot be modified or extended.",
    useCase:
      "\n\nObject.seal is used in JavaScript to prevent new properties from being added to an object and to prevent existing properties from being removed. It also prevents existing properties from being changed, but it does not prevent them from being altered. This provides an extra layer of security to help protect data stored in objects.",
  },
  {
    code: "\n\nif (!Object.setPrototypeOf) {\n  Object.setPrototypeOf = function (obj, prototype) {\n  \tobj.__proto__ = prototype;\n\n    if (obj.__proto__ !== prototype) {\n      //IE8\n      function F() {}\n      F.prototype = prototype;\n      obj = new F();\n      obj.__proto__ = prototype;\n    }\n    return obj;\n  }\n}",
    term: "Object.setPrototypeOf",
    explain:
      "\n\n// This line checks if the Object.setPrototypeOf method is already defined. If it is, the code below does not run.\nif (!Object.setPrototypeOf) {\n\n// This line is the definition for Object.setPrototypeOf. It takes two parameters: obj and prototype.\nObject.setPrototypeOf = function (obj, prototype) {\n\n// This line sets the prototype of the object.\n\tobj.__proto__ = prototype;\n\n// This line checks if the prototype was set correctly.\n    if (obj.__proto__ !== prototype) {\n\n// This line is used in IE8 as it does not support the __proto__ property. It creates a new function F and sets its prototype to the given prototype.\n      function F() {}\n      F.prototype = prototype;\n\n// This line creates a new object with the F function.\n      obj = new F();\n\n// This line sets the prototype of the object to the given prototype.\n      obj.__proto__ = prototype;\n    }\n\n// This line returns the object.\n    return obj;\n  }\n}",
    useCase:
      "\n\nObject.setPrototypeOf is used in JavaScript to set the prototype of an object. This is an important way to extend the functionality of an object and to create inheritance. By setting the prototype of an object, you can access the methods and properties of the parent object, helping to create a hierarchical structure for your code. It is also used to set the prototype of the global object.",
  },
  {
    code: "\n\nif (!Object.values) {\n  Object.values = function (obj) {\n    const values = [];\n    for (let key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        values.push(obj[key]);\n      }\n    }\n    return values;\n  };\n}",
    term: "Object.values",
    explain:
      "\n\n// Line 1:\n// This line checks if the Object.values function doesn't exist. \n\n// Line 2:\n// This line creates a new Object.values function if it doesn't already exist.\n\n// Line 3:\n// This line creates an array called values.\n\n// Line 4:\n// This line creates a for loop that iterates through the keys of the object passed in as a parameter.\n\n// Line 5:\n// This line checks if the object passed in as a parameter has the current key that the for loop is iterating through.\n\n// Line 6:\n// This line pushes the value of the current key into the values array.\n\n// Line 7:\n// This line returns the values array.\n\n// Line 8:\n// This line closes the Object.values function.",
    useCase:
      "\n\nObject.values is used in JavaScript to retrieve an array of all the values contained in an object. This allows for quick and easy access to all the values contained in an object without having to iterate over each key. This can be useful for quickly extracting data from an object, or for performing operations on all the values contained in an object.",
  },
  {
    code: '\n\n(function(){\n\tif(typeof document.hidden !== "undefined"){\n\t\tObject.defineProperty(document, "visibilityState", {\n\t\t\tget: function(){\n\t\t\t\treturn document.hidden ? "hidden" : "visible";\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(document, "hidden", {\n\t\t\tget: function(){\n\t\t\t\treturn document.visibilityState === "hidden";\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(document, "visibilitychange", {\n\t\t\tget: function(){\n\t\t\t\tvar evt;\n\t\t\t\tif(typeof document.createEvent === "function"){\n\t\t\t\t\tevt = document.createEvent("HTMLEvents");\n\t\t\t\t\tevt.initEvent("visibilitychange", true, false);\n\t\t\t\t\tif(document.dispatchEvent){\n\t\t\t\t\t\tdocument.dispatchEvent(evt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\telse if(typeof document.mozHidden !== "undefined"){\n\t\tObject.defineProperty(document, "visibilityState", {\n\t\t\tget: function(){\n\t\t\t\treturn document.mozHidden ? "hidden" : "visible";\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(document, "hidden", {\n\t\t\tget: function(){\n\t\t\t\treturn document.visibilityState === "hidden";\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(document, "mozVisibilitychange", {\n\t\t\tget: function(){\n\t\t\t\tvar evt;\n\t\t\t\tif(typeof document.createEvent === "function"){\n\t\t\t\t\tevt = document.createEvent("HTMLEvents");\n\t\t\t\t\tevt.initEvent("visibilitychange", true, false);\n\t\t\t\t\tif(document.dispatchEvent){\n\t\t\t\t\t\tdocument.dispatchEvent(evt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\telse if(typeof document.msHidden !== "undefined"){\n\t\tObject.defineProperty(document, "visibilityState", {\n\t\t\tget: function(){\n\t\t\t\treturn document.msHidden ? "hidden" : "visible";\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(document, "hidden", {\n\t\t\tget: function(){\n\t\t\t\treturn document.visibilityState === "hidden";\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(document, "msVisibilitychange", {\n\t\t\tget: function(){\n\t\t\t\tvar evt;\n\t\t\t\tif(typeof document.createEvent === "function"){\n\t\t\t\t\tevt = document.createEvent("HTMLEvents");\n\t\t\t\t\tevt.initEvent("visibilitychange", true, false);\n\t\t\t\t\tif(document.dispatchEvent){\n\t\t\t\t\t\tdocument.dispatchEvent(evt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\telse if(typeof document.webkitHidden !== "undefined"){\n\t\tObject.defineProperty(document, "visibilityState", {\n\t\t\tget: function(){\n\t\t\t\treturn document.webkitHidden ? "hidden" : "visible";\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(document, "hidden", {\n\t\t\tget: function(){\n\t\t\t\treturn document.visibilityState === "hidden";\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(document, "webkitVisibilitychange", {\n\t\t\tget: function(){\n\t\t\t\tvar evt;\n\t\t\t\tif(typeof document.createEvent === "function"){\n\t\t\t\t\tevt = document.createEvent("HTMLEvents");\n\t\t\t\t\tevt.initEvent("visibilitychange", true, false);\n\t\t\t\t\tif(document.dispatchEvent){\n\t\t\t\t\t\tdocument.dispatchEvent(evt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n})();',
    term: "PageVisibility",
    explain:
      '\n\n// Line 1: This is an anonymous function that is being invoked immediately. \n// Line 2: This is a conditional check to see if the document property "hidden" is undefined.\n// Line 3: This defines a new property, "visibilityState", on the document object. The getter returns "hidden" if the document.hidden is true, else it returns "visible".\n// Line 4: This defines a new property, "hidden", on the document object. The getter returns true if the document.visibilityState is "hidden".\n// Line 5: This defines a new property, "visibilitychange", on the document object. The getter creates an HTML event called "visibilitychange" and dispatches it.\n// Line 6-9: This is an else if statement, checking if document.mozHidden is undefined.\n// Line 10-19: This is the same process as lines 3-5, but using the document.mozHidden property instead.\n// Line 20-29: This is an else if statement, checking if document.msHidden is undefined.\n// Line 30-39: This is the same process as lines 3-5, but using the document.msHidden property instead.\n// Line 40-49: This is an else if statement, checking if document.webkitHidden is undefined.\n// Line 50-59: This is the same process as lines 3-5, but using the document.webkitHidden property instead.',
    useCase:
      "\n\nPageVisibility is used in Javascript to detect when a user switches tabs or minimizes their browser window. This is useful for improving user experience, as it allows the web page to respond to the user's actions. For instance, it can be used to pause a video or audio when the user switches away from the page, or to reduce the number of requests being sent while the user is not actively using the page.",
  },
  {
    code: "\n\nif (typeof Promise !== 'function') {\n  //  Promise polyfill\n  function Promise(executor) {\n    let self = this;\n    self.status = 'pending';\n    self.onResolvedCallback = [];\n    self.onRejectedCallback = [];\n\n    self.resolve = function(value) {\n      if (self.status === 'pending') {\n        self.status = 'resolved';\n        self.data = value;\n        for (let i = 0; i < self.onResolvedCallback.length; i++) {\n          self.onResolvedCallback[i](value);\n        }\n      }\n    };\n\n    self.reject = function(reason) {\n      if (self.status === 'pending') {\n        self.status = 'rejected';\n        self.data = reason;\n        for (let i = 0; i < self.onRejectedCallback.length; i++) {\n          self.onRejectedCallback[i](reason);\n        }\n      }\n    };\n\n    try {\n      executor(self.resolve, self.reject);\n    } catch (reason) {\n      self.reject(reason);\n    }\n  }\n\n  //  for .then\n  Promise.prototype.then = function(onResolved, onRejected) {\n    let self = this;\n    let promise2;\n\n    //  如果promise1和promise2共用一个回调函数，\n    //  那么它们的resolve状态就可能互相影响，从而导致不可预知的错误\n    //  因此要重新创建一个promise对象，作为使用一个独立回调函数\n    onResolved = typeof onResolved === 'function' ? onResolved : function(v) { return v; };\n    onRejected = typeof onRejected === 'function' ? onRejected : function(r) { throw r; };\n\n    if (self.status === 'resolved') {\n      return (promise2 = new Promise(function(resolve, reject) {\n        try {\n          let x = onResolved(self.data);\n          if (x instanceof Promise) {\n            //  如果onResolved的返回值是一个Promise对象，\n            //  直接取它的结果做为promise2的结果\n            x.then(resolve, reject);\n          }\n          resolve(x); //  否则，以它的返回值做为promise2的结果\n        } catch (reason) {\n          reject(reason);\n        }\n      }));\n    }\n\n    if (self.status === 'rejected') {\n      return (promise2 = new Promise(function(resolve, reject) {\n        try {\n          let x = onRejected(self.data);\n          if (x instanceof Promise) {\n            x.then(resolve, reject);\n          }\n        } catch (reason) {\n          reject(reason);\n        }\n      }));\n    }\n\n    if (self.status === 'pending') {\n      //  这里之所以没有异步执行，是因为这些函数必然会被resolve或reject调用，而resolve或reject函数里的内容已是异步执行，构造函数里的定义\n      return (promise2 = new Promise(function(resolve, reject) {\n        self.onResolvedCallback.push(function(value) {\n          try {\n            let x = onResolved(value);\n            if (x instanceof Promise) {\n              x.then(resolve, reject);\n            }\n          } catch (r) {\n            reject(r);\n          }\n        });\n\n        self.onRejectedCallback.push(function(reason) {\n          try {\n            let x = onRejected(reason);\n            if (x instanceof Promise) {\n              x.then(resolve, reject);\n            }\n          } catch (r) {\n            reject(r);\n          }\n        });\n      }));\n    }\n  };\n\n  //  for .catch\n  Promise.prototype.catch = function(onRejected) {\n    return this.then(null, onRejected);\n  };\n\n  //  for .resolve\n  Promise.resolve = function(value) {\n    return new Promise(function(resolve, reject) {\n      if (value instanceof Promise) {\n        value.then(resolve, reject);\n      } else {\n        resolve(value);\n      }\n    });\n  };\n\n  //  for .reject\n  Promise.reject = function(reason) {\n    return new Promise(function(resolve, reject) {\n      reject(reason);\n    });\n  };\n\n  //  for .all\n  Promise.all = function(promises) {\n    if (!Array.isArray(promises)) {\n      throw new TypeError('You must pass an array to Promise.all().');\n    }\n    return new Promise(function(resolve, reject) {\n      let i = 0;\n      let result = [];\n      let len = promises.length;\n      let count = len;\n\n      function resolver(index) {\n        return function(value) {\n          resolveAll(index, value);\n        };\n      }\n\n      function rejecter(reason) {\n        reject(reason);\n      }\n\n      function resolveAll(index, value) {\n        result[index] = value;\n        if (--count == 0) {\n          resolve(result);\n        }\n      }\n\n      for (; i < len; i++) {\n        promises[i].then(resolver(i), rejecter);\n      }\n    });\n  };\n\n  //  for .race\n  Promise.race = function(promises) {\n    if (!Array.isArray(promises)) {\n      throw new TypeError('You must pass an array to Promise.race().');\n    }\n    return new Promise(function(resolve, reject) {\n      for (var i = 0, len = promises.length; i < len; i++) {\n        promises[i].then(resolve, reject);\n      }\n    });\n  };\n\n  window.Promise = Promise;\n}",
    term: "Promise",
    explain:
      "\n\n// This code is a polyfill for the Promise object. It checks if the Promise function is available. If it is not available, it defines the Promise function, its prototype methods (then, catch, resolve, reject, all, race), and adds it to the window object. \n\n// Line 1: Check if the Promise function is available.\nif (typeof Promise !== 'function') {\n\n// Line 2: Define a Promise constructor function.\n  function Promise(executor) {\n\n// Line 3: Set the status of the promise to 'pending'.\n    let self = this;\n    self.status = 'pending';\n\n// Line 4: Create an array to store the resolved and rejected callbacks.\n    self.onResolvedCallback = [];\n    self.onRejectedCallback = [];\n\n// Line 5: Define the resolve function.\n    self.resolve = function(value) {\n      if (self.status === 'pending') {\n\n// Line 6: Set the status of the promise to 'resolved' and store the value.\n        self.status = 'resolved';\n        self.data = value;\n\n// Line 7: Loop through the resolved callbacks and call them with the stored value.\n        for (let i = 0; i < self.onResolvedCallback.length; i++) {\n          self.onResolvedCallback[i](value);\n        }\n      }\n    };\n\n// Line 8: Define the reject function.\n    self.reject = function(reason) {\n      if (self.status === 'pending') {\n\n// Line 9: Set the status of the promise to 'rejected' and store the reason.\n        self.status = 'rejected';\n        self.data = reason;\n\n// Line 10: Loop through the rejected callbacks and call them with the stored reason.\n        for (let i = 0; i < self.onRejectedCallback.length; i++) {\n          self.onRejectedCallback[i](reason);\n        }\n      }\n    };\n\n// Line 11: Try to execute the executor function.\n    try {\n      executor(self.resolve, self.reject);\n\n// Line 12: If the executor function throws an error, reject the promise with the error.\n    } catch (reason) {\n      self.reject(reason);\n    }\n  }\n\n// Line 13: Define the then method on the Promise prototype.\n  Promise.prototype.then = function(onResolved, onRejected) {\n    let self = this;\n    let promise2;\n\n// Line 14: Check if the onResolved and onRejected functions are valid.\n    onResolved = typeof onResolved === 'function' ? onResolved : function(v) { return v; };\n    onRejected = typeof onRejected === 'function' ? onRejected : function(r) { throw r; };\n\n// Line 15: Check if the promise is resolved.\n    if (self.status === 'resolved') {\n\n// Line 16: Create a new promise.\n      return (promise2 = new Promise(function(resolve, reject) {\n\n// Line 17: Try to call the onResolved function with the stored value.\n        try {\n          let x = onResolved(self.data);\n\n// Line 18: If the returned value is a promise, resolve promise2 with the returned promise.\n          if (x instanceof Promise) {\n            x.then(resolve, reject);\n          }\n\n// Line 19: Resolve promise2 with the returned value.\n          resolve(x);\n\n// Line 20: If an error is thrown, reject promise2 with the thrown error.\n        } catch (reason) {\n          reject(reason);\n        }\n      }));\n    }\n\n// Line 21: Check if the promise is rejected.\n    if (self.status === 'rejected') {\n\n// Line 22: Create a new promise.\n      return (promise2 = new Promise(function(resolve, reject) {\n\n// Line 23: Try to call the onRejected function with the stored reason.\n        try {\n          let x = onRejected(self.data);\n\n// Line 24: If the returned value is a promise, resolve promise2 with the returned promise.\n          if (x instanceof Promise) {\n            x.then(resolve, reject);\n          }\n\n// Line 25: If an error is thrown, reject promise2 with the thrown error.\n        } catch (reason) {\n          reject(reason);\n        }\n      }));\n    }\n\n// Line 26: Check if the promise is pending.\n    if (self.status === 'pending') {\n\n// Line 27: Create a new promise.\n      return (promise2 = new Promise(function(resolve, reject) {\n\n// Line 28: Push the onResolved and onRejected functions to the resolved and rejected callbacks arrays.\n        self.onResolvedCallback.push(function(value) {\n          try {\n            let x = onResolved(value);\n            if (x instanceof Promise) {\n              x.then(resolve, reject);\n            }\n\n// Line 29: Resolve promise2 with the returned value.\n            resolve(x);\n\n// Line 30: If an error is thrown, reject promise2 with the thrown error.\n          } catch (r) {\n            reject(r);\n          }\n        });\n\n        self.onRejectedCallback.push(function(reason) {\n          try {\n            let x = onRejected(reason);\n            if (x instanceof Promise) {\n              x.then(resolve, reject);\n            }\n          } catch (r) {\n            reject(r);\n          }\n        });\n      }));\n    }\n  };\n\n// Line 31: Define the catch method on the Promise prototype.\n  Promise.prototype.catch = function(onRejected) {\n    return this.then(null, onRejected);\n  };\n\n// Line 32: Define the resolve method on the Promise constructor.\n  Promise.resolve = function(value) {\n    return new Promise(function(resolve, reject) {\n\n// Line 33: If the value is a promise, resolve the promise with the returned promise.\n      if (value instanceof Promise) {\n        value.then(resolve, reject);\n\n// Line 34: Resolve the promise with the value.\n      } else {\n        resolve(value);\n      }\n    });\n  };\n\n// Line 35: Define the reject method on the Promise constructor.\n  Promise.reject = function(reason) {\n    return new Promise(function(resolve, reject) {\n\n// Line 36: Reject the promise with the reason.\n      reject(reason);\n    });\n  };\n\n// Line 37: Define the all method on the Promise constructor.\n  Promise.all = function(promises) {\n\n// Line 38: Throw an error if the 'promises' argument is not an array.\n    if (!Array.isArray(promises)) {\n      throw new TypeError('You must pass an array to Promise.all().');\n    }\n\n// Line 39: Create a new promise.\n    return new Promise(function(resolve, reject) {\n\n// Line 40: Initialize variables.\n      let i = 0;\n      let result = [];\n      let len = promises.length;\n      let count = len;\n\n// Line 41: Define the resolver function.\n      function resolver(index) {\n        return function(value) {\n\n// Line 42: Resolve all promises with their values.\n          resolveAll(index, value);\n        };\n      }\n\n// Line 43: Define the rejecter function.\n      function rejecter(reason) {\n\n// Line 44: Reject the promise with the reason.\n        reject(reason);\n      }\n\n// Line 45: Define the resolveAll function.\n      function resolveAll(index, value) {\n\n// Line 46: Store the value in the result array.\n        result[index] = value;\n\n// Line 47: Check if all the promises are resolved and resolve the promise with the result array.\n        if (--count == 0) {\n          resolve(result);\n        }\n      }\n\n// Line 48: Loop through the promises and call their then methods.\n      for (; i < len; i++) {\n        promises[i].then(resolver(i), rejecter);\n      }\n    });\n  };\n\n// Line 49: Define the race method on the Promise constructor.",
    useCase:
      "\n\nPromise is used in Javascript to handle asynchronous operations. Promises are used to handle the asynchronous nature of JavaScript and allow developers to write asynchronous code that looks and behaves like synchronous code. Promises simplify the process of handling asynchronous operations and make it easier to write code that works reliably in the face of network and server errors. Promises also allow developers to write code that is easier to debug and handle errors in a more organized way.",
  },
  {
    code: '\n\n//Create a new promise to wrap the native promise.allSettled\nconst PromiseAllSettled = (promises) => {\n  return new Promise((resolve, reject) => {\n    //Then create a new array to store the fulfilled and rejected promises\n    let results = [];\n    //Create a loop that will iterate through all the promises\n    let completed = 0;\n    //Create an array of promises that will be returned\n    let returnedPromises = [];\n\n    const checkIfAllPromisesAreDone = () => {\n      //Increment completed with each iteration\n      completed++;\n      //If all promises are fulfilled, resolve the promise\n      if (completed === promises.length) {\n        resolve(results);\n      }\n    };\n\n    //Loop through the promises\n    promises.forEach((promise, index) => {\n      //Create a new promise that will take the individual promise\n      //and store it in the results array\n      returnedPromises[index] = new Promise((resolve, reject) => {\n        //When the promse is fulfilled\n        promise.then((value) => {\n          results[index] = {\n            //Store the value in the results array\n            status: "fulfilled",\n            value: value,\n          };\n          //Resolve the new promise\n          resolve(value);\n          //Call the checkIfAllPromisesAreDone function\n          checkIfAllPromisesAreDone();\n        });\n\n        //When the promise is rejected\n        promise.catch((reason) => {\n          results[index] = {\n            //Store the reason in the results array\n            status: "rejected",\n            reason: reason,\n          };\n          //Resolve the new promise\n          resolve(reason);\n          //Call the checkIfAllPromisesAreDone function\n          checkIfAllPromisesAreDone();\n        });\n      });\n    });\n\n    //Return the array of promises\n    return Promise.all(returnedPromises);\n  });\n};',
    term: "Promise.allSettled",
    explain:
      "\n\n// 1. Create a new promise to wrap the native promise.allSettled\n// This line creates a new promise and sets it equal to a function that takes an argument of promises. \n\n// 2. Then create a new array to store the fulfilled and rejected promises\n// This line creates an empty array to store the fulfilled and rejected promises. \n\n// 3. Create a loop that will iterate through all the promises\n// This line creates a variable that will be used to iterate through all the promises in the argument.\n\n// 4. Create an array of promises that will be returned\n// This line creates an empty array that will be used to store the promises that will be returned.\n\n// 5. Create a new promise that will take the individual promise and store it in the results array\n// This line creates a new promise that will take an individual promise and store it in the results array. \n\n// 6. When the promse is fulfilled, store the value in the results array\n// This line stores the value of the promise in the results array when the promise is fulfilled. \n\n// 7. When the promise is rejected, store the reason in the results array\n// This line stores the reason of the promise in the results array when the promise is rejected. \n\n// 8. Return the array of promises\n// This line returns the array of promises.",
    useCase:
      "\n\nPromise.allSettled is used in Javascript to handle multiple promises that may not all resolve successfully. It allows all promises to run concurrently and resolves each promise with either a 'fulfilled' or 'rejected' state. This allows for a more efficient use of resources as all promises are run in parallel, which helps to reduce the amount of time it takes for all promises to be handled. It also provides a more predictable way of handling multiple promises as the resulting states are known before the promise is resolved.",
  },
  {
    code: "\n\n//polyfill for Promise.any\nif (!Promise.any) {\n  Promise.any = function (iterable) {\n    return new Promise((resolve, reject) => {\n      let iterablePromises = Array.from(iterable);\n      let response;\n      let rejectCount = 0;\n      let iterablePromisesLength = iterablePromises.length;\n\n      if (iterablePromisesLength === 0) {\n        reject(new Error('At least one Promise should be passed'));\n      }\n\n      iterablePromises.forEach(promise => {\n        promise.then(res => {\n          response = res;\n          resolve(res);\n        }).catch(err => {\n          rejectCount += 1;\n          if (rejectCount === iterablePromisesLength) {\n            reject(err);\n          }\n        });\n      });\n    });\n  };\n}",
    term: "Promise.any",
    explain:
      "\n\n//This code is a polyfill for Promise.any. This function will allow us to execute multiple promises and resolves when one of them is successful. It works by using the Promise constructor to create a new Promise and the Array method from() to convert the iterable object into an array. \n//Line 1: if (!Promise.any) {\n//This checks to see if the Promise.any method already exists, if it does not, the code within the if statement will run. \n//Line 2: Promise.any = function (iterable) {\n//This assigns a function to the Promise.any method. The argument passed into the function is an iterable object. \n//Line 3: return new Promise((resolve, reject) => {\n//This creates a new Promise and assigns resolve and reject callbacks to it. \n//Line 4: let iterablePromises = Array.from(iterable);\n//This creates an array with the elements from the iterable object. \n//Line 5: let response;\n//This creates a variable that will be used to store the response from one of the promises. \n//Line 6: let rejectCount = 0;\n//This creates a variable to keep track of how many promises have been rejected. \n//Line 7: let iterablePromisesLength = iterablePromises.length;\n//This creates a variable to store the length of the array of promises. \n//Line 8: if (iterablePromisesLength === 0) {\n//This checks to see if the length of the array is 0, if it is, an error is thrown. \n//Line 9: iterablePromises.forEach(promise => {\n//This iterates over the array of promises. \n//Line 10: promise.then(res => {\n//This is the then function of the promise. It will be called when the promise is resolved. \n//Line 11: response = res;\n//This assigns the response to the response variable. \n//Line 12: resolve(res);\n//This resolves the promise with the response. \n//Line 13: }).catch(err => {\n//This is the catch function of the promise. It will be called when the promise is rejected. \n//Line 14: rejectCount += 1;\n//This increments the rejectCount variable. \n//Line 15: if (rejectCount === iterablePromisesLength) {\n//This checks to see if all of the promises have been rejected. \n//Line 16: reject(err);\n//This rejects the promise with the error. \n//Line 17: });\n//This closes the catch function. \n//Line 18: });\n//This closes the Promise constructor. \n//Line 19: };\n//This closes the Promise.any function. \n//Line 20: }\n//This closes the if statement.",
    useCase:
      "\n\nPromise.any is used in Javascript to help handle multiple asynchronous operations. It allows the programmer to specify a set of Promises that should be executed in parallel and returns a single Promise that resolves when any of the Promises in the set resolves. This is useful when dealing with multiple operations that don’t have to be in any particular order. For example, if you need to fetch data from several different sources, you can use Promise.any to fetch them all at once, without having to wait for each individual Promise to resolve.",
  },
  {
    code: "\n\nif (!Promise.prototype.finally) {\n  Promise.prototype.finally = function (callback) {\n    const res = () => this.then(callback);\n    const rej = () => this.catch(callback);\n    return this.then(res, rej);\n  };\n}",
    term: "Promise.prototype.finally",
    explain:
      '\n\n//Line 1: This line checks if the Promise.prototype object already has a method called "finally".\n//Line 2: This line creates a function called "finally" on the Promise prototype object.\n//Line 3: This line creates a constant called "res" which stores the result of calling the "then" method on the Promise with the callback parameter passed in.\n//Line 4: This line creates a constant called "rej" which stores the result of calling the "catch" method on the Promise with the callback parameter passed in.\n//Line 5: This line returns the result of calling the "then" method on the Promise with the "res" and "rej" constants passed in.',
    useCase:
      "\n\nPromise.prototype.finally is used in JavaScript to provide a way to observe when a Promise is settled, regardless of whether it was fulfilled or rejected. This allows developers to perform certain tasks after the Promise has been settled, such as cleaning up resources or logging information. It also allows developers to make sure that certain tasks are always performed after a Promise is settled, regardless of the outcome.",
  },
  {
    code: "\n\n//polyfill for Reflect\nObject.defineProperty(window, 'Reflect', {\n  value: (function() {\n    const assign = Object.assign;\n    return {\n      assign(target, ...sources) {\n        return assign(target, ...sources);\n      },\n      defineProperty(target, property, descriptor) {\n        return Object.defineProperty(target, property, descriptor);\n      },\n      deleteProperty(target, property) {\n        return delete target[property];\n      },\n      get(target, property, receiver) {\n        return target[property];\n      },\n      getOwnPropertyDescriptor(target, property) {\n        return Object.getOwnPropertyDescriptor(target, property);\n      },\n      getPrototypeOf(target) {\n        return Object.getPrototypeOf(target);\n      },\n      has(target, property) {\n        return property in target;\n      },\n      isExtensible(target) {\n        return Object.isExtensible(target);\n      },\n      ownKeys(target) {\n        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n      },\n      preventExtensions(target) {\n        return Object.preventExtensions(target);\n      },\n      set(target, property, value, receiver) {\n        return target[property] = value;\n      },\n      setPrototypeOf(target, prototype) {\n        return Object.setPrototypeOf(target, prototype);\n      }\n    };\n  }())\n});",
    term: "Reflect",
    explain:
      "\n\n// This code is a polyfill for the Reflect object in JavaScript. A polyfill is a piece of code (often JavaScript on the Web) used to provide modern functionality on older browsers that do not natively support it.\n// Object.defineProperty() is used to create a new property directly on an object, or modify an existing one, and return the object.\n// window is being passed as the target object and Reflect is being assigned as the property.\n// A function is being assigned as the value of Reflect, which is used to define the various methods of the Reflect object.\n// assign, defineProperty, deleteProperty, get, getOwnPropertyDescriptor, getPrototypeOf, has, isExtensible, ownKeys, preventExtensions, set, and setPrototypeOf methods are being defined within the function.",
    useCase:
      "\n\nReflect is used in JavaScript to provide a way to interact with objects and their properties. It provides methods that allow us to query, set, and delete an object's properties, as well as invoke methods on objects. It also provides a way to get the meta-properties of an object, such as its prototype, and its constructor. Reflect also provides a way to apply functions to objects and to construct new objects. It is also useful for determining if an object has a particular property or method.",
  },
  {
    code: "\n\n//polyfill of Reflect.apply\nconst ReflectApply = (target, thisArg, args) =>\n  Function.prototype.apply.call(target, thisArg, args);",
    term: "Reflect.apply",
    explain:
      "\n\n//This line declares a constant called ReflectApply and assigns it a function definition. This function takes three parameters: target, thisArg, and args. \n\n//The function definition is the polyfill (replacement) for the Reflect.apply method. \n\n//The Reflect.apply method is used to call a target function with a given this value and arguments provided as an array. \n\n//This polyfill uses the Function.prototype.apply method, which is used to call a function with a given this value and arguments provided as an array. \n\n//The polyfill uses the call method of the Function.prototype.apply method to call the target function with the given thisArg and args.",
    useCase:
      "\n\nReflect.apply is used in Javascript to invoke a target function with a given this value and arguments provided as an array. It is a useful tool for calling functions with an unknown number of arguments or for calling functions on objects that may not have the function in their prototype.",
  },
  {
    code: "\n\nconst ReflectConstruct = (target, args, newTarget) => {\n  if (newTarget === undefined) {\n    newTarget = target;\n  }\n\n  const proto = newTarget.prototype;\n  const instance = Object.create(proto);\n  const result = target.apply(instance, args);\n\n  return (Object(result) === result) ? result : instance;\n}",
    term: "Reflect.construct",
    explain:
      "\n\n// Line 1: \n// This line declares a function named ReflectConstruct with three parameters - target, args, and newTarget.\n\n// Line 2:\n// This line checks if the newTarget parameter is undefined and if it is, it sets newTarget to the same value as target.\n\n// Line 3:\n// This line declares a variable named proto and sets it to the prototype of the newTarget.\n\n// Line 4:\n// This line declares a variable named instance and sets it to an object created with the proto variable.\n\n// Line 5:\n// This line calls the target function with the instance and args parameters and sets the result to a variable named result.\n\n// Line 6:\n// This line checks if the result is an object and if it is, it returns the result, otherwise it returns the instance.",
    useCase:
      "\n\nReflect.construct is used in JavaScript to create new objects with the specified prototype and, optionally, initializing it with given arguments. It is a built-in function of the Reflect API that provides a way to construct new objects without explicitly using the new operator. The Reflect.construct function allows developers to dynamically construct objects instead of relying on the traditional constructor function. This is useful when a constructor function has not been defined, or when a constructor function needs to be dynamically generated.",
  },
  {
    code: "\n\nif (!Reflect.defineProperty) {\n  Reflect.defineProperty = function (target, property, descriptor) {\n    try {\n      Object.defineProperty(target, property, descriptor);\n      return true;\n    } catch (err) {\n      return false;\n    }\n  }\n}",
    term: "Reflect.defineProperty",
    explain:
      "\n\n// Line 1: This line checks if the Reflect.defineProperty function is not defined.\n// Line 2: If the function is not defined, then this line defines a function named Reflect.defineProperty which takes in three parameters: target, property, and descriptor.\n// Line 3: This line tries to call the Object.defineProperty() function and pass in the three parameters passed into the Reflect.defineProperty function.\n// Line 4: If the call to Object.defineProperty() is successful, then this line returns true.\n// Line 5: If the call to Object.defineProperty() fails, then this line returns false.\n// Line 6: This line closes the if statement.",
    useCase:
      "\n\nReflect.defineProperty is used in Javascript to create or modify properties on an object. This method allows you to define a property on an object and set the value and property attributes. This is useful for adding functionality to objects, such as getters, setters, enumerable, writable, and configurable. This can be used to control how an object is accessed and used.",
  },
  {
    code: "\n\nconst ReflectDeleteProperty = (object, property) => {\n  let success = false;\n\n  if (!object || typeof object !== 'object' || !Object.prototype.hasOwnProperty.call(object, property)) {\n    return success;\n  }\n\n  delete object[property];\n  success = true;\nreturn success;\n};",
    term: "Reflect.deleteProperty",
    explain:
      "\n\n// Line 1: This sets a constant variable, called ReflectDeleteProperty, which refers to a function that takes in two parameters (object and property).\n\n// Line 2: This sets a variable, called success, to false.\n\n// Line 3: This checks if the object parameter is not defined, or if its type is not an object, or if the object does not have the property passed in as the second parameter. If any of these conditions are true, then the function will return the success variable (which is currently set to false).\n\n// Line 4: This uses the delete operator to delete the property from the object, if it exists.\n\n// Line 5: This sets the success variable to true.\n\n// Line 6: This returns the success variable, which is now set to true.",
    useCase:
      "\n\nReflect.deleteProperty is used in JavaScript to delete a property from an object. It works like the delete operator, except that it returns a boolean value indicating whether the property was successfully deleted or not. This allows for more precise control over the deletion of object properties and makes it easier to debug code.",
  },
  {
    code: "\n\nif (!Reflect.get) {\n  Reflect.get = function (target, propertyKey, receiver) {\n    const descriptor = Object.getOwnPropertyDescriptor(target, propertyKey);\n    if (descriptor === undefined) {\n      let parent = Object.getPrototypeOf(target);\n      if (parent === null) {\n        return undefined;\n      } else {\n        return Reflect.get(parent, propertyKey, receiver);\n      }\n    }\n    if (descriptor.get) {\n      return descriptor.get.call(receiver);\n    } else {\n      return descriptor.value;\n    }\n  };\n}",
    term: "Reflect.get",
    explain:
      "\n\n//Line 1: \n//This line is checking to see if the Reflect.get function has already been defined. If it has not been defined, the code in the block will be executed. \n\n//Line 2: \n//This line is defining the Reflect.get function. It takes three parameters: target, propertyKey, and receiver. \n\n//Line 3: \n//This line is getting the property descriptor of the target object. \n\n//Line 4: \n//This line is checking to see if the descriptor is undefined. If it is, it gets the prototype of the target object. \n\n//Line 5: \n//This line is checking to see if the parent is null. If it is, it returns undefined. \n\n//Line 6: \n//This line is calling the Reflect.get function on the parent object, passing in the property key and receiver as parameters. \n\n//Line 7: \n//This line is checking to see if the descriptor has a get method. If it does, it calls the get method on the receiver. \n\n//Line 8: \n//This line is returning the value from the descriptor if it does not have a get method.",
    useCase:
      "\n\nReflect.get is used in Javascript to access the value of a property from an object. It is a built-in function of the Reflect API, which provides a way to interact with objects and their properties. It can be used to retrieve the value of an object's property without having to use the traditional dot notation or bracket syntax. This can be useful for accessing properties that have non-standard names, such as symbols, or for avoiding the need to explicitly check for the existence of a property before accessing it.",
  },
  {
    code: '\n\nif (typeof Reflect === "undefined" || typeof Reflect.getOwnPropertyDescriptor === "undefined") {\n  Reflect.getOwnPropertyDescriptor = function(obj, propName) {\n    return Object.getOwnPropertyDescriptor(obj, propName);\n  };\n}',
    term: "Reflect.getOwnPropertyDescriptor",
    explain:
      '\n\n// Line 1: This line checks if the type of the object "Reflect" is undefined or if the getOwnPropertyDescriptor method of the Reflect object is undefined.\n// Line 2: If either of the above checks is true, this line creates a new function on the Reflect object which takes two parameters, an object and a property name.\n// Line 3: This line calls the getOwnPropertyDescriptor method of the Object object with the given parameters and returns the result.',
    useCase:
      "\n\nReflect.getOwnPropertyDescriptor is used in Javascript to return the property descriptor of a given property on a specified object. This is useful as it allows developers to access information about a given property, such as its enumerability, configurability and writability. This can be useful in determining whether or not a property is able to be changed and what type of properties should be set on a given object.",
  },
  {
    code: "\n\nif (!Reflect.getPrototypeOf) {\n  Reflect.getPrototypeOf = function (target) {\n    if (Object.getPrototypeOf) {\n      return Object.getPrototypeOf(target);\n    }\n    if (target.__proto__) {\n      return target.__proto__;\n    }\n    return target.constructor.prototype;\n  }\n}",
    term: "Reflect.getPrototypeOf",
    explain:
      "\n\n// This code is checking if the Reflect.getPrototypeOf () method is available, and if not, it is defining it.\n// Line 1: This line is checking if the Reflect.getPrototypeOf () method is not available.\n// Line 2: This is the beginning of the function definition for the Reflect.getPrototypeOf() method.\n// Line 3: This line is using the Object.getPrototypeOf() method to get the prototype of the target object, if it is available.\n// Line 4: This line is using the __proto__ property to get the prototype of the target object, if it is available.\n// Line 5: This line is using the target object's constructor's prototype property to get the prototype of the target object.\n// Line 6: This is the end of the function definition for the Reflect.getPrototypeOf() method.",
    useCase:
      "\n\nReflect.getPrototypeOf is used in Javascript to retrieve the prototype of an object. It is a safe and reliable way to get the prototype of an object because it allows the user to handle errors that may occur while getting the prototype of an object. It also works in both strict and non-strict mode, making it a versatile tool to have in your Javascript toolkit.",
  },
  {
    code: "\n\nif (!Reflect.has) {\n    Reflect.has = (obj, prop) => {\n        return Object.prototype.hasOwnProperty.call(obj, prop);\n    }\n}",
    term: "Reflect.has",
    explain:
      "\n\n// Line 1: If the Reflect object does not have the 'has' property, execute the code in the following block.\n// Line 2: Create a property on the Reflect object named 'has', and set it equal to a function that takes two parameters, 'obj' and 'prop'.\n// Line 3: Return a boolean value indicating whether the 'obj' parameter has the property named 'prop'. This is done by using the 'hasOwnProperty' method of the Object prototype.",
    useCase:
      "\n\nReflect.has is used in Javascript to determine if an object has a property with the given key. This is different from using the in operator, as the in operator will also check the prototype chain of the object, while Reflect.has only checks the object itself. This can be useful if you need to check if a property exists on an object without worrying about any inherited properties.",
  },
  {
    code: "\n\nfunction isExtensible(target) {\n  let object = Object(target);\n\n  if (Object.isFrozen(object) || Object.isSealed(object)) {\n    return false;\n  }\n\n  for (let key in object) {\n    if (Object.prototype.hasOwnProperty.call(object, key)) {\n      return false;\n    }\n  }\n\n  return Object.isExtensible(object);\n}",
    term: "Reflect.isExtensible",
    explain:
      "\n\n// 1. function isExtensible(target) { //This line declares a function named isExtensible which takes one parameter, target.\n\n// 2. let object = Object(target); //This line declares a variable named object and sets it to the object created from the target.\n\n// 3. if (Object.isFrozen(object) || Object.isSealed(object)) { //This line checks if the object is frozen or sealed.\n\n// 4. return false; //This line returns false if the object is frozen or sealed.\n\n// 5. for (let key in object) { //This line starts a loop which iterates over all the keys in the object.\n\n// 6. if (Object.prototype.hasOwnProperty.call(object, key)) { //This line checks if the object has a property with the given key.\n\n// 7. return false; //This line returns false if the object has a property with the given key.\n\n// 8. } //This line ends the if statement.\n\n// 9. } //This line ends the loop.\n\n// 10. return Object.isExtensible(object); //This line returns a boolean indicating whether the object is extensible or not.\n\n// 11. } //This line ends the function.",
    useCase:
      "\n\nReflect.isExtensible is used in Javascript to check if an object is extensible, meaning whether new properties can be added to it or not. This allows for more control over objects, as it allows developers to decide when an object can and cannot be modified.",
  },
  {
    code: "\n\nif (!Reflect.ownKeys) {\n  Reflect.ownKeys = (target) => {\n    let keys = [];\n    if (target == null) return keys;\n\n    let targetObj = Object(target);\n    const symbols = Object.getOwnPropertySymbols(targetObj);\n    const targetKeys = Object.getOwnPropertyNames(targetObj);\n    \n    keys.push(...targetKeys);\n    if (symbols.length > 0) {\n      keys.push(...symbols);\n    }\n\n    return keys;\n  }\n}",
    term: "Reflect.ownKeys",
    explain:
      "\n\n// Line 1:\n// If the Reflect object does not have an ownKeys property, execute the following code.\n\n// Line 2 - 10:\n// Declare an empty array, keys, to store the keys of the target object. If the target object is null, return the empty array. Then, create a targetObj object that is a wrapper of the target object. After that, store the symbols and properties of the target object in symbols and targetKeys variables respectively.\n\n// Line 11:\n// Push all the target keys into the keys array.\n\n// Line 12 - 14:\n// If the symbols array has any elements, push them into the keys array.\n\n// Line 15:\n// Return the keys array.",
    useCase:
      "\n\nReflect.ownKeys is used in JavaScript to return an array of all own enumerable properties found directly upon a given object. This method is useful for obtaining an array of the properties that an object has, including both enumerable and non-enumerable properties. It can also be used to iterate over the properties of an object, or to check if an object has a certain property.",
  },
  {
    code: "\n\n// ES5\nObject.preventExtensions = function (object) {\n\tObject.defineProperty(object, 'preventExtensions', {\n\t\tvalue: true,\n\t\twritable: false,\n\t\tenumerable: false,\n\t\tconfigurable: false\n\t});\n\treturn object;\n};\n\nif (!Reflect.preventExtensions) {\n    Reflect.preventExtensions = function(target) {\n        return Object.preventExtensions(target);\n    }\n}",
    term: "Reflect.preventExtensions",
    explain:
      "\n\n//Line 1: \n//Object.preventExtensions = function (object) {\n//This line defines a function named \"preventExtensions\" which takes an object as an argument. \n\n//Line 2:\n//Object.defineProperty(object, 'preventExtensions', {\n//This line uses the defineProperty method to set a property of the object to preventExtensions.\n\n//Line 3:\n//value: true,\n//This line sets the value of the property to true.\n\n//Line 4: \n//writable: false,\n//This line sets the writable property of the property to false, meaning that the value cannot be changed. \n\n//Line 5: \n//enumerable: false,\n//This line sets the enumerable property of the property to false, meaning that it will not be returned in a for-in loop.\n\n//Line 6: \n//configurable: false\n//This line sets the configurable property of the property to false, meaning that it cannot be deleted or changed.\n\n//Line 7: \n//});\n//This line closes the defineProperty method.\n\n//Line 8: \n//return object;\n//This line returns the object.\n\n//Line 9: \n//if (!Reflect.preventExtensions) {\n//This line checks if the Reflect.preventExtensions function does not exist.\n\n//Line 10: \n//Reflect.preventExtensions = function(target) {\n//This line defines a new function named preventExtensions which takes a target as an argument.\n\n//Line 11: \n//return Object.preventExtensions(target);\n//This line calls the preventExtensions function defined in line 1 and passes the target as an argument.\n\n//Line 12: \n//}\n//This line closes the if statement.",
    useCase:
      "\n\nReflect.preventExtensions is used in JavaScript to prevent any new properties from being added to an object. This is useful when you want to make sure that an object remains in its current state and is not changed by code elsewhere in the program. It is a way to “lock” an object, making it immutable.",
  },
  {
    code: "\n\nReflect.set = function(target, property, value, receiver) {\n    if (Object(target) !== target) {\n        throw new TypeError('Reflect.set called on non-object');\n    }\n    try {\n        return Reflect.setPrototypeOf(target, property, value, receiver);\n    } catch(err) { }\n\n    let desc = Object.getOwnPropertyDescriptor(target, property);\n\n    if (desc === undefined) {\n        let parent = Object.getPrototypeOf(target);\n\n        if (parent !== null) {\n            return Reflect.set(parent, property, value, receiver);\n        }\n\n        desc = {\n            value: undefined, \n            writable: true,\n            enumerable: true,\n            configurable: true\n        };\n    }\n\n    if (desc.set !== undefined) {\n        let setter = desc.set;\n        setter.call(receiver, value);\n        return true;\n    } else if (desc.writable !== undefined && desc.writable === true) {\n        target[property] = value;\n        return true;\n    } else {\n        return false;\n    }\n};",
    term: "Reflect.set",
    explain:
      "\n\n//Line 1: This line creates a function called Reflect.set which accepts four parameters: target, property, value, and receiver.\n//Line 2: This line throws an error if the target is not an object.\n//Line 3: This line attempts to set the target's prototype property.\n//Line 4: This line catches any errors that occur if the attempt to set the target's prototype property fails.\n//Lines 5-7: This block of code retrieves the property descriptor for the target property if it exists.\n//Lines 8-17: This block of code checks if the property descriptor is undefined. If it is, the parent prototype is retrieved and the Reflect.set function is called on it. If the property descriptor is not undefined, the code checks if there is a setter defined and calls it with the receiver and the value. If there is no setter, the code checks if the property is writable, and if so, sets the property to the value. Otherwise, the function returns false.",
    useCase:
      "\n\nReflect.set is a built-in method in JavaScript that allows you to set a property on an object. It's used to modify the value of a property on an object. It's particularly useful when dealing with properties that are not directly accessible, such as properties that have been defined using Object.defineProperty() or Symbol. It also allows you to set a property on a prototype object, which is something that the regular assignment operator ( = ) cannot do.",
  },
  {
    code: "\n\n// check for the native implementation of Reflect.setPrototypeOf\nif (!Object.hasOwnProperty('setPrototypeOf')) {\n  // define polyfill for Reflect.setPrototypeOf\n  // reference: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf\n  Reflect.setPrototypeOf = function(object, prototype) {\n    // check for the status of the first parameter\n    if (object === null || typeof object !== 'object') {\n      throw new TypeError('Cannot set prototype on a non-object');\n    }\n    // check for the status of the second parameter\n    if (typeof prototype !== 'object' && prototype !== null) {\n      throw new TypeError('Prototype must be an object or null');\n    }\n    // if prototype is not an object, set it to null\n    if (prototype === null) {\n      object.__proto__ = null;\n      return object;\n    }\n    // try to set the prototype\n    try {\n      object.__proto__ = prototype;\n      return object;\n    } catch (e) {\n      // if not successful, mimic the native implementation\n      let isOwnProperty = Object.prototype.hasOwnProperty.call(object, '__proto__');\n      if (object.__proto__ !== prototype) {\n        if (isOwnProperty) {\n          object.__proto__ = prototype;\n          return object;\n        } else {\n          // if the property is not owned by the object itself, return false\n          return false;\n        }\n      } else {\n        return object;\n      }\n    }\n  };\n}",
    term: "Reflect.setPrototypeOf",
    explain:
      "\n\n// Line 1: This line checks to see if the object has a native implementation of the Reflect.setPrototypeOf method.\n// Line 2: If the object does not have the native implementation, a polyfill is defined to simulate the Reflect.setPrototypeOf method.\n// Line 3: This line checks the status of the first parameter passed in to the polyfill. If the parameter is not an object, a TypeError is thrown.\n// Line 4: This line checks the status of the second parameter passed in to the polyfill. If the parameter is not an object or null, a TypeError is thrown.\n// Line 5: If the prototype is not an object, it is set to null.\n// Line 6: The try block is used to set the prototype of the object.\n// Line 7: The catch block is used to mimic the native implementation of the Reflect.setPrototypeOf method.\n// Line 8: This line checks to see if the object has a __proto__ property.\n// Line 9: If the object does not own the __proto__ property, false is returned.\n// Line 10: If the object owns the __proto__ property, the prototype is set and the object is returned.\n// Line 11: If the prototype is successfully set, the object is returned.",
    useCase:
      "\n\nReflect.setPrototypeOf is used in JavaScript to set the prototype of an object, replacing the current prototype of the object. This method allows you to set the prototype of an object without having to use the Object.setPrototypeOf syntax. It is useful for manipulating the prototype chain of an object, and for creating objects with a custom prototype.",
  },
  {
    code: "\n\nif (!RegExp.prototype.hasOwnProperty(\"@@matchAll\")) {\n    (function () {\n        RegExp.prototype[\"@@matchAll\"] = function (str) { \n            let match;\n            let matches = [];\n            let regexp = new RegExp(this.source, 'g' + (this.ignoreCase ? 'i' : '') + (this.multiline ? 'm' : ''));\n            while ((match = regexp.exec(str)) !== null) {\n                let len = match[0].length;\n                if (len === 0) {\n                    regexp.lastIndex++;\n                }\n                matches.push({\n                    length: len,\n                    index: match.index,\n                    groups: match.slice(1)\n                });\n            }\n            return matches;\n        };\n    })();\n}",
    term: "RegExp.prototype.@@matchAll",
    explain:
      "\n\n// 1. if (!RegExp.prototype.hasOwnProperty(\"@@matchAll\")) {\n//    This line checks if the RegExp prototype has a property called '@@matchAll'; if not, the code inside the block will execute.\n\n// 2. (function () {\n//    This line creates an anonymous function.\n\n// 3. RegExp.prototype[\"@@matchAll\"] = function (str) { \n//    This line adds a property '@@matchAll' to the RegExp prototype and assigns it a function that takes a string as an argument.\n\n// 4. let match;\n//    This line declares a variable called 'match'.\n\n// 5. let matches = [];\n//    This line declares a variable called 'matches' and assigns it an empty array.\n\n// 6. let regexp = new RegExp(this.source, 'g' + (this.ignoreCase ? 'i' : '') + (this.multiline ? 'm' : ''));\n//    This line declares a variable called 'regexp' and assigns it a new regular expression object. The regular expression is created using the source, ignoreCase and multiline properties of the 'this' keyword.\n\n// 7. while ((match = regexp.exec(str)) !== null) {\n//    This line creates a while loop that iterates as long as the 'match' variable is not equal to null.\n\n// 8. let len = match[0].length;\n//    This line declares a variable called 'len' and assigns it the length of the first element of the 'match' array.\n\n// 9. if (len === 0) {\n//    This line checks if the 'len' variable is equal to 0.\n\n// 10. regexp.lastIndex++;\n//    This line increments the 'lastIndex' property of the 'regexp' object.\n\n// 11. matches.push({\n//    This line adds an object to the 'matches' array. \n\n// 12. length: len,\n//    This line assigns the 'length' property of the object the value of the 'len' variable.\n\n// 13. index: match.index,\n//    This line assigns the 'index' property of the object the value of the 'index' property of the 'match' variable.\n\n// 14. groups: match.slice(1)\n//    This line assigns the 'groups' property of the object the value of the 'match' variable sliced from index 1.\n\n// 15. });\n//    This line closes the object.\n\n// 16. return matches;\n//    This line returns the 'matches' array.\n\n// 17. };\n//    This line closes the function.\n\n// 18. })();\n//    This line invokes the anonymous function.\n\n// 19. }\n//    This line closes the if statement.",
    useCase:
      "\n\nRegExp.prototype.@@matchAll is used in Javascript to return an iterator of all results matching a string against a regular expression, including capturing groups. It is useful for finding multiple matches in a single string, rather than just the first one. This can be used for more complex searches and validation tasks.",
  },
  {
    code: "\n\nif (!RegExp.prototype.flags) {\n  Object.defineProperty(RegExp.prototype, 'flags', {\n    configurable: true,\n    get: function() {\n      // create flags string\n      var flags = '';\n      if (this.global) flags += 'g';\n      if (this.ignoreCase) flags += 'i';\n      if (this.multiline) flags += 'm';\n      if (this.dotAll) flags += 's';\n      if (this.unicode) flags += 'u';\n      if (this.sticky) flags += 'y';\n      return flags;\n    }\n  });\n}",
    term: "RegExp.prototype.flags",
    explain:
      '\n\n// This line checks to see if the RegExp.prototype has a "flags" property.\nif (!RegExp.prototype.flags) {\n\n// This line uses the Object.defineProperty() method to define the "flags" property of the RegExp.prototype object.\n  Object.defineProperty(RegExp.prototype, \'flags\', {\n\n// This line sets the "configurable" property of the "flags" property to true.\n    configurable: true,\n\n// This line sets the "get" property of the "flags" property to a function that will generate a flags string from the global, ignoreCase, multiline, dotAll, unicode, and sticky properties of the RegExp object.\n    get: function() {\n\n// This line creates an empty string to use as the flags string\n      var flags = \'\';\n\n// This line checks to see if the RegExp has a global property, and if so, it adds the "g" flag to the flags string.\n      if (this.global) flags += \'g\';\n\n// This line checks to see if the RegExp has an ignoreCase property, and if so, it adds the "i" flag to the flags string.\n      if (this.ignoreCase) flags += \'i\';\n\n// This line checks to see if the RegExp has a multiline property, and if so, it adds the "m" flag to the flags string.\n      if (this.multiline) flags += \'m\';\n\n// This line checks to see if the RegExp has a dotAll property, and if so, it adds the "s" flag to the flags string.\n      if (this.dotAll) flags += \'s\';\n\n// This line checks to see if the RegExp has a unicode property, and if so, it adds the "u" flag to the flags string.\n      if (this.unicode) flags += \'u\';\n\n// This line checks to see if the RegExp has a sticky property, and if so, it adds the "y" flag to the flags string.\n      if (this.sticky) flags += \'y\';\n\n// This line returns the flags string\n      return flags;\n    }\n  });\n}',
    useCase:
      "\n\nRegExp.prototype.flags is used to return a string containing the flags of a regular expression, such as global, ignoreCase, and multiline. This is useful for retrieving information about the regular expression without having to parse the expression itself. This can be especially useful when dealing with regular expressions created using RegExp object constructors, as the flags can be dynamically set at runtime.",
  },
  {
    code: "\n\nif(!window.ResizeObserver) {\n\nconst subscribers = [];\n\nclass ResizeObserver {\n    constructor(cb) {\n        this.cb = cb;\n        subscribers.push(this);\n        this.observe();\n    }\n    \n    observe() {\n        this.resizeListener = () => this.cb(this);\n        window.addEventListener('resize', this.resizeListener);\n    }\n    \n    unobserve() {\n        window.removeEventListener('resize', this.resizeListener);\n    }\n    \n    disconnect() {\n        this.unobserve();\n        const index = subscribers.indexOf(this);\n        subscribers.splice(index, 1);\n    }\n}\n\nResizeObserver.triggerAll = () => {\n    subscribers.forEach(subscriber => subscriber.cb(subscriber));\n};\n\nwindow.ResizeObserver = ResizeObserver;\n\n}",
    term: "ResizeObserver",
    explain:
      "\n\n//Line 1: This line checks to see if the window object already has a ResizeObserver property. If not, it continues to line 2.\n\n//Line 2: This line declares a variable called ‘subscribers’ and sets it to an empty array.\n\n//Line 3-17: This block of code defines a class called ‘ResizeObserver’ and its constructor, methods, and properties. The constructor takes in a callback function ‘cb’ and adds it to the ‘subscribers’ array. The ‘observe’ method adds a listener to the ‘resize’ event on the window object, and the ‘unobserve’ and ‘disconnect’ methods remove the listener and remove the subscriber from the ‘subscribers’ array.\n\n//Line 18: This line defines a static method on the ‘ResizeObserver’ class that triggers the callback function for all the subscribers in the ‘subscribers’ array.\n\n//Line 19: This line sets the ‘window.ResizeObserver’ property to the ‘ResizeObserver’ class.",
    useCase:
      "\n\nResizeObserver is used in JavaScript to asynchronously observe changes in the size of an element's content or border box and notify when those changes occur. It is especially useful for responsive design, enabling developers to respond to changes in the size of the element by resizing or moving elements to match the new size. This helps to ensure that the layout of a page remains consistent regardless of changes in the size of the viewport or browser window.",
  },
  {
    code: "\n\nif (typeof Set === 'undefined' || !Set){\n  let Set = (function(){\n    let items = {};\n\n    class Set {\n      constructor(){\n        items = {};\n      }\n\n      add(value){\n        if(!this.has(value)){\n          items[value] = value;\n          return true;\n        }\n        return false;\n      }\n\n      remove(value){\n        if(this.has(value)){\n          delete items[value];\n          return true;\n        }\n        return false;\n      }\n\n      has(value){\n        return items.hasOwnProperty(value);\n      }\n\n      clear(){\n        items = {};\n      }\n\n      size(){\n        return Object.keys(items).length;\n      }\n\n      values(){\n        return Object.values(items);\n      }\n\n      union(otherSet){\n        let unionSet = new Set();\n\n        this.values().forEach(function(value){\n          unionSet.add(value);\n        });\n\n        otherSet.values().forEach(function(value){\n          unionSet.add(value);\n        });\n\n        return unionSet;\n      }\n\n      intersection(otherSet){\n        let intersectionSet = new Set();\n\n        this.values().forEach(function(value){\n          if(otherSet.has(value)){\n            intersectionSet.add(value);\n          }\n        });\n\n        return intersectionSet;\n      }\n\n      difference(otherSet){\n        let differenceSet = new Set();\n\n        this.values().forEach(function(value){\n          if(!otherSet.has(value)){\n            differenceSet.add(value);\n          }\n        });\n\n        return differenceSet;\n      }\n\n      subset(otherSet){\n        if(this.size() > otherSet.size()){\n          return false;\n        } else {\n          this.values().forEach(function(value){\n            if(!otherSet.has(value)){\n              return false;\n            }\n          });\n        }\n\n        return true;\n      }\n    }\n\n    return Set;\n  })();\n}",
    term: "Set",
    explain:
      "\n\n// Line 1: The code is checking to see if the Set object has been defined and is truthy. \n// If it is not truthy, then the remainder of the code will be run.\n// Line 2: A self-invoking anonymous function is defined, which will be used to create a new Set object.\n// Line 3: The items variable is declared within the scope of the anonymous function and set to an empty object.\n// Lines 4-29: The Set class is defined within the scope of the anonymous function. It has methods for adding, removing, and checking for elements, as well as methods for union, intersection, difference, and subset.\n// Line 30: The Set class is returned, creating a new Set object. \n// Line 31: The self-invoking anonymous function ends. \n// Line 32: An if statement is used to check if the Set object is truthy. If it is not, then the code within the if statement will be run.",
    useCase:
      "\n\nSet is used in Javascript as it is an unordered collection of unique values. It does not store duplicate values and can be used to remove duplicates from an array or to perform mathematical operations such as union, intersection, and difference. It is also used to store objects with unique values and to create a list of unique values from an array.",
  },
  {
    code: "\n\nif (!String.fromCodePoint) {\n  String.fromCodePoint = function () {\n    var codePoints = [];\n    for (var i = 0; i < arguments.length; i += 1) {\n      var c = arguments[i];\n      if (c < 0x10000) {\n        codePoints.push(c);\n      } else {\n        c -= 0x10000;\n        codePoints.push(0xD800 | ((c >> 10) & 0x3FF));\n        codePoints.push(0xDC00 | (c & 0x3FF));\n      }\n    }\n    return String.fromCharCode.apply(null, codePoints);\n  };\n}",
    term: "String.fromCodePoint",
    explain:
      "\n\n// Line 1: This line checks if String.fromCodePoint is defined. If it's not defined, the code in the following block will be executed. \n// Line 2-11: This block of code defines the String.fromCodePoint function. This function takes in code points and converts them into a string. \n// Line 3: This line creates an empty array to store the code points. \n// Line 4-9: This loop iterates over the arguments of the function, converts them into code points and stores them in the codePoints array. \n// Line 10: This line calls the String.fromCharCode function and passes in the codePoints array. This will convert the code points into a string and return it. \n// Line 11: This line closes the definition of the String.fromCodePoint function.",
    useCase:
      "\n\nString.fromCodePoint is used in Javascript to create a string from a Unicode code point. This can be used to create strings with special characters from the Unicode character set. It is an effective way to display non-standard characters and symbols in a consistent way across different browsers and platforms.",
  },
  {
    code: "\n\n//Create a prototype for the String class\nString.prototype.@@iterator = function () {\n    //Create a variable to store the string\n    var string = this;\n\n    //Create a variable to store the current index\n    var index = 0;\n\n    //Return an object with the necessary methods\n    return {\n        //Method to return the current character\n        next: function () {\n            //Check if the index is less than the length of the string\n            if (index < string.length) {\n                //Return an object with the character and its index\n                return {\n                    value: string[index],\n                    done: false\n                };\n            } else {\n                //If the index is greater return done as true\n                return {\n                    done: true\n                };\n            }\n        },\n        //Method to reset the index\n        reset: function () {\n            index = 0;\n        }\n    };\n};",
    term: "String.prototype.@@iterator",
    explain:
      "\n\n//Line 1: This line creates a prototype for the String class. A prototype is an object that is shared among all instances of a class. It allows us to add methods to the class without modifying the code of the class.\n\n//Line 2: This line declares a function that will be added to the prototype of the String class. \n\n//Line 3: This line declares a variable that will store the string.\n\n//Line 4: This line declares a variable that will store the current index.\n\n//Lines 5-15: This block of code returns an object with the necessary methods. The first method is next, which returns the current character of the string and its index. The second method is reset, which resets the index to 0.",
    useCase:
      "\n\nString.prototype.@@iterator is used in Javascript as it allows for the user to iterate over the characters of a string. It returns an iterator object which can be used to access each character of the string one by one, allowing for the user to perform any operations they may desire on the individual characters of the string. This can be helpful in a variety of situations where the user needs to access individual characters of a string.",
  },
  {
    code: '\n\nif(!String.prototype.anchor){\n    String.prototype.anchor = function(name){\n        return `<a name="${name}">${this}</a>`\n    }\n}',
    term: "String.prototype.anchor",
    explain:
      "\n\n//Line 1: \n//If the String prototype does not have an anchor property, \n\n//Line 2: \n//add an anchor property to the String prototype which is a function with one argument (name). \n\n//Line 3: \n//The function returns a string with an anchor tag around the original string, with the anchor tag's name attribute being the value passed in as an argument.",
    useCase:
      "\n\nString.prototype.anchor is used in Javascript to create an HTML anchor element around a string of text. This can be used to create links to other webpages, or to create bookmarks within the same page. It is useful for creating navigation menus and linking to other parts of the page. It also allows for better readability and organization of webpages.",
  },
  {
    code: "\n\nif (!String.prototype.at) {\n  String.prototype.at = function(index) {\n    if (isNaN(index) || index < 0 || index >= this.length) {\n      return '';\n    }\n    return this.charAt(index);\n  };\n}",
    term: "String.prototype.at",
    explain:
      '\n\n//This line checks to see if the String.prototype object already has a property called "at". If it does not, then the code inside the if statement will execute.\n//This line creates a new method on the String.prototype object called "at", which takes one argument, "index".\n//This line checks if the argument passed to the method is not a number, or is a negative number, or is greater than or equal to the length of the string. If any of those conditions are true, an empty string is returned.\n//This line returns the character at the specified index in the string.',
    useCase:
      "\n\nString.prototype.at is used in Javascript to retrieve a character from a specified index in a string. This method allows for easy access to individual characters in a string, which can be useful for creating automated string processing tools, such as text parsers or spellcheckers.",
  },
  {
    code: '\n\nif (!String.prototype.big) {\n    String.prototype.big = function() {\n        return "<big>" + this + "</big>";\n    };\n}',
    term: "String.prototype.big",
    explain:
      '\n\n//Line 1: This line checks if the String prototype object has a property called "big". If it does not, the code inside the curly braces will be executed.\n\n//Line 2: This line adds a new property called "big" to the String prototype object. The value of this property is a function.\n\n//Line 3: This line returns a string of HTML with a <big> tag around the string that the function was called on. For example, if the function was called on the string "Hello", the return value would be "<big>Hello</big>".',
    useCase:
      "\n\nString.prototype.big is used to add HTML <big> tags around a string in JavaScript. This is useful for dynamically displaying text of different sizes on a web page. It allows developers to easily change the size of a string without having to manually add HTML tags.",
  },
  {
    code: "\n\nif (!String.prototype.blink) {\n  Object.defineProperty(String.prototype, 'blink', {\n    get: function() {\n      return `<blink>${this}</blink>`;\n    }\n  });\n}",
    term: "String.prototype.blink",
    explain:
      "\n\n//Line 1: \n//This line checks if the prototype of the built-in String object has a method named blink. \n\n//Line 2: \n//This line uses the Object.defineProperty() method to create a new blink property for the String prototype.\n\n//Line 3:\n//This line defines the function that will be called when the blink property is accessed. The function returns a string containing the text wrapped inside of <blink> tags.\n\n//Line 4:\n//This line closes the if statement.",
    useCase:
      "\n\nString.prototype.blink is used in Javascript to make a string blink. This can be used to draw attention to certain parts of a page or to make text stand out. It is especially useful for highlighting important words or phrases when presenting information.",
  },
  {
    code: '\n\nif (!String.prototype.bold) {\n    String.prototype.bold = function() {\n        return "<strong>" + this + "</strong>";\n    }\n}',
    term: "String.prototype.bold",
    explain:
      "\n\n// Line 1:\n// This line checks if the bold function is already defined in the String prototype. If not, it proceeds to the next line.\n\n// Line 2:\n// This line defines a bold function within the String prototype. This function will add <strong> HTML tags around a string and return the result. \n\n// Line 3:\n// This line closes the if statement.",
    useCase:
      "\n\nString.prototype.bold is used in JavaScript to create a string of text that is displayed in a bold font. This can be used to add emphasis to certain words or phrases in a web page or application. It can also be used to make text stand out from other text on the page.",
  },
  {
    code: "\n\nif (!String.prototype.codePointAt) {\n  String.prototype.codePointAt = function(pos) {\n    if (this == null) {\n      throw TypeError();\n    }\n    var string = String(this);\n    var size = string.length;\n    var index = pos ? Number(pos) : 0;\n    if (index < 0 || index >= size) {\n      return undefined;\n    }\n    var first = string.charCodeAt(index);\n    var second;\n    if (first >= 0xD800 && first <= 0xDBFF && size > index + 1) {\n      second = string.charCodeAt(index + 1);\n      if (second >= 0xDC00 && second <= 0xDFFF) {\n        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n      }\n    }\n    return first;\n  };\n}",
    term: "String.prototype.codePointAt",
    explain:
      "\n\n1. if (!String.prototype.codePointAt) {  //This statement checks if the codePointAt property is not present in the String prototype object\n\n2. String.prototype.codePointAt = function(pos) { //If the codePointAt property is not present in the String prototype object, this statement adds a new codePointAt property to the String prototype object and its value is a function that takes a position parameter as argument\n\n3. if (this == null) {  //This statement checks if the value of this is null\n\n4. throw TypeError(); //If the value of this is null, this statement throws a type error\n\n5. var string = String(this); //This statement declares a new string variable and assigns it the value of this\n\n6. var size = string.length; //This statement declares a new size variable and assigns it the length of the string\n\n7. var index = pos ? Number(pos) : 0; //This statement declares a new index variable and assigns it the value of the pos argument if it is present, or 0 if it is not present\n\n8. if (index < 0 || index >= size) { //This statement checks if the index is less than 0 or greater than or equal to the size of the string\n\n9. return undefined; //If the index is less than 0 or greater than or equal to the size of the string, this statement returns undefined\n\n10. var first = string.charCodeAt(index); //This statement declares a new first variable and assigns it the character code of the character at the specified index\n\n11. var second; //This statement declares a new second variable\n\n12. if (first >= 0xD800 && first <= 0xDBFF && size > index + 1) { //This statement checks if the character code of the character at the specified index is greater than or equal to 0xD800 and less than or equal to 0xDBFF and the size of the string is greater than index + 1\n\n13. second = string.charCodeAt(index + 1); //If the condition is true, this statement assigns the character code of the character at index + 1 to the second variable\n\n14. if (second >= 0xDC00 && second <= 0xDFFF) { //This statement checks if the character code of the character at index + 1 is greater than or equal to 0xDC00 and less than or equal to 0xDFFF\n\n15. return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000; //If the condition is true, this statement returns the codepoint of the character at the specified index\n\n16. return first; //If the condition is false, this statement returns the character code of the character at the specified index",
    useCase:
      "\n\nString.prototype.codePointAt is used in JavaScript to get the numeric Unicode code point value of the character at a given index or position in a string. It is useful for working with Unicode characters and code points, as it allows developers to access and use characters beyond the standard ASCII set.",
  },
  {
    code: "\n\nif (!String.prototype.endsWith) {\n    String.prototype.endsWith = function(search, this_len) {\n        if (this_len === undefined || this_len > this.length) {\n            this_len = this.length;\n        }\n        return this.substring(this_len - search.length, this_len) === search;\n    };\n}",
    term: "String.prototype.endsWith",
    explain:
      "\n\n// Line 1: This line is checking whether the String.prototype already has an endsWith function. If it does not, the code inside the if statement will execute. \n// Line 2: This line is declaring the endsWith function that will be added to the String.prototype.\n// Line 3: This line is checking if the parameter this_len is undefined (i.e. not passed) and if it is greater than the length of the string. If either is true, this_len is set to the length of the string.\n// Line 4: This line is returning a boolean (true or false) indicating whether the substring of the string from the index this_len - search.length up to this_len is equal to search.",
    useCase:
      '\n\nString.prototype.endsWith is used in Javascript to determine if a string ends with a given substring. It returns a boolean (true or false) depending on the result. This method can be used to check if a string has the correct ending, for example if a URL ends with ".jpg" or if a username ends with “_123”. This can be useful for validating user input.',
  },
  {
    code: "\n\nif (!String.prototype.fixed) {\n  String.prototype.fixed = function() {\n    return this.replace(/([A-Z])/g, (match) => `-${match.toLowerCase()}`);\n  };\n}",
    term: "String.prototype.fixed",
    explain:
      "\n\n// Line 1: This line checks to see if there is already a method called 'fixed' on the String prototype object. \n// If there already is a method called 'fixed' on the String prototype object, the following code will not be executed.\n\n// Line 2: This line creates a new method called 'fixed' on the String prototype object.\n\n// Line 3: This line uses the 'replace' method to replace any characters that match the regex pattern with a string that has a hyphen before it. The regex pattern is looking for any uppercase letters. The replacement string is using a arrow function to convert the uppercase letter to lowercase and add a hyphen before it.",
    useCase:
      "\n\nString.prototype.fixed is used in Javascript to create a new string with all the matched search values replaced by a replacement string. This method allows developers to replace a group of characters with another group of characters with a single method call. It can be used to replace unwanted characters in a string, to change the case of a string, to format a string, and to manipulate the string in other ways.",
  },
  {
    code: '\n\nif (!String.prototype.fontcolor) {\n    String.prototype.fontcolor = function(color) {\n        return `<font color="${color}">${this}</font>` \n    }\n}',
    term: "String.prototype.fontcolor",
    explain:
      "\n\n//This code adds a fontcolor prototype to the String object.\n//Line 1: This checks to see if the String object already has a fontcolor prototype. If not, the code inside the if statement will be executed.\n//Line 2: This creates a fontcolor prototype for the String object.\n//Line 3: This returns a string with the font color set to the color argument passed in.",
    useCase:
      "\n\nString.prototype.fontcolor is used in Javascript to set the color of a string. This can be useful for making text stand out on a webpage or making it easier to read or highlight certain words or phrases. It can also be used to add visual appeal to a website or document.",
  },
  {
    code: '\n\nif (!String.prototype.fontsize) {\n    String.prototype.fontsize = function (size) {\n        if (size < 0 || size > 7) {\n            return this;\n        }\n        let fontSizeArray = ["xx-small", "x-small", "small", "medium", "large", "x-large", "xx-large"];\n        let fontSize = fontSizeArray[size];\n        return `<span style="font-size:${fontSize};">${this}</span>`;\n    }\n}',
    term: "String.prototype.fontsize",
    explain:
      "\n\n// Line 1:\n// This line checks if the native String object has a fontsize method that has been defined previously. If it has not been defined, the code block will execute. \n\n// Line 2: \n// This line defines the fontsize method on the native String object. It takes in an argument of size, which is a numerical value. \n\n// Line 3:\n// This line checks if the size argument is less than 0 or greater than 7. If it is, the original string is returned as is. \n\n// Line 4:\n// This line defines an array of strings representing font sizes. \n\n// Line 5:\n// This line uses the size argument to index into the fontSizeArray and assigns the corresponding font size string to the fontSize variable. \n\n// Line 6:\n// Finally, this line returns the original string wrapped in a span element with the font-size style set to the fontSize variable.",
    useCase:
      "\n\nString.prototype.fontsize is used in Javascript to provide an easy way to set the size of text that is contained in a string. This can be used to set the font size of a text element, or to style text elements in other ways. By using this method, developers can quickly and easily set the size of text, without having to manually set it each time.",
  },
  {
    code: "\n\nif (!String.prototype.includes) {\n  String.prototype.includes = function(search, start) {\n    'use strict';\n    if (search instanceof RegExp) {\n      throw TypeError('first argument must not be a RegExp');\n    } \n    if (start === undefined) {\n      start = 0;\n    }\n    return this.indexOf(search, start) !== -1;\n  };\n}",
    term: "String.prototype.includes",
    explain:
      '\n\n// Line 1: This line checks if the method "includes" is not already available in the String prototype. If not, it will add it.\n// Line 2: This line defines the "includes" method for the String prototype. It takes two parameters, "search" and "start".\n// Line 3: This line checks to see if the "search" parameter is a RegExp. If it is, it will throw a TypeError.\n// Line 4: This line checks to see if the "start" parameter is undefined. If it is, it will assign the value of 0 to it.\n// Line 5: This line returns the result of the comparison between the index of the search string and -1. If it is not -1, it means that the search string was found.',
    useCase:
      "\n\nString.prototype.includes is used in Javascript to determine whether a given string includes another string or not. This is useful when dealing with strings because it allows us to quickly and easily check for the presence of a particular substring within a larger string. This can be helpful when dealing with user input validation, for example, to make sure that a user has entered a valid email address or phone number.",
  },
  {
    code: "\n\nif (!String.prototype.italics) {\n  String.prototype.italics = function () {\n    return '<i>' + this + '</i>';\n  }\n}",
    term: "String.prototype.italics",
    explain:
      '\n\n//Line 1: This line checks if the "italics" function is already defined as a prototype of the String class.\n//Line 2: If the italics function is not already defined, then this line defines the italics function as a prototype of the String class.\n//Line 3: The italics function returns a string wrapped in <i> tags.',
    useCase:
      "\n\nString.prototype.italics is used to make a portion of a string appear in italics when displayed on a web page. This is useful for emphasizing parts of a string, such as a title or important phrase. It also allows for greater control over the formatting of strings than with traditional HTML tags.",
  },
  {
    code: "\n\nif (!String.prototype.link) {\n String.prototype.link = function (url) {\n  return '<a href=\"'+url+'\">'+this+'</a>';\n };\n}",
    term: "String.prototype.link",
    explain:
      "\n\n// this code is creating a new method on the String prototype called link.\n// Line 1: This line checks to see if the link method has already been added to the String prototype. \n// Line 2: This line adds the link method to the String prototype. The link method takes in a url parameter and returns a string containing an HTML link with the given URL and the string that called the link method as the link text.\n// Line 3: This line closes the if statement.",
    useCase:
      "\n\nString.prototype.link is used in Javascript to create HTML hyperlinks from a string. It allows a user to link to an external resource or an internal resource within the same website. The link() method takes two parameters, the URL and the link text, which are used to create the link HTML. This method can be used to quickly create links within a web page, making it easier to navigate.",
  },
  {
    code: "\n\n\n// constructor\nString.prototype.matchAll = function (regExp) {\n  // get string\n  const string = this.toString();\n  // initialize match index\n  let matchIndex = 0;\n  // initialize matches array\n  const matches = [];\n  // loop until all matches found\n  while ((match = regExp.exec(string)) !== null) {\n    // save match details to matches array\n    matches.push({\n      index: matchIndex,\n      input: match.input,\n      groups: match.groups,\n      0: match[0],\n      1: match[1],\n      ...match.groups,\n    });\n    // increment index\n    matchIndex++;\n  }\n  // return matches\n  return matches;\n};",
    term: "String.prototype.matchAll",
    explain:
      "\n\n\n// This code creates a matchAll prototype method on the String constructor. \n// This method takes a regular expression as a parameter, \n// then iterates through the string to find all matches and saves them in an array of objects.\n\n//Line 1: This line creates the matchAll prototype method on the String constructor.\n//Line 2: This line gets the string from the this object.\n//Line 3: This line initializes the matchIndex variable to 0.\n//Line 4: This line initializes the matches array.\n//Line 5: This line creates a while loop that runs until all matches have been found.\n//Line 6: This line saves the match details to the matches array.\n//Line 7: This line increments the matchIndex variable.\n//Line 8: This line returns the matches array.",
    useCase:
      "\n\nString.prototype.matchAll is used to match all occurrences of a regular expression in a string. This can be used to find all matches for a given pattern, which can be useful for performing operations on each match or for extracting all matches for further processing. Additionally, it can be used to iterate over all matches in a string, which is more performant than using a loop to do the same thing.",
  },
  {
    code: '\n\n// This polyfill is for the normalize() method in JavaScript\n\n// Create a Polyfill object\nvar Polyfill = {\n    // Implement the normalize() method\n    normalize: function(str) {\n        // Ensure the argument is a string\n        if (typeof str !== "string") {\n            throw new TypeError("The argument must be a string.");\n        }\n\n        // Split the string into an array of characters\n        var chars = str.split("");\n\n        // Iterate through the array of characters\n        var normalizedChars = chars.map(function(char) {\n            // Convert the character to its lowercase form\n            var lowerChar = char.toLowerCase();\n\n            // Remove accents, including diacritics\n            var normalizedChar = lowerChar\n                .replace(/[àáâãäå]/gi, "a")\n                .replace(/[èéêë]/gi, "e")\n                .replace(/[ìíîï]/gi, "i")\n                .replace(/[òóôõö]/gi, "o")\n                .replace(/[ùúûü]/gi, "u")\n                .replace(/[ýÿ]/gi, "y")\n                .replace(/[ñ]/gi, "n")\n                .replace(/[ç]/gi, "c")\n                .replace(/[œ]/gi, "oe")\n                .replace(/[æ]/gi, "ae");\n\n            return normalizedChar;\n        });\n\n        // Join the array of characters back into a string\n        var normalizedStr = normalizedChars.join("");\n\n        return normalizedStr;\n    }\n};\n\n// Add the normalize() method to the String prototype, if it doesn\'t already exist\nif (!String.prototype.normalize) {\n    String.prototype.normalize = Polyfill.normalize;\n}',
    term: "String.prototype.normalize",
    explain:
      "\n\n// Explanation: \n// Line 1: This code creates a Polyfill object to implement the normalize() method in JavaScript. \n// Line 3: The normalize() method takes a string argument and ensures it is a string.\n// Line 6: The string is split into an array of characters.\n// Line 9: The characters in the array are then iterated through and converted to their lowercase form and accents and diacritics are removed.\n// Line 16: The characters are then joined back into a string.\n// Line 19: The normalize() method is then added to the String prototype, if it doesn't already exist.",
    useCase:
      "\n\nString.prototype.normalize is used to normalize a string by converting it into a Unicode Normalization Form. This is useful for comparing strings, such as user input, that may have been entered using different encodings or may contain characters from various languages. It also helps to ensure that text is displayed consistently across different platforms and browsers.",
  },
  {
    code: "\n\nif (!String.prototype.padEnd) {\n  String.prototype.padEnd = function padEnd(targetLength,padString) {\n    targetLength = targetLength>>0;\n    padString = String(padString || ' ');\n    if (this.length > targetLength) {\n      return String(this);\n    } else {\n      targetLength = targetLength - this.length;\n      if (targetLength > padString.length) {\n        padString += padString.repeat(targetLength / padString.length);\n      }\n      return String(this) + padString.slice(0,targetLength);\n    }\n  };\n}",
    term: "String.prototype.padEnd",
    explain:
      "\n\n1. if (!String.prototype.padEnd) {\n  // if the String prototype does not already have a padEnd() method, execute the rest of the code\n\n2. String.prototype.padEnd = function padEnd(targetLength,padString) {\n  // assign the rest of the code to the String padEnd() method\n\n3. targetLength = targetLength>>0;\n   // bitwise operator to convert targetLength from a string to an integer\n\n4. padString = String(padString || ' ');\n   // if padString is not specified, assign it to a space character\n\n5. if (this.length > targetLength) {\n    return String(this);\n  } else {\n    // if the length of the string is greater than the targetLength, return the string, else execute the rest of the code\n\n6. targetLength = targetLength - this.length;\n   // subtract the length of the string from the targetLength\n\n7. if (targetLength > padString.length) {\n    padString += padString.repeat(targetLength / padString.length);\n  }\n  // if the targetLength is greater than the length of the padString, repeat the padString to match the targetLength\n\n8. return String(this) + padString.slice(0,targetLength);\n  // return the string, preceded by the padString up to the targetLength",
    useCase:
      "\n\nString.prototype.padEnd is used to add a specified number of characters to the end of a string. This can be useful for formatting strings, such as when formatting a phone number or adding a specific number of spaces between words. It can also be used to ensure a certain amount of characters for a specific purpose, such as for a password.",
  },
  {
    code: "\n\nif (!String.prototype.padStart) {\n    String.prototype.padStart = function padStart(targetLength,padString) {\n        targetLength = targetLength>>0; //floor if number or convert non-number to 0;\n        padString = String(typeof padString !== 'undefined' ? padString : ' ');\n        if (this.length > targetLength) {\n            return String(this);\n        }\n        else {\n            targetLength = targetLength-this.length;\n            if (targetLength > padString.length) {\n                padString += padString.repeat(targetLength/padString.length); //append to original to ensure we are longer than needed\n            }\n            return padString.slice(0,targetLength) + String(this);\n        }\n    };\n}",
    term: "String.prototype.padStart",
    explain:
      '\n\n//Line 1\n//This line checks to see if the "padStart" method has already been added to the String prototype. \n\n//Line 2\n//If the method has not been added, this line adds the method "padStart" to the String prototype.\n\n//Line 3\n//This line sets the first argument passed to the "padStart" method to a number and floors it. This argument represents the length to which the string should be padded.\n\n//Line 4\n//This line sets the second argument passed to the "padStart" method to a string. This argument represents the character or string to be used for padding.\n\n//Line 5\n//This line checks to see if the length of the string is greater than the length to which it should be padded. If it is, it returns the string as is.\n\n//Line 6\n//This line calculates the length of the string to which the string should be padded.\n\n//Line 7\n//This line checks to see if the target length is greater than the length of the string used for padding. If it is, it adds the string used for padding to itself, so that it can be used to fill the entire target length.\n\n//Line 8\n//This line returns the string used for padding with the appropriate length, followed by the original string.',
    useCase:
      "\n\nString.prototype.padStart is used to pad (add characters to) the beginning of a string. This can be useful for formatting strings, such as adding leading zeroes to numbers, or adding a fixed number of characters to the beginning of a string to make it a certain length.",
  },
  {
    code: "\n\nif (!String.prototype.repeat) {\n  String.prototype.repeat = function(count) {\n    'use strict';\n    if (this === null) {\n      throw new TypeError('can\\'t convert ' + this + ' to object');\n    }\n    var str = '' + this;\n    count = +count;\n    if (count !== count) {\n      count = 0;\n    }\n    if (count < 0) {\n      throw new RangeError('repeat count must be non-negative');\n    }\n    if (count === Infinity) {\n      throw new RangeError('repeat count must be less than infinity');\n    }\n    count = Math.floor(count);\n    if (str.length === 0 || count === 0) {\n      return '';\n    }\n    // Ensuring count is a 31-bit integer allows us to heavily optimize the\n    // main part. But anyway, most current (August 2014) browsers can't handle\n    // strings 1 << 28 chars or longer, so:\n    if (str.length * count >= 1 << 28) {\n      throw new RangeError('repeat count must not overflow maximum string size');\n    }\n    var rpt = '';\n    for (;;) {\n      if ((count & 1) === 1) {\n        rpt += str;\n      }\n      count >>>= 1;\n      if (count === 0) {\n        break;\n      }\n      str += str;\n    }\n    // Could we try:\n    // return Array(count + 1).join(this);\n    return rpt;\n  };\n}",
    term: "String.prototype.repeat",
    explain:
      "\n\n// Line 1: This checks if the String.prototype.repeat function has already been defined. If it has not been defined, the code in the following if statement will run.\n// Line 2: This defines a function called repeat as a property of the String.prototype object. This function takes a parameter called count.\n// Line 3: This line declares a variable called 'use strict', which enables strict mode for the following code. It prevents certain syntax errors.\n// Line 4: This line checks if the value of 'this' is null. If it is, it throws a TypeError.\n// Line 5: This line declares a variable called str and assigns it the value of 'this', which is a string.\n// Line 6: This line converts the value of count to a number data type.\n// Line 7: This line checks if the value of count is not a number. If it is not, it sets count to zero.\n// Line 8: This line checks if the value of count is less than zero. If it is, it throws a RangeError.\n// Line 9: This line checks if the value of count is equal to Infinity. If it is, it throws a RangeError.\n// Line 10: This line uses Math.floor to convert the value of count to an integer.\n// Line 11: This line checks if the string length is zero or if count is zero. If either is true, it returns an empty string.\n// Line 12: This line checks if the string length multiplied by count is greater than or equal to 1 << 28. If it is, it throws a RangeError.\n// Line 13: This line declares a variable called rpt and assigns it an empty string.\n// Line 14: This line is the start of a for loop.\n// Line 15: This line checks if the value of count is odd. If it is, it adds the value of str to the value of rpt.\n// Line 16: This line right shifts the bits of count, which divides it by two and rounds down.\n// Line 17: This line checks if the value of count is equal to zero. If it is, the loop will end.\n// Line 18: This line adds the value of str to itself.\n// Line 19: This line is the end of the for loop.\n// Line 20: This line returns the value of rpt.\n// Line 21: This line ends the if statement.",
    useCase:
      "\n\nString.prototype.repeat is used in JavaScript to create a new string consisting of a specified number of copies of an existing string. This is useful when a certain string needs to be repeated multiple times without having to manually type it out. It can also be used to create a certain pattern or format with strings.",
  },
  {
    code: "\n\nif (!String.prototype.replaceAll) {\n  String.prototype.replaceAll = function(search, replacement) {\n    const target = this\n    return target.replace(new RegExp(search, 'g'), replacement)\n  }\n}",
    term: "String.prototype.replaceAll",
    explain:
      '\n\n//Line 1: This line checks if the method "replaceAll" is already a part of the String class. If not, it will move to line 2.\n\n//Line 2: This line creates a new method called "replaceAll" in the String class.\n\n//Line 3: This line stores the current string in a variable called "target".\n\n//Line 4: This line returns the string with all occurrences of the search string replaced with the replacement string, using the "replace" method and a Regular Expression. The \'g\' flag indicates that the search should be done globally, meaning all occurrences of the search string should be replaced.',
    useCase:
      "\n\nString.prototype.replaceAll is used in Javascript to perform a global search and replace on a given string, using a regular expression or a string as the search parameter. It is often used to replace multiple occurrences of a substring within a larger string with a single instance of the substring, or to remove multiple substrings from a string. It is also used to format strings by replacing certain characters with other characters or strings.",
  },
  {
    code: "\n\nif (!String.prototype.small) {\n  String.prototype.small = function() {\n    return '<small>' + this + '</small>';\n  };\n}",
    term: "String.prototype.small",
    explain:
      "\n\nLine 1: This line checks if the function small() exists within the String prototype. \nLine 2: If the function does not exist, this line adds the small() function to the String prototype. \nLine 3: This line creates the small() function, which adds the <small> HTML element around the string. \nLine 4: This line closes the small() function.",
    useCase:
      "\n\nString.prototype.small is used in Javascript to create a small-sized version of the given string. This can be used to make text look smaller on a webpage or other application. Additionally, it can also be used to reduce the size of a string so that it can fit within a certain width or length, such as when formatting text for a mobile application.",
  },
  {
    code: "\n\n//polyfill for String.prototype.startsWith\nif (!String.prototype.startsWith) {\n  String.prototype.startsWith = function(searchString, position) {\n    position = position || 0;\n    return this.indexOf(searchString, position) === position;\n  };\n}",
    term: "String.prototype.startsWith",
    explain:
      "\n\n// This code is a polyfill which adds a new method to the String prototype. The purpose of this method is to check if a string starts with a certain character or not. \n// Line 1: This line is a check to determine if the String.prototype.startsWith method has already been implemented or not. \n// Line 2: If the method has not been implemented, then a new method is created and added to the String prototype. \n// Line 3: The position variable is set to 0 if it is not passed as an argument. \n// Line 4: This line returns a boolean value indicating if the string starts with the given character or not. It does this by checking if the index of the searchString is equal to the position provided.",
    useCase:
      "\n\nString.prototype.startsWith is used in Javascript to determine whether a given string starts with a specified string or character. This method returns a boolean value (true or false) depending on whether the given string begins with the specified string or character. This method is useful for determining if a string is a certain type of string, for example, starting with a certain letter or containing a certain word.",
  },
  {
    code: '\n\nif(!String.prototype.strike){\n  String.prototype.strike = function(){\n    return "<strike>" + this + "</strike>";\n  }\n}',
    term: "String.prototype.strike",
    explain:
      '\n\n// This code is adding a function called "strike" to the String object in JavaScript. \n// This will allow you to apply the strike tag to any string, for example:\n\n// Line 1:\n// This line is checking if the "strike" function does not already exist on the String object.\n\n// Line 2:\n// This line is creating the "strike" function on the String object.\n\n// Line 3:\n// This line is returning a string with the strike tag applied to it. The "this" keyword refers to the string that is being passed in to the function.',
    useCase:
      "\n\nString.prototype.strike is used in Javascript to add a strikethrough effect to a string. This can be used to indicate that a particular piece of text is no longer relevant or has been edited. It can also be used to add emphasis or to create a visual effect.",
  },
  {
    code: "\n\n/* polyfill for String.prototype.sub */\n\nif (!String.prototype.sub) {\n  String.prototype.sub = function(startIndex, endIndex) {\n    let start = startIndex;\n    let end = endIndex;\n    let strLength = this.length;\n    if(endIndex === undefined) {\n      end = strLength;\n    }\n    if (startIndex < 0 || startIndex >= strLength || endIndex < 0 || endIndex > strLength) {\n      return '';\n    } \n    let newStr = '';\n    for(let i = start; i < end; i++){\n      newStr += this[i];\n    }\n    return newStr;\n  }\n}",
    term: "String.prototype.sub",
    explain:
      "\n\n// This code is a polyfill for String.prototype.sub() which is a method that returns a part of a string based on a specified index. \n\n//Line 1: \n//This line declares that the following code is a polyfill for the String.prototype.sub() method. \n\n//Line 2: \n//This line checks if the String.prototype.sub() method already exists in the current environment. If it does not exist, then the code inside the if block is executed.\n\n//Line 3: \n//This line defines the function which will become the String.prototype.sub() method. It takes two parameters - startIndex and endIndex.\n\n//Lines 4-5: \n//These lines declare two variables, start and end, and set their values to the parameters passed to the function. \n\n//Line 6: \n//This line declares a variable strLength and assigns it the value of the length of the string on which the method is called.\n\n//Line 7: \n//This line checks if the endIndex parameter is undefined or not. If it is undefined, then the end variable is assigned the value of strLength. \n\n//Lines 8-11: \n//These lines check if the startIndex and endIndex parameters are within the valid range of the string length. If they are not, then an empty string is returned.\n\n//Lines 12-16: \n//These lines declare a new string called newStr and loop through the characters in the string from the startIndex to the endIndex and add them to the newStr.\n\n//Line 17: \n//This line returns the newly created string.",
    useCase:
      "\n\nString.prototype.sub is used in Javascript to create a new string containing a specified number of copies of the string on which it was called. This method is useful for creating strings of a specific length quickly and efficiently. This can be especially useful in web development where it can be used to dynamically generate strings of a specific length for display in the browser.",
  },
  {
    code: '\n\nif (!String.prototype.sup) {\n  String.prototype.sup = function() {\n    return "<sup>" + this + "</sup>";\n  };\n}',
    term: "String.prototype.sup",
    explain:
      "\n\n1. if (!String.prototype.sup) {  // checks if the String prototype object already has a property called 'sup', if it doesn't, move to the next line of code\n\n2. String.prototype.sup = function() {  // if the property 'sup' is not found, it is created and set equal to a function\n\n3. return \"<sup>\" + this + \"</sup>\";  // the function returns a string with the word inside the parentheses surrounded by <sup> tags",
    useCase:
      "\n\nString.prototype.sup is used to create superscript text, which is text that is slightly smaller and raised above the baseline of the surrounding text. Superscript text is often used to denote exponents in mathematical equations, footnotes, trademark and copyright symbols, and ordinal indicators.",
  },
  {
    code: "\n\nif (!String.prototype.trim) {\n  String.prototype.trim = function () {\n    return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n  };\n}",
    term: "String.prototype.trim",
    explain:
      "\n\n//This line checks if the trim() function already exists on the String object\nif (!String.prototype.trim) {\n\n//This line adds the trim() function to the String prototype if it does not already exist\n  String.prototype.trim = function () {\n\n//This line defines the trim() function so that it removes leading and trailing whitespace from a string.\n    return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n  };\n}",
    useCase:
      "\n\nString.prototype.trim is used in JavaScript to remove whitespace from the beginning and end of a string. This is useful when dealing with user input, as it ensures that the data is properly formatted and ready to be manipulated. It also helps to avoid any problems caused by extra whitespace.",
  },
  {
    code: "\n\nif (!String.prototype.trimEnd) {\n  String.prototype.trimEnd = function() {\n    var str = this.replace(/\\s+$/, '');\n    return str;\n  }\n}",
    term: "String.prototype.trimEnd",
    explain:
      "\n\n// Line 1: This line is checking if the trimEnd method already exists in the String prototype. If it does not, the code within the if statement will be executed. \n// Line 2: This line is adding the trimEnd method to the String prototype. \n// Line 3: This line is setting a variable called str to the result of running the replace method on the current string. The replace method is replacing any whitespace characters at the end of the string with an empty string. \n// Line 4: This line is returning the variable str.",
    useCase:
      "\n\nString.prototype.trimEnd() is used in Javascript to remove whitespace from the end of a string. This is useful for trimming off extra whitespace characters that can be added by the user in a form field or from other sources. It is especially important for removing whitespace from a string before validating or saving it to a database.",
  },
  {
    code: "\n\nif(!String.prototype.trimStart) {\n String.prototype.trimStart = function(){\n  let str = this;\n  while(str.charAt(0) == ' '){\n   str = str.substr(1);\n  }\n  return str;\n }\n}",
    term: "String.prototype.trimStart",
    explain:
      "\n\n//This code checks if the method trimStart() is not already defined in the String prototype. If it is not already defined, it adds the trimStart() method to the String prototype.\n\n//Line 1: This line checks if the method trimStart() is not already defined in the String prototype.\n\n//Line 2: If the method is not already defined, it adds the trimStart() method to the String prototype.\n\n//Line 3: This line declares a variable 'str' and assigns the value of 'this' to it.\n\n//Line 4: This line is a while loop which checks if the first character of the string is a space.\n\n//Line 5: If the first character of the string is a space, the string is trimmed from the start, by removing the first character from the string.\n\n//Line 6: This line returns the trimmed string.\n\n//Line 7: This line closes the trimStart() method.\n\n//Line 8: This line closes the if statement.",
    useCase:
      "\n\nString.prototype.trimStart is used to remove whitespace from the beginning of a string. This can be useful if you need to ensure that the string is properly formatted or if you need to compare strings that may have leading whitespace.",
  },
  {
    code: "\n\nif (!String.raw) {\n  String.raw = function (strings, ...values) {\n    let str = strings.raw[0];\n    for (let i = 0; i < values.length; i++) {\n      str += String(values[i]) + strings.raw[i + 1];\n    }\n    return str;\n  };\n}",
    term: "String.raw",
    explain:
      "\n\n// Line 1: This checks if the String object has a raw property. If not, then the code within the if statement will run.\n// Line 2: This is the definition of the String.raw function, which takes two parameters: strings and values.\n// Line 3: This creates a variable called str and sets it equal to the first element in the strings.raw array.\n// Line 4: This is a for loop that iterates over the values array and adds each value to the str variable along with the corresponding element in the strings.raw array.\n// Line 5: This returns the str variable.",
    useCase:
      "\n\nString.raw is used in Javascript to create a string literal that will not interpret any escape characters. This allows for easier writing of strings that contain special characters, as the backslash character does not need to be escaped.",
  },
  {
    code: '\n\nif(!Symbol){\n  var i = 0;\n  var symbols = {};\n  window.Symbol = function(name){\n    if(!symbols[name]){\n      symbols[name] = "__symbol__" + (i++);\n    }\n    return symbols[name];\n  };\n}',
    term: "Symbol",
    explain:
      '\n\n//This line checks to see if the Symbol function is defined. \nif(!Symbol){\n\n//This line creates the variable "i" and assigns it the value 0.\n  var i = 0;\n\n//This line creates an empty object called "symbols"\n  var symbols = {};\n\n//This line defines the Symbol function, assigning it to the window object.\n  window.Symbol = function(name){\n\n//This line checks to see if the object "symbols" contains the name passed in as an argument.\n    if(!symbols[name]){\n\n//This line creates a new entry in the "symbols" object, using the value of "i" and incrementing it by 1.\n      symbols[name] = "__symbol__" + (i++);\n    }\n\n//This line returns the value associated with the name passed in as an argument.\n    return symbols[name];\n  };\n}',
    useCase:
      "\n\nSymbol is used in JavaScript to create a unique, immutable primitive value that can be used as an identifier for object properties. Symbol is used to provide a way to create unique, private identifiers for objects, which can be used to avoid name collisions when maintaining and developing large code bases. Additionally, it provides a way to create unique properties of objects that can not be easily accessed or modified from outside code.",
  },
  {
    code: "\n\n// Defining the Symbol.asyncIterator\nif (Symbol.asyncIterator === undefined) {\n  Object.defineProperty(Symbol, 'asyncIterator', {\n    value: Symbol('asyncIterator'),\n  });\n}",
    term: "Symbol.asyncIterator",
    explain:
      "\n\n// Line 1: This line is checking to see if the Symbol.asyncIterator is undefined. Symbol.asyncIterator is a well-known symbol that is used to create an asynchronous iterator object. \n\n// Line 2: If Symbol.asyncIterator is undefined, this line will define a new property on the Symbol object called asyncIterator and set its value to a new Symbol('asyncIterator'). This will create a new Symbol which can be used to create an asynchronous iterator object.",
    useCase:
      "\n\nSymbol.asyncIterator is used to create asynchronous iterators in JavaScript. It allows a developer to create an asynchronous iterator that can pause in the middle of a loop and resume at a later time. This allows the iterator to wait for data from an external source such as an API or a database call, and then resume the loop when the data has been retrieved. This is especially useful when dealing with asynchronous data, such as in a web application.",
  },
  {
    code: "\n\nif (!Symbol.for) {\n  Symbol.for = function (key) {\n    return '@@' + key;\n  }\n}",
    term: "Symbol.for",
    explain:
      "\n\n// This code is checking if the Symbol.for property exists. Symbol.for is a function that allows developers to create unique, non-string identifiers.\n// If Symbol.for does not exist, this code is defining the function and assigning it to the Symbol.for property. The function takes a string as an argument and returns a string prefixed with '@@'.",
    useCase:
      "\n\nSymbol.for is used in JavaScript to create a unique global symbol that can be used to access data stored in the global symbol registry. This allows for data that is shared across multiple code blocks and instances to be securely accessed. This is useful for creating unique identifiers for objects and variables, as well as for creating private data that can only be accessed by specific code blocks.",
  },
  {
    code: "\n\nif (!Symbol.hasInstance) {\n    Object.defineProperty(Symbol, 'hasInstance', {\n        value: Symbol('hasInstance')\n    });\n}",
    term: "Symbol.hasInstance",
    explain:
      "\n\n// This line checks if the Symbol.hasInstance property has been defined.\n// If not, it creates a new property of Symbol called 'hasInstance' and sets its value to a newly created Symbol with the name 'hasInstance'. This is done to ensure that the Symbol.hasInstance property is available for use.",
    useCase:
      "\n\nSymbol.hasInstance is used in Javascript to allow an object to customize the instanceof operator behavior. It allows an object to define a function that is called whenever the instanceof operator is used on the object. This function can then determine whether the object is an instance of a given class, and return the appropriate result. This allows for more complex logic to be used when determining instanceof than simply checking the object's prototype chain.",
  },
  {
    code: "\n\nif (Symbol.isConcatSpreadable === undefined) {\n  Object.defineProperty(Symbol, 'isConcatSpreadable', {\n    value: Symbol('isConcatSpreadable'),\n    writable: false,\n    enumerable: false,\n    configurable: true\n  });\n}",
    term: "Symbol.isConcatSpreadable",
    explain:
      "\n\n// Line 1:\n// This line checks if the Symbol.isConcatSpreadable property is undefined. If it is, it will execute the following code. \n\n// Line 2:\n// This line defines a new property on Symbol, called 'isConcatSpreadable'. The value being assigned to this property is a Symbol with the label 'isConcatSpreadable'.\n\n// Line 3:\n// This line sets the writable property of this new Symbol to false, meaning that its value cannot be changed.\n\n// Line 4:\n// This line sets the enumerable property of this new Symbol to false, meaning that it will not be visible when looping through the properties of an object.\n\n// Line 5:\n// This line sets the configurable property of this new Symbol to true, meaning that it can be configured or deleted from the object.",
    useCase:
      "\n\nSymbol.isConcatSpreadable is used in Javascript to specify whether an object should be flattened to its array elements when it is used in the Array.prototype.concat() method. This is useful for objects such as typed arrays, which may have non-index properties, and so should not be flattened.",
  },
  {
    code: "\n\nif (Symbol.iterator === undefined) {\n  Symbol.iterator = Symbol('Symbol.iterator');\n}\n\nif (Array.prototype[Symbol.iterator] === undefined) {\n  Array.prototype[Symbol.iterator] = function() {\n    let index = 0;\n    const arr = this;\n\n    return {\n      next() {\n        if (index < arr.length) {\n          return { value: arr[index++], done: false };\n        } else {\n          return { done: true };\n        }\n      }\n    };\n  };\n}",
    term: "Symbol.iterator",
    explain:
      "\n\n// Line 1: \n// This line checks if a Symbol.iterator property already exists. If it already exists, nothing happens. \n\n// Line 2: \n// This line adds a Symbol.iterator property to the Array.prototype if it does not already exist. \n\n// Line 3: \n// This line creates a new function for the Symbol.iterator property if it does not already exist. \n\n// Line 4: \n// This line declares a variable called index and sets it to 0. \n\n// Line 5: \n// This line declares a constant called arr and sets it to the current array. \n\n// Line 6-11: \n// This section returns an object with a next() method. This method checks if the index is less than the length of the array. If it is, it will return an object with the value of the element at the current index and a done property set to false. If it is not, it will return an object with the done property set to true.",
    useCase:
      "\n\nSymbol.iterator is used in Javascript to create an iterator for an object. It creates a new, unique symbol that can be used to reference the iterator for the object. This symbol is typically used as a key in the object's prototype, which allows for a custom iterator to be created for the object. This is especially useful when dealing with iterables such as arrays and strings, as it allows for custom iteration to be defined.",
  },
  {
    code: "\n\nif (!Symbol.keyFor) {\n  Symbol.keyFor = function(sym) {\n    if (typeof Symbol.for === 'function') {\n      const symbols = Object.getOwnPropertySymbols(Symbol.for);\n      for (let i = 0; i < symbols.length; i++) {\n        if (sym === symbols[i]) {\n          return Symbol.for[symbols[i]];\n        }\n      }\n    }\n    return undefined;\n  }\n}",
    term: "Symbol.keyFor",
    explain:
      "\n\n// line 1: \n// This line checks if the Symbol.keyFor function has already been defined. If it hasn't been defined, it will move on to the next lines.\n\n// line 2: \n// This line creates the Symbol.keyFor function.\n\n// line 3: \n// This line checks if the Symbol.for function is defined. If it is, it will move on to the next lines.\n\n// line 4: \n// This line creates an array called symbols and assigns it the value of the list of symbols from the Symbol.for function.\n\n// line 5-8: \n// This loop checks if the symbol passed in to the Symbol.keyFor function matches any of the symbols in the symbols array. If it does, it will return the symbol's key.\n\n// line 9: \n// If the symbol isn't found in the symbols array, this line will return undefined.",
    useCase:
      "\n\nSymbol.keyFor is used in JavaScript to retrieve the name of a Symbol key from the global symbol registry. This allows for the retrieval of a Symbol key in a programmatic way, which can be useful for debugging purposes or for retrieving the name of a Symbol key that was registered at a different time.",
  },
  {
    code: "\n\nif (!Symbol.match) {\n  Object.defineProperty(Symbol, 'match', {\n    value: Symbol('match'),\n  });\n}",
    term: "Symbol.match",
    explain:
      '\n\n//Line 1: This line checks to see if the property "match" is not present on the Symbol object.\n\n//Line 2: If the property "match" is not present on the Symbol object, this line will create it with a value of Symbol(\'match\'). This means that the property "match" will be set to a new Symbol object with the description \'match\'.',
    useCase:
      "\n\nSymbol.match is used in JavaScript to provide an explicit method for determining if a given string matches a regular expression. It is typically used to create custom implementations of the String.prototype.match method, which is used to match a string against a regular expression and return an array of matched substrings. Symbol.match can also be used as a shorthand for the RegExp.prototype.exec method, which is used to execute a search for a match in a specified string.",
  },
  {
    code: "\n\nif (!Symbol.matchAll) {\n  Object.defineProperty(Symbol, 'matchAll', {\n    value: Symbol('matchAll')\n  });\n}",
    term: "Symbol.matchAll",
    explain:
      "\n\n// Line 1: This line checks whether the Symbol.matchAll property exists. If it does not exist, the code moves to line 2. \n// Line 2: This line defines a new property, Symbol.matchAll, with the value of the Symbol('matchAll') constructor. This constructor creates a new unique symbol that can be used to identify objects.",
    useCase:
      "\n\nSymbol.matchAll is used in Javascript to return an iterator of all results matching a string against a regular expression. This is especially useful when searching for multiple matches in a string. This symbol allows for the code to be more efficient and effective when searching for multiple matches.",
  },
  {
    code: "\n\nif (!Symbol.prototype.hasOwnProperty('description')) {\n\tObject.defineProperty(Symbol.prototype, 'description', {\n\t\tconfigurable: true,\n\t\tvalue: function () {\n\t\t\tlet desc;\n\t\t\tif (this.toString !== Symbol.prototype.toString) {\n\t\t\t\tdesc = this.toString();\n\t\t\t}\n\t\t\tdesc = (desc || '').substring(7, desc.length - 1);\n\t\t\treturn desc;\n\t\t}\n\t});\n}",
    term: "Symbol.prototype.description",
    explain:
      "\n\n// Line 1: This line is checking to see if the Symbol prototype already has an own property called 'description'.\n\n// Line 2: If the Symbol prototype does not already have a property called 'description', then this line defines a property called 'description' on the Symbol prototype. The configuration of the property is set to be configurable, and the value of the property is a function. \n\n// Line 3: This line declares a variable to store the description of the Symbol.\n\n// Line 4: This line checks to see if the Symbol has a toString function that is not the same as the toString function on the Symbol prototype. If so, the line assigns the result of the toString function to the desc variable.\n\n// Lines 5-7: If the Symbol does not have a toString function, or if the toString function is the same as the toString function on the Symbol prototype, then the line assigns a substring of the description to the desc variable. The substring is from the 7th character to the last character of the description.\n\n// Line 8: This line returns the description of the Symbol.",
    useCase:
      "\n\nSymbol.prototype.description is used to set a description for a Symbol primitive value. The description is a string that can be used to provide more information about the Symbol, which can be useful when debugging.",
  },
  {
    code: "\n\nif (!Symbol.replace) {\n  Object.defineProperty(Symbol, 'replace', {\n    value: Symbol('replace')\n  });\n}",
    term: "Symbol.replace",
    explain:
      "\n\n1. if (!Symbol.replace): This checks if the Symbol.replace property does not exist.\n2. Object.defineProperty(Symbol, 'replace', { This sets the replace property of the Symbol object.\n3. value: Symbol('replace') This sets the value of the replace property to a new Symbol with the key 'replace'.\n4. }); This ends the Object.defineProperty method. \n5. } This ends the if statement.",
    useCase:
      "\n\nSymbol.replace is used in Javascript as a special type of Symbol, used to provide a method that can be used to replace the contents of a string with a given value. It is useful when creating a custom string manipulator or when needing to quickly and easily replace parts of a string.",
  },
  {
    code: "\n\nif (!Symbol.search) {\n  Object.defineProperty(Symbol, 'search', {\n    value: Symbol('search')\n  });\n}",
    term: "Symbol.search",
    explain:
      "\n\n//This line checks if the Symbol 'search' exists.\nif (!Symbol.search) {\n\n//If it does not exist, this line creates a new property 'search' with a value of a Symbol('search').\n  Object.defineProperty(Symbol, 'search', {\n    value: Symbol('search')\n  });\n}",
    useCase:
      "\n\nSymbol.search is used in Javascript for its ability to provide a unique identifier for an object. This unique identifier can be used to help distinguish an object from any other object, including other objects of the same type. It can be used to help identify objects in a data structure or to facilitate object comparison. Symbol.search can also be used to create custom properties on objects, providing an additional layer of flexibility when working with data.",
  },
  {
    code: "\n\nif (typeof Symbol.species === 'undefined') {\n  Object.defineProperty(Symbol, 'species', {\n    value: Symbol('species'),\n    configurable: false,\n    writable: false,\n    enumerable: false\n  });\n}",
    term: "Symbol.species",
    explain:
      "\n\n// Line 1: This line checks if the Symbol.species property has been defined. If it has not been defined, the code in the following block will be executed. \n\n// Line 2: This line defines a new property on the Symbol object called 'species'. The value of this property is a new Symbol with the description 'species'. \n\n// Line 3: This line sets the configurable property of the 'species' property to false, meaning that it cannot be deleted or changed. \n\n// Line 4: This line sets the writable property of the 'species' property to false, meaning that its value cannot be changed. \n\n// Line 5: This line sets the enumerable property of the 'species' property to false, meaning that it will not be visible when looping over the properties of the Symbol object.",
    useCase:
      "\n\nSymbol.species is used in JavaScript to allow subclasses to override the default constructor for an object. For example, when you create an instance of an Array, the constructor will use the Array constructor. However, if you create a subclass of Array, you can override the constructor to use the subclass constructor instead by setting the Symbol.species property. This allows you to create instances of the subclass instead of the base class.",
  },
  {
    code: '\n\nif (!Symbol.split) {\n\tSymbol.split = Symbol("split");\n}',
    term: "Symbol.split",
    explain:
      "\n\n//This line checks to see if the Symbol.split variable has been defined. If it has not been defined, then it will create a new Symbol with the name 'split'. A symbol is a type of primitive data type that is created by calling the Symbol constructor. It is used to create unique identifiers for objects.",
    useCase:
      "\n\nSymbol.split is used in JavaScript to define the split method of string objects. This method is used to split a string into an array of substrings and returns the new array. This is useful for manipulating strings, such as extracting certain parts of a string or splitting a string into multiple strings.",
  },
  {
    code: "\n\n// Polyfill for Symbol.toPrimitive\nif (!Symbol.toPrimitive) {\n  Symbol.toPrimitive = symbol => {\n    switch (symbol) {\n      case Symbol.toPrimitive:\n        return 'default';\n      case Symbol.toStringTag:\n        return 'string';\n      case Symbol.toNumber:\n        return 0;\n    }\n  };\n}",
    term: "Symbol.toPrimitive",
    explain:
      "\n\n// This line checks if the Symbol.toPrimitive is defined. If not, it defines it.\nif (!Symbol.toPrimitive) {\n\n// This line defines the Symbol.toPrimitive with a switch statement. \n  Symbol.toPrimitive = symbol => {\n\n// This line checks if the symbol is Symbol.toPrimitive and returns 'default' if so.\n    switch (symbol) {\n      case Symbol.toPrimitive:\n        return 'default';\n\n// This line checks if the symbol is Symbol.toStringTag and returns 'string' if so.\n      case Symbol.toStringTag:\n        return 'string';\n\n// This line checks if the symbol is Symbol.toNumber and returns 0 if so.\n      case Symbol.toNumber:\n        return 0;\n    }\n  };\n}",
    useCase:
      "\n\nSymbol.toPrimitive is used in JavaScript to define a function that will be called when a conversion to a primitive value is requested. This allows developers to add custom logic to control how values are converted to a primitive type, such as a number or string. This can be helpful for creating custom objects that interact with other objects or functions in a desired way.",
  },
  {
    code: "\n\nif (!Symbol.toStringTag) {\n\tSymbol.toStringTag = Symbol('toStringTag');\n\n\tObject.defineProperty(Object.prototype, Symbol.toStringTag, {\n\t\tget: function () {\n\t\t\tif (this instanceof Object) {\n\t\t\t\tlet tag = Object.prototype.toString.call(this).slice(8, -1);\n\t\t\t\tif (tag !== 'Object') return tag;\n\t\t\t\tlet ctor = this.constructor;\n\t\t\t\treturn ctor && ctor.name || tag;\n\t\t\t}\n\t\t\treturn undefined;\n\t\t},\n\t\tconfigurable: true,\n\t});\n}",
    term: "Symbol.toStringTag",
    explain:
      "\n\nLine 1: \nThis line checks if the built-in Symbol.toStringTag property exists.  If it doesn’t exist, the code will proceed to the following lines and define a new Symbol.toStringTag property.\n\nLine 2: \nThis line creates a new Symbol with the name 'toStringTag' and assigns it to the Symbol.toStringTag property.\n\nLine 3: \nThis line uses the Object.defineProperty() method to define a property with the same name as the Symbol created in the previous line.\n\nLine 4: \nThis line defines the getter method for the property. This method will be called whenever the property is accessed.\n\nLine 5: \nThis line checks if the object being accessed is an instance of Object.\n\nLine 6: \nThis line calls the built-in Object.prototype.toString() method on the object and slices off the first 8 characters and the last character of the returned string. This will give us the name of the object (e.g., “Object”, “Array”, “Date”, etc.).\n\nLine 7: \nThis line checks if the name of the object is “Object”. If it is, the code will proceed to the following line; otherwise, the name will be returned.\n\nLine 8: \nThis line gets the constructor of the object (e.g., Array, Date, etc.) and assigns it to the ctor variable.\n\nLine 9:\nThis line checks if the ctor variable has a name property. If it does, the name of the constructor will be returned; otherwise, the name of the object will be returned.\n\nLine 10: \nThis line sets the configurable property of the property to true. This means that the property can be changed or deleted.",
    useCase:
      "\n\nSymbol.toStringTag is used in Javascript to provide a more descriptive string representation of an object. It allows developers to customize an object's string representation, which can be useful when debugging or logging data. This symbol can also be used to create a more accurate representation of an object, making it easier to differentiate between different types of objects.",
  },
  {
    code: "\n\nif (!Symbol.unscopables) {\n  Symbol.unscopables = Symbol('unscopables');\n  Object.defineProperty(Object.prototype, Symbol.unscopables, {\n    get: function() {\n      return this._unscopables;\n    },\n    set: function(value) {\n      this._unscopables = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n}",
    term: "Symbol.unscopables",
    explain:
      "\n\n//This code checks if Symbol.unscopables already exists. If it does not, then it defines Symbol.unscopables and set up a property on the Object prototype. \n//1. if (!Symbol.unscopables): Checks if a Symbol object with the name 'unscopables' already exists. \n//2. Symbol.unscopables = Symbol('unscopables'): If the Symbol object does not exist, then this creates a Symbol object with the name 'unscopables'. \n//3. Object.defineProperty(Object.prototype, Symbol.unscopables, {...}: Defines a property on the Object prototype with the Symbol object just created. \n//4. get: function() {return this._unscopables;}: Sets the getter function of the property to return the value of this._unscopables. \n//5. set: function(value) {this._unscopables = value;}: Sets the setter function of the property to assign the value of this._unscopables. \n//6. enumerable: false, configurable: true: Sets the property to be non-enumerable and configurable.",
    useCase:
      '\n\nSymbol.unscopables is used in JavaScript to provide hints for the engine to know which symbols should be excluded from the dynamic scope lookup when using the "with" statement. This allows developers to control which symbols are available in the scope of a given "with" statement, and which should remain in the scope of their enclosing scope. This can help to prevent unexpected behavior and unexpected access to variables.',
  },
  {
    code: '\n\n// polyfill for TextDecoder\nconst TextDecoder = function TextDecoder(encoding) {\n  // save the encoding\n  this.encoding = encoding;\n\n  // decode function\n  this.decode = function(buffer) {\n    // create a buffer view\n    const view = new Uint8Array(buffer);\n\n    // create a result variable\n    let result = "";\n\n    // loop through the buffer view\n    for (let i = 0; i < view.length; i++) {\n      // convert the byte to a character\n      result += String.fromCharCode(view[i]);\n    }\n\n    // return the result\n    return result;\n  }\n}',
    term: "TextDecoder",
    explain:
      "\n\n// This code is a polyfill for the TextDecoder API, which is a built-in browser API to decode strings from a byte array. The code creates a TextDecoder constructor function, which takes an encoding as an argument and saves it. It then creates a decode function which takes a buffer as an argument, creates a buffer view from it, creates a result string, loops through the buffer view, converting each byte to a character and adds it to the result string. Finally, it returns the result.",
    useCase:
      "\n\nTextDecoder is used in Javascript to decode binary data into strings. It is used to decode text encoded using the UTF-8, UTF-16, or UTF-32 character encoding schemes, which are the most commonly used encodings for text on the web. TextDecoder is helpful for converting binary data into a format that can be easily handled by a programming language.",
  },
  {
    code: "\n\nlet TextEncoder = window.TextEncoder || (function () {\n  function TextEncoder() { }\n\n  TextEncoder.prototype.encode = function (str) {\n    let result = [], i, c;\n    for (i = 0; i < str.length; i++) {\n      c = str.charCodeAt(i);\n      if (c < 0x80) {\n        result.push(c);\n      } else if (c < 0x800) {\n        result.push(0xC0 | (c >> 6));\n        result.push(0x80 | (c & 0x3F));\n      } else if (c < 0xD800 || c >= 0xE000) {\n        result.push(0xE0 | (c >> 12));\n        result.push(0x80 | ((c >> 6) & 0x3F));\n        result.push(0x80 | (c & 0x3F));\n      } else {\n        i++;\n        c = 0x10000 + (((c & 0x3FF) << 10) | (str.charCodeAt(i) & 0x3FF));\n        result.push(0xF0 | (c >> 18));\n        result.push(0x80 | ((c >> 12) & 0x3F));\n        result.push(0x80 | ((c >> 6) & 0x3F));\n        result.push(0x80 | (c & 0x3F));\n      }\n    }\n    return result;\n  };\n\n  return TextEncoder;\n})();",
    term: "TextEncoder",
    explain:
      "\n\n// Line 1: This line checks if the window object has a TextEncoder property. If it does, it assigns that value to the TextEncoder variable. If the window object does not have a TextEncoder property, a function (which is defined on the following lines) will be assigned to the TextEncoder variable.\n\n// Line 2: This line defines an empty TextEncoder function.\n\n// Line 3: This line adds an encode property to the TextEncoder function. The encode property has a function as its value.\n\n// Lines 4-20: This is the code for the encode function. It takes a string as an argument and returns an array of encoded characters. It loops through each character in the string and encodes them according to their character code. If the character code is less than 0x80, it is added to the result array as is. If the character code is greater than 0x80, it is encoded as a two or four byte sequence, depending on the character code.\n\n// Line 21: This line returns the TextEncoder function.\n\n// Line 22: This line closes the function that was defined on line 1.",
    useCase:
      "\n\nTextEncoder is used in JavaScript to encode strings into a format that can be used by other programs and applications. This is necessary because different applications and programs may use different character encoding formats, which can cause issues with compatibility. TextEncoder ensures that strings are encoded correctly so that they can be correctly interpreted by other systems.",
  },
  {
    code: "\n\nif (!TypedArray.prototype.at) {\n  Object.defineProperty(TypedArray.prototype, 'at', {\n    value: function (i) {\n      if (i < 0 || i >= this.length) {\n        throw new RangeError('Index out of bound');\n      }\n\n      return this[i];\n    },\n    configurable: true,\n    writable: true\n  });\n}",
    term: "TypedArray.prototype.at",
    explain:
      "\n\n// Line 1: This line checks if the TypedArray.prototype object has a property called 'at'.\n// Line 2: If the property 'at' does not exist, the Object.defineProperty method is used to create it. This method allows setting the value and configuration of the 'at' property.\n// Line 3: The value for the 'at' property is set to be a function that takes one argument 'i'.\n// Line 4: If the value of 'i' is less than 0 or greater than or equal to the length of the array, an error is thrown.\n// Line 5: If the value of 'i' is valid, the element at the index 'i' is returned.\n// Line 6-8: The 'at' property is set to be configurable and writable.",
    useCase:
      "\n\nTypedArray.prototype.at() is used in Javascript to provide a more performant way of accessing and manipulating the values in a TypedArray. It allows for direct access to a specific item in the array without having to loop through the entire array. This makes it much faster than the traditional array methods. Additionally, the .at() method can be used to update a single item in the array without affecting the rest of the values in the array.",
  },
  {
    code: "\n\nif (typeof window.URL === 'undefined') {\n  window.URL = function(url) {\n    var a = document.createElement('a');\n    a.href = url;\n    return {\n      href: a.href,\n      host: a.host,\n      port: a.port,\n      hash: a.hash,\n      hostname: a.hostname,\n      pathname: a.pathname,\n      origin: a.origin,\n      protocol: a.protocol,\n      search: a.search,\n    };\n  };\n}",
    term: "URL",
    explain:
      "\n\n// Line 1: This line checks if the type of the window.URL is undefined. \n// If it is undefined, the code block will be executed.\n\n// Line 2: If the type of window.URL is undefined, this line creates a function called URL which accepts an argument called url.\n\n// Line 3: This line creates an element called a and assigns the argument passed to the URL function to it. \n\n// Line 4-11: This code block creates an object and assigns the properties of the element a to it. \n\n// Line 12: This line closes the if statement.",
    useCase:
      "\n\nURLs (Uniform Resource Locators) are used in JavaScript to specify the location of a resource on the web. They are typically used to link to web pages, images, videos, and other online resources. URLs are also used to send data to a web server using Ajax requests, allowing for dynamic content to be loaded without the need for a full page reload.",
  },
  {
    code: '\n\n// Polyfill for URL.prototype.toJSON\nif (!URL.prototype.toJSON) {\n  Object.defineProperty(URL.prototype, "toJSON", {\n    value: function () {\n      return {\n        href: this.href,\n        origin: this.origin,\n        protocol: this.protocol,\n        username: this.username,\n        password: this.password,\n        host: this.host,\n        hostname: this.hostname,\n        port: this.port,\n        pathname: this.pathname,\n        search: this.search,\n        searchParams: this.searchParams,\n        hash: this.hash\n      };\n    },\n    writable: true,\n    configurable: true\n  });\n}',
    term: "URL.prototype.toJSON",
    explain:
      "\n\n// Line 1:\n// Check if the URL.prototype has a toJSON method. \n// If it does not, then proceed to the code below.\n\n// Line 2:\n// Defines a new property to the URL.prototype, called toJSON.\n\n// Line 3-15:\n// The value of the property is a function. \n// The function returns an object with all the properties of the URL object. \n// These properties are: href, origin, protocol, username, password, host, hostname, port, pathname, search, searchParams, and hash.\n\n// Line 16:\n// Set the writable attribute of the property to true, meaning that the value of the property can be changed.\n\n// Line 17:\n// Set the configurable attribute to true, meaning that the property can be deleted and reconfigured.",
    useCase:
      "\n\nThe URL.prototype.toJSON() method is used in JavaScript to convert a URL object into a JSON string. This is useful when working with web services that require URLs to be passed as a string. It also allows for easier manipulation of the URL data when used in conjunction with other JSON methods such as parse and stringify.",
  },
  {
    code: "\n\nif(!window.URLSearchParams) {\n  window.URLSearchParams = class URLSearchParams {\n    constructor(search) {\n      this.params = search.split('&').reduce((params, keyVal) => {\n        let [key, val] = keyVal.split('=');\n        params[key] = decodeURIComponent(val);\n        return params;\n      }, {});\n    }\n    \n    get(key) {\n      return this.params[key];\n    }\n    \n    has(key) {\n      return this.params.hasOwnProperty(key);\n    }\n    \n    set(key, val) {\n      this.params[key] = val;\n    }\n    \n    toString() {\n      return Object.keys(this.params).map((k) => `${k}=${encodeURIComponent(this.params[k])}`).join('&');\n    }\n  }\n}",
    term: "URLSearchParams",
    explain:
      "\n\n//1. if(!window.URLSearchParams) { \n//    This line checks if the window object has a URLSearchParams property. If it doesn't it will execute the following code.\n\n//2. window.URLSearchParams = class URLSearchParams { \n//    This line adds a URLSearchParams property to the window object.\n\n//3. constructor(search) { \n//    This is the constructor for the URLSearchParams class. It takes a search string as an argument.\n\n//4. this.params = search.split('&').reduce((params, keyVal) => { \n//    This line splits the search string into an array of strings separated by the & character. Then it uses the reduce() method to create an object containing key/value pairs.\n\n//5. let [key, val] = keyVal.split('='); \n//    This line uses destructuring assignment to assign the key and value variables from the keyVal string.\n\n//6. params[key] = decodeURIComponent(val); \n//    This line sets the key and value in the params object.\n\n//7. return params; \n//    This line returns the params object.\n\n//8. get(key) { \n//    This method returns the value for the specified key.\n\n//9. has(key) { \n//    This method checks if the specified key exists in the params object.\n\n//10. set(key, val) { \n//    This method sets the specified key and value in the params object.\n\n//11. toString() { \n//    This method returns a string representation of the params object.\n\n//12. } \n//    This line closes the URLSearchParams class.\n\n//13. } \n//    This line closes the if statement.",
    useCase:
      "\n\nURLsearchParams is used in Javascript to easily parse and manipulate the query string of a URL. It makes it easier to access and modify the query string parameters for a URL without having to parse the string manually. It can also be used to add new parameters to the URL, which can be useful for tracking and analytics.",
  },
  {
    code: "\n\nif (!Uint16Array) {\n    Uint16Array = function (length) {\n        var arr = new Array(length);\n        for (var i = 0; i < length; i++) {\n            arr[i] = 0;\n        }\n        arr.byteLength = length * 2;\n        arr.set = function (index, value) {\n            arr[index] = (value & 0xff);\n            arr[index + 1] = (value >> 8) & 0xff;\n        };\n        arr.get = function (index) {\n            return arr[index] | (arr[index + 1] << 8);\n        };\n        return arr;\n    };\n}",
    term: "Uint16Array",
    explain:
      "\n\n//This code is creating a Uint16Array constructor if it does not already exist.\n1. if (!Uint16Array) { //This checks if the Uint16Array constructor already exists\n2. Uint16Array = function (length) { //This creates the Uint16Array constructor if it does not already exist\n3. var arr = new Array(length); //This creates a new array of size 'length'\n4. for (var i = 0; i < length; i++) { //This loop assigns each element in the array a value of 0\n5. arr[i] = 0;\n6. }\n7. arr.byteLength = length * 2; //This assigns the byteLength property of the array to double the length of the array \n8. arr.set = function (index, value) { //This creates a method on the array to set a given index to a value\n9. arr[index] = (value & 0xff); //This sets the element at the given index to the value\n10. arr[index + 1] = (value >> 8) & 0xff; //This sets the element at the given index+1 to the value shifted 8 bits\n11. };\n12. arr.get = function (index) { //This creates a method on the array to get the value of a given index \n13. return arr[index] | (arr[index + 1] << 8); //This returns the element at the given index and the element at the given index+1 shifted 8 bits\n14. };\n15. return arr; //This returns the array\n16. };\n17. }",
    useCase:
      "\n\nUint16Array is used in Javascript when dealing with large amounts of data that is represented by integers. It is a typed array that stores data in a 16-bit (2-byte) unsigned integer format, which allows for a larger range of values than the regular 8-bit formats. This is useful for situations such as when dealing with large images or audio files, as it allows for faster and more efficient storage and manipulation of the data.",
  },
  {
    code: "\n\nfunction Uint32ArrayPolyfill(length) {\n\tthis.length = length;\n\tthis.byteLength = length * 4;\n\tlet bytes = new Array(this.byteLength);\n\t\n\tthis.fill = function(value, start = 0, end = this.byteLength) {\n\t\tlet i = start;\n\t\twhile (i < end) {\n\t\t\tbytes[i] = value & 0xFF;\n\t\t\tvalue >>= 8;\n\t\t\ti++;\n\t\t}\n\t\treturn this;\n\t}\n\n\tthis.getUint8 = function(index, littleEndian = false) {\n\t\tlet i = index * 4;\n\t\tif (littleEndian) {\n\t\t\treturn bytes[i]\n\t\t\t\t\t| (bytes[i + 1] << 8)\n\t\t\t\t\t| (bytes[i + 2] << 16)\n\t\t\t\t\t| (bytes[i + 3] << 24)\n\t\t} else {\n\t\t\treturn bytes[i + 3]\n\t\t\t\t\t| (bytes[i + 2] << 8)\n\t\t\t\t\t| (bytes[i + 1] << 16)\n\t\t\t\t\t| (bytes[i] << 24)\n\t\t}\n\t}\n\n\tthis.setUint8 = function(index, value, littleEndian = false) {\n\t\tlet i = index * 4;\n\t\tif (littleEndian) {\n\t\t\tbytes[i] = value & 0xFF;\n\t\t\tbytes[i + 1] = (value >> 8) & 0xFF;\n\t\t\tbytes[i + 2] = (value >> 16) & 0xFF;\n\t\t\tbytes[i + 3] = (value >> 24) & 0xFF;\n\t\t} else {\n\t\t\tbytes[i + 3] = value & 0xFF;\n\t\t\tbytes[i + 2] = (value >> 8) & 0xFF;\n\t\t\tbytes[i + 1] = (value >> 16) & 0xFF;\n\t\t\tbytes[i] = (value >> 24) & 0xFF;\n\t\t}\n\t}\n\n\treturn this;\n}",
    term: "Uint32Array",
    explain:
      "\n\n// Line 1: This function is defining a constructor function which creates an object with a property length.\n// Line 2: The byteLength property of the object is set to the length of the object multiplied by 4.\n// Line 3: A new array called bytes is created with the length of the object's byteLength.\n// Line 4: This is defining a fill method which takes in three parameters: value, start, and end.\n// Line 5: The index i is set to the value of the start parameter.\n// Line 6: A while loop is started which will run until the value of i is no longer less than the end parameter.\n// Line 7: The value at the current index of the bytes array is set to value with the bitwise and operator only keeping the 8 least significant bits.\n// Line 8: The value is shifted to the right by 8 bits.\n// Line 9: The index i is incremented by 1.\n// Line 10: The fill method returns the object.\n// Line 11: This is defining a getUint8 method which takes in two parameters: index, and littleEndian.\n// Line 12: The index is multiplied by 4 and stored in i.\n// Line 13: An if statement is started which will check if the littleEndian parameter is true.\n// Line 14: If the littleEndian parameter is true, the value at index i of the bytes array is returned with the bitwise or operator combining the bits from each of the following indices.\n// Line 15: If the littleEndian parameter is false, the value at index i + 3 of the bytes array is returned with the bitwise or operator combining the bits from each of the following indices.\n// Line 16: This is defining a setUint8 method which takes in three parameters: index, value, and littleEndian.\n// Line 17: The index is multiplied by 4 and stored in i.\n// Line 18: An if statement is started which will check if the littleEndian parameter is true.\n// Line 19: If the littleEndian parameter is true, the value at index i of the bytes array is set to value with the bitwise and operator only keeping the 8 least significant bits and the bits at the following indices are shifted to the left accordingly and set.\n// Line 20: If the littleEndian parameter is false, the value at index i + 3 of the bytes array is set to value with the bitwise and operator only keeping the 8 least significant bits and the bits at the following indices are shifted to the left accordingly and set.\n// Line 21: The object is returned.",
    useCase:
      "\n\nUint32Array is used in Javascript because it is an array-like view into the underlying binary data buffer. It is used to represent an array of 32-bit unsigned integers, which is perfect for tasks such as bitwise operations, indexing into arrays, and more. It is also more efficient than regular arrays because it stores its data in a more compact format, allowing for faster access and manipulation.",
  },
  {
    code: "\n\nif(!Uint8Array){\n  Uint8Array = function(len, init){\n    var arr = new Array(len);\n    if (init){\n      for (var i = 0; i < len; i++){\n        arr[i] = init;\n      }\n    }\n    return arr;\n  }\n}",
    term: "Uint8Array",
    explain:
      "\n\n// Line 1: This line checks to see if the Uint8Array is defined. If it is not defined, then the code in the block will execute.\n\n// Line 2: This line creates a function called Uint8Array, which takes two parameters: len and init.\n\n// Line 3: This line creates an array with the length specified by the len parameter.\n\n// Line 4: This line checks to see if the init parameter is defined. If it is, then it will loop through the array and set each element to the value of the init parameter.\n\n// Line 5: This line returns the array that was created. \n\n// Line 6: This line closes the if statement from line 1.",
    useCase:
      "\n\nUint8Array is used in Javascript because it is an array-like view on an underlying binary data buffer, and is specifically designed to store 8-bit unsigned integers. This makes it ideal for representing a range of binary data such as raw image data, or for storing large amounts of data efficiently, such as data from a network socket. It is also very fast and efficient to use, making it a popular choice for developers.",
  },
  {
    code: "\n\nif (!Uint8ClampedArray) {\n  Uint8ClampedArray = function(length) {\n    const result = new Uint8Array(length);\n    Object.setPrototypeOf(result, Uint8ClampedArray.prototype);\n    return result;\n  };\n\n  Uint8ClampedArray.prototype = Object.create(Uint8Array.prototype, {\n    constructor: {\n      value: Uint8ClampedArray,\n      writable: true,\n      configurable: true\n    }\n  });\n}",
    term: "Uint8ClampedArray",
    explain:
      "\n\n// Line 1: This line checks to see if Uint8ClampedArray is defined in the environment. \n// If it is not defined, the code beneath this line will be executed.\n\n// Line 2-4: This code creates a custom Uint8ClampedArray function and sets its prototype to the Uint8ClampedArray.prototype object.\n\n// Line 5-8: This code creates an object with the constructor property set to the Uint8ClampedArray function. This allows the custom Uint8ClampedArray function to act as a constructor and create instances of Uint8ClampedArray.",
    useCase:
      "\n\nUint8ClampedArray is used in Javascript because it is an array of 8-bit unsigned integers (integers in the range of 0 to 255) whose values are clamped to 0 and 255 when out-of-range values are assigned. It is useful for manipulating and representing image data, such as pixel data, which is often represented as 8-bit unsigned integers.",
  },
  {
    code: "\n\n(function() {\n  if (!window.performance || !window.performance.now || !window.performance.mark) {\n    window.performance = {\n      now: function() {\n        return Date.now();\n      },\n      mark: function(name) {\n        window.performance[name] = window.performance.now();\n      },\n      measure: function(name, startMark, endMark) {\n        if (!window.performance[startMark]) {\n          console.warn('Unable to find mark: ', startMark);\n        } else if (!window.performance[endMark]) {\n          console.warn('Unable to find mark: ', endMark);\n        } else {\n          window.performance[name] =\n            window.performance[endMark] - window.performance[startMark];\n        }\n      },\n      getEntriesByName: function(name) {\n        return window.performance[name] ? [{ name, entryType: 'measure', startTime: 0, duration: window.performance[name] }] : [];\n      },\n      clearMarks: function(name) {\n        delete window.performance[name];\n      },\n      clearMeasures: function(name) {\n        delete window.performance[name];\n      }\n    };\n  }\n})();",
    term: "UserTiming",
    explain:
      "\n\n//1. (function() { ... })();:  This line creates an anonymous self-executing function that runs the code within it. This allows us to create a local scope and prevent variables from leaking into the global scope.\n\n//2. if (!window.performance || !window.performance.now || !window.performance.mark): This line checks to see if the performance API is available. The performance API allows us to measure the performance of our code. If the API is not available, then we need to create an implementation of it.\n\n//3. window.performance = { ... }: This line assigns an object containing our implementation of the performance API to the window.performance variable. This will allow us to use the performance API in our code.\n\n//4. now: function() { return Date.now(); },: This line assigns a function to the now property of the performance API. This function returns the current timestamp.\n\n//5. mark: function(name) { window.performance[name] = window.performance.now(); },: This line assigns a function to the mark property of the performance API. This function stores a timestamp in the window.performance object with the name specified as an argument.\n\n//6. measure: function(name, startMark, endMark) {...}: This line assigns a function to the measure property of the performance API. This function calculates the time difference between two timestamps stored in the window.performance object.\n\n//7. getEntriesByName: function(name) {...}: This line assigns a function to the getEntriesByName property of the performance API. This function returns an array of performance entries with the specified name.\n\n//8. clearMarks: function(name) { delete window.performance[name]; },: This line assigns a function to the clearMarks property of the performance API. This function deletes a mark from the window.performance object with the specified name.\n\n//9. clearMeasures: function(name) { delete window.performance[name]; }: This line assigns a function to the clearMeasures property of the performance API. This function deletes a measure from the window.performance object with the specified name.",
    useCase:
      "\n\nUserTiming is used in JavaScript to measure the performance of code execution. It allows developers to measure the time taken for code to execute by providing a set of APIs to track and measure the performance of JavaScript code. This allows developers to analyze the performance of their code and optimize it for better performance. Additionally, UserTiming can be used to measure the performance of third-party code and track performance issues.",
  },
  {
    code: "\n\nif(window.WeakMap === undefined){\n\nWeakMap = function(){\n    var keys = [];\n    var values = [];\n\n    this.set = function(key, value){\n        keys.push(key);\n        values.push(value);\n    };\n\n    this.get = function(key){\n        var index = keys.indexOf(key);\n        if(index !== -1){\n            return values[index];\n        } else {\n            return undefined;\n        }\n    };\n\n    this.delete = function(key){\n        var index = keys.indexOf(key);\n        if(index !== -1){\n            keys.splice(index, 1);\n            values.splice(index, 1);\n        }\n    };\n\n    this.has = function(key){\n        if(keys.indexOf(key) !== -1){\n            return true;\n        } else {\n            return false;\n        }\n    };\n};\n\n}",
    term: "WeakMap",
    explain:
      "\n\n// Line 1: \n// This line checks if the global variable 'window.WeakMap' is undefined. \n\n// Line 2: \n// This line creates a new function called WeakMap if the global variable 'window.WeakMap' is undefined.\n\n// Line 3: \n// This line declares two arrays, 'keys' and 'values', which will be used to store key-value pairs.\n\n// Line 4-7: \n// This block of code creates a function called 'set' which takes in a key and a value as parameters.  It then pushes both the key and the value onto the 'keys' and 'values' arrays.\n\n// Line 8-13: \n// This block of code creates a function called 'get' which takes in a key as a parameter. It then finds the index of the key in the 'keys' array and returns the corresponding value from the 'values' array. If the key is not found, it returns 'undefined'.\n\n// Line 14-18: \n// This block of code creates a function called 'delete' which takes in a key as a parameter. It then finds the index of the key in the 'keys' array and removes both the key and the corresponding value from the 'keys' and 'values' arrays.\n\n// Line 19-23: \n// This block of code creates a function called 'has' which takes in a key as a parameter. It then checks if the key is present in the 'keys' array and returns true if it is, or false if it is not.",
    useCase:
      "\n\nWeakMap is used in Javascript because it provides a way to store key/value pairs in a way that is similar to a regular Map, with the added feature that the keys are weakly referenced. This means that the keys are only held weakly in memory and can be garbage collected if there are no other references to them. This allows WeakMap to be used for creating private data structures that are not exposed to the outside world.",
  },
  {
    code: "\n\nif(!window.WeakSet) {\n  window.WeakSet = (function () {\n    var index = 0;\n    var items = {};\n    var WeakSet = function WeakSet() {\n      Object.defineProperty(this, 'index', {\n        enumerable: false,\n        value: index\n      });\n      Object.defineProperty(this, 'items', {\n        enumerable: false,\n        value: items\n      });\n      index++;\n    };\n    WeakSet.prototype.add = function add(object) {\n      if (object && typeof object === 'object') {\n        this.items[this.index] = object;\n      }\n    };\n    WeakSet.prototype.has = function has(object) {\n      if (object && typeof object === 'object') {\n        return this.items[this.index] === object;\n      }\n      return false;\n    };\n    WeakSet.prototype.delete = function deleteFn(object) {\n      if (object && typeof object === 'object') {\n        delete this.items[this.index];\n      }\n    };\n    WeakSet.prototype.clear = function clear() {\n      this.items = {};\n    };\n    return WeakSet;\n  }());\n}",
    term: "WeakSet",
    explain:
      "\n\n// Line 1: This line checks if the WeakSet object is not defined in the window, if it is not then it will execute the code in the if statement.\n// Line 2: This line defines a window object property called WeakSet, which is a function.\n// Line 3-6: This code creates a new index and items object, which will store the data for the WeakSet.\n// Line 7: This line creates a new WeakSet object.\n// Line 8-10: This code defines two properties, index and items, and sets them to their respective values.\n// Line 11: This line increments the index counter.\n// Line 12-17: This code defines the add method of the WeakSet object, which adds an object to the items object.\n// Line 18-22: This code defines the has method of the WeakSet object, which checks if an object is in the items object.\n// Line 23-27: This code defines the delete method of the WeakSet object, which deletes an object from the items object.\n// Line 28-30: This code defines the clear method of the WeakSet object, which clears all objects from the items object.\n// Line 31: This line returns the WeakSet object.",
    useCase:
      "\n\nWeakSets are used in JavaScript as a way to store weakly held objects. WeakSets are collections of objects where the objects are held weakly and can be garbage collected if they are no longer referenced. This is useful for keeping track of a collection of objects without them being retained in memory, which is useful when memory management is a concern.",
  },
  {
    code: "\n\n(function() {\n  // check for browser support for the WebAnimations API\n  // IE, Edge, and Safari do not currently have native support\n  if (!('animate' in Element.prototype)) {\n    // polyfill Element.prototype.animate\n    Element.prototype.animate = function(props, options) {\n      // create a new animation object\n      var animation = new Animation(this, props, options);\n      // return the animation object\n      return animation;\n    };\n\n    // polyfill the Animation constructor\n    var Animation = function(el, props, options) {\n      // set animation options\n      this.duration = options.duration || 500;\n      this.easing = options.easing || 'ease';\n\n      // set element and props for animation\n      this.el = el;\n      this.props = props;\n\n      // set a counter for frames\n      this.frame = 0;\n\n      // set an interval to step through the animation\n      var self = this;\n      this.interval = setInterval(function() {\n        self.step();\n      }, this.duration / 60);\n    };\n\n    // polyfill the animation step method\n    Animation.prototype.step = function() {\n      // get the current frame\n      var frame = this.frame;\n\n      // set the current style\n      for (var prop in this.props) {\n        if (this.props.hasOwnProperty(prop)) {\n          // use the easing function to calculate the progress\n          var progress = this.easing(frame / this.duration);\n\n          // calculate the value for the frame\n          var value = this.props[prop].start + (this.props[prop].end - this.props[prop].start) * progress;\n\n          // set the value\n          this.el.style[prop] = value + 'px';\n        }\n      }\n\n      // increment the frame\n      this.frame++;\n\n      // check if the animation is complete\n      if (this.frame >= this.duration) {\n        // clear the interval\n        clearInterval(this.interval);\n      }\n    };\n\n    // polyfill the easing function\n    Animation.prototype.easing = function(x) {\n      return x;\n    };\n  }\n})();",
    term: "WebAnimations",
    explain:
      "\n\n// Line 1\n// (function() {}) is an Immediately Invoked Function Expression (IIFE) which runs the code inside of it immediately\n\n// Line 4\n// This line checks to see if the browser supports the Web Animations API. Browsers such as IE, Edge, and Safari do not have native support.\n\n// Line 6\n// This line polyfills Element.prototype.animate. This will allow the browser to recognize the animate method when called.\n\n// Line 11\n// This line creates a new Animation object. This contains properties such as the element, props, duration, and easing.\n\n// Line 15\n// This line sets an interval to step through the animation. The duration is set by the options parameter in the animate method.\n\n// Line 21\n// This line calculates the progress of the animation using the easing function.\n\n// Line 24\n// This line sets the value of the property for the current frame.\n\n// Line 27\n// This line increments the frame counter by one.\n\n// Line 30\n// This line checks to see if the animation is complete. If it is, the interval is cleared.\n\n// Line 35\n// This line polyfills the easing function. By default, it returns the value of x, which will make the animation have a linear effect.",
    useCase:
      "\n\nWebAnimations is used in Javascript to provide a high-performance animation library that allows developers to create smooth, complex, and well-timed animations for websites, apps, and other digital products. WebAnimations is a powerful tool because it can animate any element on a web page, including those with dynamic content. It also provides support for a wide variety of animation techniques, such as keyframes, timing functions, and even custom animation functions. WebAnimations is also a cross-platform technology, meaning it can be used in both desktop and mobile web browsers.",
  },
  {
    code: "\n\nif (typeof window === 'undefined') {\n  const window = new Object();\n  window.document = new Object();\n  window.location = new Object();\n  window.history = new Object();\n  window.navigator = new Object();\n  window.alert = function(str) { console.log(str); };\n  window.setTimeout = function(fn, delay) { setTimeout(fn, delay); };\n  window.setInterval = function(fn, delay) { setInterval(fn, delay); };\n  window.confirm = function(str) { console.log(str); };\n  window.innerWidth = 0;\n  window.innerHeight = 0;\n  window.screen = new Object();\n  window.screen.width = 0;\n  window.screen.height = 0;\n}",
    term: "Window",
    explain:
      "\n\n//This code is checking to see if the window object is already defined. If it is not, then it is defining the window object and setting properties for it. \n//Line 1: This line is checking to see if the window object is already defined. \n//Line 2: This line is defining the window object as an object. \n//Line 3: This line is setting the document property of the window object to an object. \n//Line 4: This line is setting the location property of the window object to an object. \n//Line 5: This line is setting the history property of the window object to an object. \n//Line 6: This line is setting the navigator property of the window object to an object. \n//Line 7: This line is setting the alert function of the window object to a function that logs a string. \n//Line 8: This line is setting the setTimeout function of the window object to a function that sets a timeout with a given delay. \n//Line 9: This line is setting the setInterval function of the window object to a function that sets an interval with a given delay. \n//Line 10: This line is setting the confirm function of the window object to a function that logs a string. \n//Line 11: This line is setting the innerWidth property of the window object to 0. \n//Line 12: This line is setting the innerHeight property of the window object to 0. \n//Line 13: This line is setting the screen property of the window object to an object. \n//Line 14: This line is setting the width property of the screen object to 0. \n//Line 15: This line is setting the height property of the screen object to 0.",
    useCase:
      "\n\nWindow is used in Javascript to provide the global context for the code to run in. It creates a number of global objects, such as the window object, the document object, the history object, and the location object, which can be accessed from anywhere in the code. It also provides access to features such as timers, dialog boxes, and the ability to manipulate the browser's window size.",
  },
  {
    code: "\n\n//polyfill for XMLHttpRequest\nif (!window.XMLHttpRequest) {\n  window.XMLHttpRequest = function () {\n    let request\n\n    if (window.ActiveXObject) {\n      try {\n        request = new ActiveXObject('Msxml2.XMLHTTP')\n      } catch (e) {\n        request = new ActiveXObject('Microsoft.XMLHTTP')\n      }\n    } else {\n      request = new XMLHttpRequest()\n    }\n\n    const methods = {\n      open: function (method, url) {\n        request.open(method, url)\n        return this\n      },\n      send: function (data) {\n        request.send(data)\n        return this\n      },\n      setRequestHeader: function (key, value) {\n        request.setRequestHeader(key, value)\n        return this\n      },\n      getResponseHeader: function (key) {\n        return request.getResponseHeader(key)\n      },\n      onload: function (callback) {\n        request.onreadystatechange = function () {\n          if (request.readyState === 4 && request.status === 200) {\n            callback(request.response)\n          }\n        }\n        return this\n      }\n    }\n\n    return Object.create(methods)\n  }\n}",
    term: "XMLHttpRequest",
    explain:
      "\n\n// Line 1: \n// This is a polyfill for the XMLHttpRequest object which is used to send HTTP requests. \n\n// Line 2: \n// This line checks if the browser supports the XMLHttpRequest object. \n\n// Line 3: \n// If the browser does not have the XMLHttpRequest object, this line defines the window.XMLHttpRequest object with a function. \n\n// Line 4: \n// This line initializes the request variable. \n\n// Line 5-9: \n// This set of lines checks if the browser uses the ActiveXObject and tries to create a new ActiveXObject for the request. \n\n// Line 10: \n// If the browser does not use the ActiveXObject, it creates a new XMLHttpRequest object. \n\n// Line 12-19: \n// This set of lines defines the methods of the window.XMLHttpRequest object. It includes open, send, setRequestHeader, getResponseHeader, and onload methods. \n\n// Line 20: \n// This line returns an object containing the methods of the window.XMLHttpRequest object.",
    useCase:
      "\n\nXMLHttpRequest (XHR) is used in JavaScript to make asynchronous HTTP requests to a web server. It is used to send and receive data, as well as update webpages without having to reload the page. This helps allow webpages to be more dynamic and interactive. It is also used to transfer data from a server to a client or from a client to a server.",
  },
  {
    code: "\n\nfunction atob(str) {\n  let output = '';\n  const keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n  str = String(str).replace(/=+$/, '');\n  if (str.length % 4 === 1) {\n    throw new Error('atob failed: The string to be decoded is not correctly encoded.');\n  }\n  for (let bc = 0, bs = 0, buffer, i = 0; buffer = str.charAt(i++); ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n    bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {\n    buffer = keyStr.indexOf(buffer);\n  }\n  return output;\n}",
    term: "atob",
    explain:
      '\n\n//Line 1: \n//This line is declaring a function called atob that takes a parameter called str. This function will be used to decode a string from base-64 encoded format.\n\n//Line 2:\n//This line is declaring a variable named output and setting it equal to an empty string. This variable will be used to store the output of the atob function.\n\n//Line 3:\n//This line is declaring a constant called keyStr and setting it equal to a string of characters. This string contains all the characters used in base-64 encoding.\n\n//Line 4:\n//This line is using the String.replace() method to replace any trailing "=" characters with an empty string. This is done to ensure that the string is correctly encoded.\n\n//Line 5:\n//This line is using an if statement to check if the length of the str parameter is not divisible by 4. If it is not, the function will throw an error.\n\n//Line 6:\n//This line is declaring two variables: bc and bs. bc will be used to store the character index of the string being decoded, and bs will be used to store the encoded character.\n\n//Line 7:\n//This line is declaring a variable called buffer and setting it equal to the character at the current index of the string.\n\n//Line 8:\n//This line is using a ternary operator to check if the buffer variable is defined and if the bc variable is divisible by 4. If both are true, it sets the bs variable equal to the encoded character. Otherwise, it sets it equal to zero.\n\n//Line 9:\n//This line is using the String.fromCharCode() method to convert the bs variable to a character and then adding it to the output variable.\n\n//Line 10:\n//This line is using the indexOf() method to find the index of the character in the keyStr variable.',
    useCase:
      "\n\nAtob is used in JavaScript to decode a base-64 encoded string. It takes a string as an argument and returns a decoded string. It is used to decode data that has been encoded using the btoa() method, which is used to encode a string into base-64 format. It is mainly used when dealing with data that needs to be transferred across different platforms, like when sending an email or when transferring data over the internet.",
  },
  {
    code: "\n\n(function () {\n  var console = window.console || {};\n  \n  if(typeof console.log !== 'function') {\n    console.log = function() {};\n  }\n  if(typeof console.info !== 'function') {\n    console.info = console.log;\n  }\n  if(typeof console.warn !== 'function') {\n    console.warn = console.log;\n  }\n  if(typeof console.error !== 'function') {\n    console.error = console.log;\n  }\n  \n  window.console = console;\n})();",
    term: "console",
    explain:
      "\n\n//Line 1: This line is creating an anonymous function which will be executed immediately \n//Line 2: This line is declaring a variable called console and assigning the value of the window.console property to it. If window.console is undefined, the value of console is set to an empty object.\n//Line 4: This line checks to see if the console.log method is a function. If not, it sets the console.log method to an empty function.\n//Line 6: This line checks to see if the console.info method is a function. If not, it sets the console.info method to the console.log method.\n//Line 8: This line checks to see if the console.warn method is a function. If not, it sets the console.warn method to the console.log method.\n//Line 10: This line checks to see if the console.error method is a function. If not, it sets the console.error method to the console.log method.\n//Line 12: This line sets the window.console property to the value of the console variable.",
    useCase:
      "\n\nConsole is used in Javascript to provide a way for developers to log information, debug code, and interact with the browser. It is a great way to quickly test and debug code, as it can be used to log messages and errors, inspect objects and variables, and interact with the browser. Additionally, it provides a way to quickly test code without having to reload the page or create a new page.",
  },
  {
    code: "\n\nif (!console.assert) {\n  console.assert = function(assertion, message) {\n    if (!assertion) {\n      throw new Error(message);\n    }\n  };\n}",
    term: "console.assert",
    explain:
      "\n\n// Line 1: This line checks if there is an existing console.assert function available.\n// Line 2: If there is no existing console.assert function, this line creates a new function called console.assert as a property of the console object.\n// Line 3: This line checks if the assertion passed into the function is false.\n// Line 4: If the assertion is false, this line throws an error with the given message.\n// Line 5: This line is the closing bracket for the if statement.",
    useCase:
      "\n\nConsole.assert is used in Javascript to test a given condition and display a message in the console if the condition is false. This is useful for debugging purposes and can help to identify potential errors in code. By using console.assert, developers can quickly pinpoint and troubleshoot any issues they may be having.",
  },
  {
    code: "\n\nif (typeof console.clear === 'undefined') {\n  console.clear = () => {\n    console.log('\\x1Bc')\n  }\n}",
    term: "console.clear",
    explain:
      "\n\n//line 1: This line checks if there is a function called clear() inside the console object. \n//If there is no such function, the code will proceed to line 2.\n\n//line 2: This line creates a new function called clear() inside the console object. \n//The function will log a special character to the console, which will clear the console.",
    useCase:
      "\n\nConsole.clear is used in JavaScript to clear the console of any previous messages and data. This is useful for developers to keep their console organized and to troubleshoot any errors that may have occurred in their code. It is also helpful for debugging purposes as it allows developers to start with a clean slate and inspect any new messages or data that may arise.",
  },
  {
    code: '\n\n(function() {\n  if (!console.count) {\n    console.count = function(label = "default") {\n      if (!this.count.counters) {\n        this.count.counters = {};\n      }\n      if (!this.count.counters[label]) {\n        this.count.counters[label] = 0;\n      }\n      this.count.counters[label]++;\n      console.log(`${label}: ${this.count.counters[label]}`);\n    };\n  }\n})();',
    term: "console.count",
    explain:
      '\n\n1. (function() {...}: This line creates a function that will contain the following code.\n2. if (!console.count): This line checks to see if there is a function called count in the console object.\n3. console.count = function(label = "default"): This line creates a function called count in the console object and sets the default label to "default".\n4. if (!this.count.counters): This line checks to see if there is a property called counters in the count object.\n5. this.count.counters = {};: This line creates an empty object called counters in the count object.\n6. if (!this.count.counters[label]): This line checks to see if the label passed in as an argument is already defined in the counters object.\n7. this.count.counters[label] = 0;: This line sets the value of the label in the counters object to 0.\n8. this.count.counters[label]++;: This line increments the value of the label in the counters object by 1.\n9. console.log(`${label}: ${this.count.counters[label]}`): This line logs the label and its value in the console.',
    useCase:
      "\n\nConsole.count is used in Javascript to log a count of how many times a specific string has been logged to the console. It's useful for tracking how often a certain operation is performed or for debugging purposes.",
  },
  {
    code: "\n\nif (!console.debug) {\n    console.debug = (...args) => {\n        args.unshift('[debug]:');\n        console.log.apply(console, args);\n    };\n}",
    term: "console.debug",
    explain:
      '\n\n// Line 1: This line checks if the debug function does not exist in the console object. \n// Line 2: This line creates a new debug function in the console object. This function takes in any number of arguments, and prepends each with "[debug]:".\n// Line 3: This line calls the console.log function, passing in the args array, with the prepended elements.',
    useCase:
      "\n\nConsole.debug is used in Javascript to provide additional information about the execution of a program. It can be used to log debugging information, errors, warnings, and other data to a console output. This is useful for debugging code, especially in large applications, as it provides a way to quickly identify and debug issues.",
  },
  {
    code: "\n\nif (!console.dir) {\n  console.dir = function (object) {\n    var objectString = JSON.stringify(object, undefined, 2);\n    console.log(objectString);\n  };\n}",
    term: "console.dir",
    explain:
      "\n\n// This line checks to see if the console.dir function already exists. \nif (!console.dir) {\n\n// If the console.dir function does not exist, this code creates it.\n  console.dir = function (object) {\n\n// This line uses the JSON.stringify method to convert the object into a string.\n    var objectString = JSON.stringify(object, undefined, 2);\n\n// This line logs the stringified object to the console.\n    console.log(objectString);\n  };\n}",
    useCase:
      "\n\nConsole.dir is used in JavaScript to log an interactive list of the properties of a specified JavaScript object. This can be useful when debugging an application as it allows you to quickly inspect the values of an object’s properties. It also makes it easier to inspect an object’s prototype chain.",
  },
  {
    code: "\n\n// console.dirxml polyfill\nif (typeof console.dirxml === 'undefined') {\n  console.dirxml = function(object) {\n    if (typeof object === 'undefined') {\n      console.log('undefined');\n    } else if (object === null) {\n      console.log('null');\n    } else {\n      let tagName;\n      if (typeof object.tagName !== 'undefined') {\n        tagName = object.tagName.toLowerCase();\n      } else {\n        tagName = 'object';\n      }\n      let output = `<${tagName}`;\n      if (typeof object.attributes !== 'undefined') {\n        for (let i = 0; i < object.attributes.length; i++) {\n          output += ` ${object.attributes[i].name}=\"${object.attributes[i].value}\"`;\n        }\n      }\n      output += '>';\n      if (typeof object.innerHTML !== 'undefined') {\n        output += object.innerHTML;\n      }\n      console.log(output);\n    }\n  };\n}",
    term: "console.dirxml",
    explain:
      '\n\n// This code is a polyfill for the console.dirxml() method. \n// It checks if the method has been defined, and if not defines it. \n// Line 1: Check if the console.dirxml() method exists.\n// Lines 2-17: If the method does not exist, define it to take an object as an argument.\n// Line 3: If the argument is undefined, print "undefined" to the console.\n// Line 4: If the argument is null, print "null" to the console.\n// Lines 5-7: Get the tag name of the object, or default to "object" if it does not have a tag name.\n// Lines 8-11: Create a string of the object\'s tag name, and any attributes it has.\n// Lines 12-15: If the object has inner HTML, append it to the string.\n// Line 16: Log the string to the console.',
    useCase:
      "\n\nConsole.dirxml is used in JavaScript to display an XML/HTML representation of an object. This can be useful for debugging and inspecting the structure of an object. It can help developers to quickly identify the HTML element structure of an object, as well as any associated attributes and values.",
  },
  {
    code: "\n\nif (!console.error) {\n  console.error = (message) => {\n    throw new Error(message);\n  }\n}",
    term: "console.error",
    explain:
      "\n\n// Line 1: This line checks to see if the console.error property does not exist.\n// Line 2: If the console.error property does not exist, this line creates a new function that takes in a message parameter and throws a new error with the message.",
    useCase:
      "\n\nConsole.error is used in Javascript to output an error message. It also highlights the error message in red, which helps to draw attention to the message and make it easier for the user to identify. This is useful for debugging purposes as it helps the user to quickly identify and troubleshoot errors.",
  },
  {
    code: "\n\nif (!window.console) {\n  window.console = {};\n}\nif (!window.console.exception) {\n  window.console.exception = function(error) {\n    if (typeof error === 'string') {\n      console.log('Exception: ' + error);\n    } else if (error instanceof Error) {\n      console.log('Exception: ' + error.name + ': ' + error.message);\n    } else {\n      console.log('Exception: ' + error);\n    }\n  };\n}",
    term: "console.exception",
    explain:
      "\n\n// If window.console does not exist, create it\n// This is done in case window.console is undefined, meaning that the console object does not exist\n\n// If window.console.exception does not exist, create it\n// This is done to create a function that will be used to log exception messages\n\n// If the error variable passed into the function is a string, log a string saying 'Exception: ' + the error message\n// This is done to log a string that conveys that the message is an exception\n\n// If the error variable passed into the function is an instance of the Error object, log a string saying 'Exception: ' + the error name + ': ' + the error message\n// This is done to log a string that conveys that the message is an exception, as well as provide more detail about the type of error\n\n// Otherwise, log a string saying 'Exception: ' + the error\n// This is done to log a string that conveys that the message is an exception, without providing more detail about the type of error",
    useCase:
      "\n\nConsole.exception is used in Javascript to log an error to the console and display a stack trace for the error. It can be useful for debugging as it provides useful information about the error and its origin. This can help developers identify and fix the issue more quickly.",
  },
  {
    code: '\n\nif (!console.group) {\n  console.group = (groupName) => {\n    console.log(`%c ${groupName} `, "color: green; font-size: large");\n  };\n}',
    term: "console.group",
    explain:
      '\n\n// This line checks if the console.group method is available in the current environment. If it is not available then the code block below will execute.\nif (!console.group) {\n\n// This line creates a function that takes in a groupName argument.\n  console.log = (groupName) => {\n\n// This line prints the groupName argument in green color and large font size to the console.\n    console.log(`%c ${groupName} `, "color: green; font-size: large");\n  };\n}',
    useCase:
      "\n\nConsole.group is used in Javascript to create a visual grouping in the console output. This allows developers to organize and distinguish the log messages, making it easier to read and debug code. It also helps to keep the console output tidy, which is important when debugging complex scripts.",
  },
  {
    code: '\n\nif(!window.console.groupCollapsed) {\n  window.console.groupCollapsed = function (name) {\n    console.log("%c "+name, "color: gray; font-weight: lighter;");\n  };\n}',
    term: "console.groupCollapsed",
    explain:
      '\n\n// This code checks if the method "groupCollapsed" on the "console" object of the "window" object is not defined.\n// If it is not defined, this code defines the method "groupCollapsed" on the "console" object of the "window" object.\n// The method "groupCollapsed" takes a parameter called "name" and prints it in the console log with a gray color and font-weight lighter.',
    useCase:
      "\n\nConsole.groupCollapsed is used in Javascript to provide a way to group multiple console log messages together in a collapsed group, making it easier to read and analyze the output. This allows the user to quickly expand and collapse the group to view the information they need without having to scroll through a potentially long list of individual log messages. Additionally, using console.groupCollapsed can help declutter the console output and make it easier to identify related messages.",
  },
  {
    code: '\n\n//polyfill for console.groupEnd\nif (!console.groupEnd) {\n    console.groupEnd = function () {\n        if (console.groupCollapsed) {\n            console.groupCollapsed("End of group");\n        }\n        console.log("End of group");\n    }\n}',
    term: "console.groupEnd",
    explain:
      '\n\n//This code is a polyfill for the console.groupEnd function. This function is used to end a console.group that was started by the console.group function. \n//If the console.groupEnd function is not available, this code creates a polyfill so that the group can be ended.\n//Line 1: This line checks if the console.groupEnd function is available.\n//Line 2: If the console.groupEnd function is not available, this code creates a polyfill.\n//Line 3: This line checks if the console.groupCollapsed function is available. \n//Line 4: If the console.groupCollapsed function is available, this code will end the group with the message "End of group".\n//Line 5: This line will log the message "End of group" to the console.',
    useCase:
      "\n\nConsole.groupEnd is used in JavaScript to close a previously opened console.group. It is used to visually group messages and allow developers to easily track messages printed to the console. This can be helpful for debugging code, or for organizing messages in the console.",
  },
  {
    code: "\n\nif (!console.info) {\n  console.info = function() {\n    console.log.apply(console, arguments);\n  };\n}",
    term: "console.info",
    explain:
      "\n\n// This line checks if the console.info function does not exist.\n// If it does not exist, this line will create a new function called console.info.\n// This function will invoke the console.log function and pass in the arguments that are passed in to console.info.",
    useCase:
      "\n\nConsole.info is used in JavaScript to provide information to developers. It is commonly used to provide helpful information such as errors, warnings, and other debugging messages. It can also be used to provide important information such as the value of a particular variable or the result of a function call. Console.info is an essential tool for developers to debug their code and understand the behavior of their programs.",
  },
  {
    code: "\n\nif (!window.console) window.console = {};\nif (!window.console.log) window.console.log = function (str) {\n  window.alert(str);\n};",
    term: "console.log",
    explain:
      "\n\n// Line 1: This line checks to see if the window does not have a console property. If it does not, then it creates the console property on the window and assigns it an empty object.\n// Line 2: This line checks to see if the window.console object does not have a log function. If it does not, then it creates the log function on the window.console object and assigns it a function that takes in a string as an argument and then alerts that string when called.",
    useCase:
      "\n\nConsole.log is used in Javascript to display information in the browser console. It is often used to log information such as errors, warnings, and debug messages that can be used to help troubleshoot and debug code. It can also be used to log values of variables and other data to better understand the state of the application.",
  },
  {
    code: "\n\n(function() {\n  // Check if the browser supports console.markTimeline\n  if (!console.markTimeline) {\n    // Add console.markTimeline if it does not exist\n    console.markTimeline = function(label) {\n      // Create a console.timeStamp if it exists\n      if (console.timeStamp) {\n        console.timeStamp(label);\n      } else {\n        // Fallback to logging the label\n        console.log(label);\n      }\n    };\n  }\n})();",
    term: "console.markTimeline",
    explain:
      "\n\n// This line creates an anonymous function that runs immediately.\n(function() { \n\n// This line checks if the browser supports the console.markTimeline function.\nif (!console.markTimeline) { \n\n// If the browser does not support it, this line adds the console.markTimeline function.\nconsole.markTimeline = function(label) { \n\n// This line checks if the browser supports the console.timeStamp function.\nif (console.timeStamp) {\n\n// If the browser does support it, this line creates a console.timeStamp.\nconsole.timeStamp(label); \n\n// This line is a fallback for when the browser does not support the console.timeStamp function.\n} else { \n\n// This line logs the label if the fallback is used.\nconsole.log(label); \n\n// This line closes the if statement.\n} \n\n// This line closes the console.markTimeline function.\n}; \n\n// This line closes the if statement.\n} \n\n// This line closes the anonymous function.\n})();",
    useCase:
      "\n\nConsole.markTimeline is used in JavaScript to create a timeline marker that can be used to measure the performance of the code. It can be used to track the performance of code over time, providing an easy way for developers to identify any potential performance issues. This can be especially useful for debugging complex code and large applications.",
  },
  {
    code: "\n\nwindow.console.profile = function() {\n  let startTime = performance.now(); \n  console.log(`Profile started at ${startTime}`);\n  return {\n    end: function() {\n      let endTime = performance.now();\n      console.log(`Profile ended at ${endTime}. Total time: ${endTime - startTime}`);\n    }\n  };\n};",
    term: "console.profile",
    explain:
      "\n\n// Line 1: Assigns a function to the console.profile property of the window object. This function is used to measure the time it takes to execute a given code block.\n\n// Line 2: Stores the current time in milliseconds in the startTime variable, using the performance.now() method.\n\n// Line 3: Logs a message to the console with the value of the startTime variable.\n\n// Line 4: Returns an object with an end method.\n\n// Line 5: Stores the current time in milliseconds in the endTime variable, using the performance.now() method.\n\n// Line 6: Logs a message to the console with the value of the endTime variable and the total time taken to execute the code block.",
    useCase:
      "\n\nConsole.profile is used to help identify and debug performance issues in Javascript code. It allows developers to measure the performance of their code by starting and stopping a timer within their code, and then recording the performance data to the console. This data can then be used to identify areas of code that are not performing optimally, and make adjustments to improve performance.",
  },
  {
    code: "\n\nif (! console.profileEnd) {\n  console.profileEnd = function() {\n    let profiles = console.profiles;\n    let profile = profiles.filter(function(p) {\n      return p.type === 'profileEnd';\n    });\n    if (profile.length > 0) {\n      let profileEnd = profile[0];\n      let profileName = profileEnd.name;\n      let profileStartIndex = -1;\n      for (let i = 0; i < profiles.length; i++) {\n        let p = profiles[i];\n        if (p.name === profileName && p.type === 'profileStart') {\n          profileStartIndex = i;\n          break;\n        }\n      }\n      if (profileStartIndex > -1) {\n        let profileStart = profiles[profileStartIndex];\n        let diff = profileEnd.time - profileStart.time;\n        let log = `${profileName} : ${diff.toFixed(2)}ms`;\n        console.log(log);\n        profiles.splice(profileStartIndex, 2);\n      }\n    }\n  };\n};",
    term: "console.profileEnd",
    explain:
      "\n\n//This code checks to see if the console.profileEnd function is defined. If it is not defined, it creates a function to be used when the function is called. \n\n//if (! console.profileEnd): Checks to see if the console.profileEnd function is defined. \n//console.profileEnd = function(): Defines the console.profileEnd function. \n//let profiles = console.profiles: Creates a variable called profiles and assigns it to the console.profiles array. \n//let profile = profiles.filter(function(p) {Returns a new array with all elements that pass the test implemented by the provided function.\n//return p.type === 'profileEnd': Checks to see if the type of the profile is equal to 'profileEnd'. \n//if (profile.length > 0): Checks to see if the length of the profile array is more than 0. \n//let profileEnd = profile[0]: Creates a variable called profileEnd and assigns it to the first element of the profile array. \n//let profileName = profileEnd.name: Creates a variable called profileName and assigns it to the name property of the profileEnd variable. \n//let profileStartIndex = -1: Creates a variable called profileStartIndex and assigns it the value -1. \n//for (let i = 0; i < profiles.length; i++): Iterates through the profiles array. \n//let p = profiles[i]: Creates a variable called p and assigns it to the current element in the profiles array. \n//if (p.name === profileName && p.type === 'profileStart'): Checks to see if the name of the profile is equal to the profileName variable and if the type of the profile is equal to 'profileStart'. \n//profileStartIndex = i: Assigns the value of i to the profileStartIndex variable. \n//let profileStart = profiles[profileStartIndex]: Creates a variable called profileStart and assigns it to the element of the profiles array at the index of the profileStartIndex variable. \n//let diff = profileEnd.time - profileStart.time: Creates a variable called diff and assigns it to the difference between the time property of the profileEnd variable and the time property of the profileStart variable. \n//let log = `${profileName} : ${diff.toFixed(2)}ms`: Creates a variable called log and assigns it a string containing the profileName variable and the diff variable with 2 decimal places. \n//console.log(log): Logs the log variable to the console. \n//profiles.splice(profileStartIndex, 2): Removes two elements, starting at the profileStartIndex, from the profiles array.",
    useCase:
      "\n\nConsole.profileEnd is used in JavaScript to end the profiling session that was started with console.profile. Profiling is used to find out where most of the time is being spent in the code, and to help identify potential areas of optimization. It can be used to help identify bottlenecks and long-running functions.",
  },
  {
    code: "\n\nif (!console.profiles) {\n    console.profiles = function(name) {\n        if(!name) name = 'Profile'\n        console.time(name);\n    }\n    console.profilesEnd = function(name) {\n        if(!name) name = 'Profile'\n        console.timeEnd(name);\n    }\n}",
    term: "console.profiles",
    explain:
      "\n\n// Line 1: This line checks if the console object does not have a 'profiles' property.\n// Line 2: If the console object does not have a 'profiles' property, a new function is added. This function takes in one parameter, 'name'.\n// Line 3: If 'name' is not provided, the default value of 'Profile' is assigned to 'name'.\n// Line 4: The console.time function is invoked with 'name' as the argument.\n// Line 5: A new function is added to the console object, called 'profilesEnd'. This function also takes in one parameter, 'name'.\n// Line 6: If 'name' is not provided, the default value of 'Profile' is assigned to 'name'.\n// Line 7: The console.timeEnd function is invoked with 'name' as the argument.",
    useCase:
      "\n\nConsole.profiles is used in Javascript to profile the performance of code running in the browser. It enables developers to identify areas of code that are taking the longest to execute, allowing them to optimize their code and improve the overall performance of their application.",
  },
  {
    code: "\n//(Note: Not tested)\n\nif (!console.table) {\n    console.table = function(tableData) {\n        let table = document.createElement('table');\n        let thead = document.createElement('thead');\n        let tbody = document.createElement('tbody');\n \n        tableData.forEach(function(row) {\n            let tr = document.createElement('tr');\n            Object.keys(row).forEach(function(key) {\n                let th = document.createElement('th');\n                let td = document.createElement('td');\n                th.innerHTML = key;\n                td.innerHTML = row[key];\n                tr.appendChild(th);\n                tr.appendChild(td);\n            });\n            tbody.appendChild(tr);\n        });\n \n        table.appendChild(thead);\n        table.appendChild(tbody);\n \n        document.body.appendChild(table);\n    };\n}",
    term: "console.table",
    explain:
      "\n\n// Line 1: \n// If the console.table function does not already exist, run the code below. \n\n// Line 2: \n// Create a console.table function that takes a parameter of tableData. \n\n// Line 3-4: \n// Create the table, thead and tbody tags, and store them in respective variables. \n\n// Line 5-12: \n// For each row in tableData, create a tr tag, then loop through each key in the row and create th and td tags, with the th tag containing the key and the td tag containing the row[key]. Append the th and td tags to the tr tag and the tr tag to the tbody tag. \n\n// Line 13-15: \n// Append the thead and tbody tags to the table tag and the table tag to the body tag.",
    useCase:
      "\n\nConsole.table is used in Javascript to display tabular data in a concise, readable format. It is useful for quickly viewing data in a structured format, as it is easier to read than other formats such as JSON. Console.table can also be used to quickly debug code and view values that are stored in variables.",
  },
  {
    code: '\n\n(function () {\n    if (!window.console) {\n        window.console = {\n            time: function (name) {\n                this._timers = this._timers || {};\n                this._timers[name] = new Date().getTime();\n            },\n            timeEnd: function (name) {\n                this._timers = this._timers || {};\n                if (this._timers[name]) {\n                    var elapsed = new Date().getTime() - this._timers[name];\n                    console.log(name + ": " + elapsed + "ms");\n                    delete this._timers[name];\n                }\n            }\n        };\n    }\n})();',
    term: "console.time",
    explain:
      "\n\n// Line 1: \n// This line creates an anonymous function and immediately invokes it.\n\n// Line 2:\n// This line checks if a console object exists in the window object. If not, it will assign a new object to the window object.\n\n// Line 3:\n// This line adds a new time function to the console object. This function takes a name argument, stores the current time in a _timers object and stores it with the given name.\n\n// Line 4: \n// This line adds a new timeEnd function to the console object. This function takes a name argument, checks if the given name exists in the _timers object, calculates the elapsed time since the time function was invoked, logs the elapsed time and deletes the entry from the _timers object.",
    useCase:
      "\n\nConsole.time is used in JavaScript to measure the amount of time it takes for a specific code snippet or function to execute. It is useful for identifying performance issues and optimizing code. It works by recording the time it takes to start and finish a given code snippet or function and then displays the result in the console.",
  },
  {
    code: '\n\nconst console = {\n  times: {},\n  time: function(label) {\n    console.times[label] = new Date();\n  },\n  timeEnd: function(label) {\n    const timeStart = console.times[label];\n    if (timeStart) {\n        const timeEnd = new Date();\n        const timeDiff = timeEnd.getTime() - timeStart.getTime();\n        console.log(label + ": " + timeDiff + "ms");\n        delete console.times[label];\n    } else {\n        console.log(label + ": No such label");\n    }\n  }\n};',
    term: "console.timeEnd",
    explain:
      '\n\n//1. const console = {};\n//This line declares a constant variable named console that holds an object.\n\n//2. times: {},\n//This line adds a property called times to the console object and sets it to an empty object.\n\n//3. time: function(label) {\n//This line adds a method called time to the console object. This method takes a parameter called label. \n\n//4. console.times[label] = new Date();\n//This line sets a property of the times object of console to a new Date object. The property name is the value of the label parameter.\n\n//5. timeEnd: function(label) {\n//This line adds a method called timeEnd to the console object. This method takes a parameter called label.\n\n//6. const timeStart = console.times[label];\n//This line declares a constant variable named timeStart and sets it to the value of the property of the times object of console with the name of the value of the label parameter.\n\n//7. if (timeStart) {\n//This line checks if the timeStart variable is truthy.\n\n//8. const timeEnd = new Date();\n//This line declares a constant variable named timeEnd and sets it to a new Date object.\n\n//9. const timeDiff = timeEnd.getTime() - timeStart.getTime();\n//This line declares a constant variable named timeDiff and sets it to the difference of the getTime of the timeEnd and timeStart variables.\n\n//10. console.log(label + ": " + timeDiff + "ms");\n//This line logs the value of the label parameter, a colon, a space, the timeDiff variable and the string "ms" to the console.\n\n//11. delete console.times[label];\n//This line deletes the property of the times object of console with the name of the value of the label parameter.\n\n//12. } else {\n//This line is the else part of the if statement in line 7.\n\n//13. console.log(label + ": No such label");\n//This line logs the value of the label parameter, a colon, a space and the string "No such label" to the console.\n\n//14. }\n//This line closes the timeEnd method.',
    useCase:
      "\n\nConsole.timeEnd is used in Javascript to measure the amount of time that has passed between console.time and console.timeEnd. This can be used to measure the performance of a certain piece of code or the amount of time taken to complete a specific task.",
  },
  {
    code: "\n\nif (typeof console.timeStamp !== 'function') {\n    console.timeStamp = function(name) {\n        let time = new Date();\n        name ? console.log(name + ': ' + time) : console.log('TimeStamp: ' + time);\n    }\n}",
    term: "console.timeStamp",
    explain:
      "\n\n// This code checks to see if the function timeStamp exists in the console. If it does not, it will define the function. \n// Line 1: Checks to see if the type of console.timeStamp is a function\n// Line 2: If the statement is true, then run the code inside the curly braces\n// Line 3: Create a variable called time and store the current date and time in it\n// Line 4: If the parameter name is given, log the name and the time stored in the variable time. Else, log the string 'TimeStamp' and the time stored in the variable time\n// Line 5: Close the if statement",
    useCase:
      "\n\nConsole.timeStamp is used in Javascript to measure the performance of a given code block or function. It allows developers to track the time spent in executing a particular block of code. This can be helpful for debugging and performance optimization.",
  },
  {
    code: "\n\nif (!console.timeline) {\n  console.timeline = function(name) {\n    console.time(name);\n  };\n\n  console.timelineEnd = function(name) {\n    console.timeEnd(name);\n  };\n}",
    term: "console.timeline",
    explain:
      "\n\n// Line 1: This line checks whether the console object has a property named timeline. If this is not the case, the code within the if statement will be executed.\n// Line 2: This line creates a new function named timeline on the console object if it does not already exist. The function takes in a parameter named name.\n// Line 3: This line creates a new function named timelineEnd on the console object if it does not already exist. The function takes in a parameter named name.\n// Line 4: This line closes the if statement.",
    useCase:
      "\n\nConsole.timeline is used in Javascript to measure the amount of time that it takes for a specific task to be completed. It can be used to track performance and identify areas of code that can be improved. It is especially useful for debugging and optimizing code.",
  },
  {
    code: "\n\n// define function to polyfill console.timelineEnd\nfunction timelineEnd() { \n  if (typeof console.timeStamp === 'function') {\n    console.timeStamp('timelineEnd');\n  } else {\n    console.log('timelineEnd');\n  }\n}",
    term: "console.timelineEnd",
    explain:
      "\n\n// This line defines a function named timelineEnd which will be used to polyfill the console.timelineEnd functionality. \n\nif (typeof console.timeStamp === 'function') { \n  // This line checks if the function console.timeStamp exists, and if it does, execute the following statement.\n\nconsole.timeStamp('timelineEnd');\n  // This line uses the console.timeStamp function to log the message 'timelineEnd' to the console.\n\n} else {\n  // If the console.timeStamp function does not exist, execute the following statement.\n\nconsole.log('timelineEnd');\n  // This line logs the message 'timelineEnd' to the console using the console.log function.\n\n}\n  // This line closes the else statement.",
    useCase:
      "\n\nconsole.timelineEnd is used to create a timeline marker in the console that can be used to measure the performance of a given JavaScript operation. It will measure the time difference between the timelineStart() and timelineEnd() calls, providing developers with more detailed information on the performance of their code. It can also be used to measure the duration between two different events. This can be useful for debugging, as it provides a way to measure how long a particular operation is taking.",
  },
  {
    code: '\n\n(function() {\n    if (!window.console) window.console = {};\n    if (!window.console.trace) {\n        window.console.trace = function() {\n            try {\n                throw new Error("console.trace was called");\n            }\n            catch(e) {\n                console.error(e.stack);\n            }\n        };\n    }\n})();',
    term: "console.trace",
    explain:
      '\n\n1. (function() { //This line creates an anonymous function which is immediately invoked.\n\n2. if (!window.console) window.console = {}; //This line checks if the console object is present in the window object. If not, it sets an empty object as the console object.\n\n3. if (!window.console.trace) { //This line checks if the trace method is present in the console object.\n\n4. window.console.trace = function() { //If the trace method is not present, this line assigns an anonymous function to the trace method.\n\n5. try { //This line starts a try-catch block.\n\n6. throw new Error("console.trace was called"); //This line throws an Error with a message indicating that the trace method was called.\n\n7. } catch(e) { //This line catches the Error thrown in the try block.\n\n8. console.error(e.stack); //This line prints the stack trace associated with the Error.\n\n9. } //This line closes the try-catch block.\n\n10. } //This line closes the anonymous function assigned to the trace method.\n\n11. })(); //This line immediately invokes the anonymous function defined in the first line.',
    useCase:
      "\n\nConsole.trace is used to trace the execution path of a function. This can be useful for debugging complex code, as it provides a detailed view of what the code is doing. It can help to identify any unexpected or incorrect behavior, and help to identify the root cause of any issues.",
  },
  {
    code: '\n\nif (!console.warn) {\n  console.warn = function(warning) {\n    console.log("Warning: " + warning);\n  };\n}',
    term: "console.warn",
    explain:
      '\n\n// Line 1: If the console object does not have a method called warn,\n// Line 2: create a new method called warn as a function that takes in a warning as an argument \n// Line 3: Log the string "Warning: " followed by the argument provided to the function',
    useCase:
      "\n\nConsole.warn is used in JavaScript for outputting a warning message to the browser console. It is a good practice to use console.warn when there is an issue with the code that needs to be addressed, as it will draw the attention of the developer who is working on the code. It also helps to differentiate warnings from other types of console messages, making it easier to identify and fix any potential issues.",
  },
  {
    code: '\n\n"use strict";\n\n// devicePixelRatio polyfill\nlet devicePixelRatio;\n\nif (window.devicePixelRatio !== undefined) {\n\tdevicePixelRatio = window.devicePixelRatio;\n} else {\n\t// Use a default value of 1.\n\tdevicePixelRatio = 1;\n}',
    term: "devicePixelRatio",
    explain:
      '\n\n// this line turns on strict mode which makes debugging easier and prevents mistakes \n"use strict";\n\n// this line declares a variable devicePixelRatio \nlet devicePixelRatio;\n\n// this line checks if window.devicePixelRatio is undefined, if it is then it sets devicePixelRatio to 1\nif (window.devicePixelRatio !== undefined) {\n\tdevicePixelRatio = window.devicePixelRatio;\n} else {\n\t// Use a default value of 1.\n\tdevicePixelRatio = 1;\n}',
    useCase:
      "\n\nDevicePixelRatio is used in Javascript to determine the pixel density of a device's screen. This information is useful for determining the size of elements and images on a page, as well as for determining the size of images that should be used for optimal display on a device. Additionally, DevicePixelRatio can be used to detect HiDPI or Retina displays, which have higher pixel densities and require higher resolution images.",
  },
  {
    code: "\n\nif (typeof document === \"undefined\") {\n  document = {\n    querySelector: function(selector) {\n      const elements = this.querySelectorAll(selector);\n      return elements[0] || null;\n    },\n    querySelectorAll: function(selector) {\n      return [];\n    },\n    createElement: function(type) {\n      return {\n        type: type,\n        innerHTML: ''\n      }\n    },\n    addEventListener: function() {},\n    removeEventListener: function() {}\n  };\n}",
    term: "document",
    explain:
      "\n\n// This code is used to provide a basic Document object if one does not exist.\n\n// Line 1:\n// If a document object is not defined, execute the following code. \n\n// Lines 2-15:\n// Create a document object with querySelector, querySelectorAll, createElement, addEventListener, and removeEventListener functions. This is so that code can be written without worrying about if a document object is available or not.",
    useCase:
      "\n\nDocument is used in JavaScript to access and manipulate HTML and XML documents. It can be used to create dynamic webpages and to access elements within the page. It can also be used to access and manipulate CSS stylesheets, to create animations, and to control multimedia elements such as audio and video. Additionally, it can be used to manipulate the browser's history, to access cookies and to respond to user events such as mouse clicks and key presses.",
  },
  {
    code: "\n\n(function() {\n\tvar scripts = document.getElementsByTagName('script');\n\tdocument.currentScript = scripts[scripts.length - 1];\n})();",
    term: "document.currentScript",
    explain:
      "\n\n1. (function() { // This is an immediately invoked function expression (IIFE). This code will be ran as soon as it is encountered by the browser.\n\n2. \tvar scripts = document.getElementsByTagName('script'); // This line creates a variable called scripts and assigns it to all script elements in the document.\n\n3. \tdocument.currentScript = scripts[scripts.length - 1]; // This line assigns the last element in the scripts array to the document's currentScript property. This will allow us to access the currently running script in the document.",
    useCase:
      "\n\nDocument.currentScript is used in JavaScript to get a reference to the current script element that is currently being processed. This can be used to access properties of the script element and the script's contents, such as the script's src attribute or the script's text content. It can also be used to determine the script's execution context, which can be useful for debugging purposes.",
  },
  {
    code: "\n\n// Polyfill for document.elementsFromPoint\nif (!document.elementsFromPoint) {\n  document.elementsFromPoint = (x, y) => {\n    const elements = [];\n    let element;\n    let previousScrollX = window.scrollX;\n    let previousScrollY = window.scrollY;\n    window.scrollTo(x, y);\n    do {\n      element = document.elementFromPoint(x, y);\n      if (element) {\n        elements.push(element);\n        window.scrollBy(0, -1);\n      }\n    } while (element);\n    window.scrollTo(previousScrollX, previousScrollY);\n    return elements;\n  };\n}",
    term: "document.elementsFromPoint",
    explain:
      "\n\n//This code is a polyfill for the document.elementsFromPoint method. \n//Line 1: If the document.elementsFromPoint method is not available, this code will execute. \n//Line 2: The document.elementsFromPoint method takes two parameters, x and y coordinate. \n//Line 3: An empty array is declared to store the elements that are found. \n//Line 4: A variable called “element” is declared to store the element obtained from the point. \n//Line 5-6: The variables “previousScrollX” and “previousScrollY” are declared to store the current scroll position. \n//Line 7: The window is scrolled to the point specified by the x and y coordinates. \n//Line 8-13: A “do-while” loop is used to obtain all the elements from the point. The element obtained is then stored in the “element” variable. If an element is found, it is added to the elements array. The window is then scrolled by -1 in the y-axis. \n//Line 14: The window is scrolled back to its original position using the stored “previousScrollX” and “previousScrollY” variables. \n//Line 15: The elements array is returned.",
    useCase:
      "\n\nDocument.elementsFromPoint is used in Javascript to return the elements that are visible within a certain point in the document. This can be useful for determining which element is located at a certain point on the page. For example, it could be used to determine which element is located at the coordinates of a mouse click event.",
  },
  {
    code: "\n\nif (!document.getElementsByClassName) {\n    document.getElementsByClassName = function (className) {\n        let allElements = document.getElementsByTagName('*');\n        let elementsName = [];\n        for (let i = 0; i < allElements.length; i++) {\n            if (allElements[i].className === className) {\n                elementsName.push(allElements[i]);\n            }\n        }\n        return elementsName;\n    }\n}",
    term: "document.getElementsByClassName",
    explain:
      "\n\n// Line 1: Check if the document object does not have a getElementsByClassName method.\n// Line 2: If it does not have the method, assign a new function to it.\n// Line 3: Create an array to store all the elements with the class name.\n// Line 4: Loop through all the elements in the document.\n// Line 5: Check if the current element has the same class name as the one passed in.\n// Line 6: If it does, push the current element into the elementsName array.\n// Line 7: Return the elementsName array.",
    useCase:
      "\n\nDocument.getElementsByClassName is used in JavaScript to access and manipulate a collection of elements with a specific class name. It is used to find all elements in the document with the specified class name, as a static NodeList object. This allows developers to easily select and manipulate a group of elements on a page.",
  },
  {
    code: '\n\nif (typeof document.head === "undefined") {\n  document.head = document.getElementsByTagName("head")[0] || document.createElement("head");\n  document.head.parentNode.insertBefore(document.head, document.head.parentNode.firstChild);\n}',
    term: "document.head",
    explain:
      "\n\n// Line 1: This line checks to see if the document.head object exists. \n// Line 2: If document.head does not exist, it will create a new head element and insert it as the first child of the parent node.",
    useCase:
      "\n\nDocument.head is used in Javascript to access and modify the head element of the current document. It is useful for adding, removing, and modifying elements within the document, such as scripts, links, and meta tags. It is also useful for accessing important information such as the document's title, charset, and other meta tags.",
  },
  {
    code: "\n\n//function for querySelector\nfunction querySelector(selector) {\n  let elements;\n\n  //check for id\n  if(selector.charAt(0) === '#') {\n    elements = document.getElementById(selector.substring(1));\n  }\n  //check for class\n  else if(selector.charAt(0) === '.') {\n    elements = document.getElementsByClassName(selector.substring(1));\n  }\n  //otherwise, assume tag name\n  else {\n    elements = document.getElementsByTagName(selector);\n  }\n\n  //return single element or array of elements\n  if(elements.length === 1) {\n    return elements[0];\n  } else {\n    return elements;\n  }\n}",
    term: "document.querySelector",
    explain:
      "\n\n//Line 1: This declares a function called querySelector that takes in an argument of 'selector'. \n//Line 2: This declares a variable called 'elements' which we will assign a value to later. \n//Line 3: This checks to see if the first character of the selector argument is a '#' symbol. If it is, it will assign the elements variable to the result of the getElementById function, using the selector argument minus the '#' as the argument to the function.\n//Line 6: This checks to see if the first character of the selector argument is a '.' symbol. If it is, it will assign the elements variable to the result of the getElementsByClassName function, using the selector argument minus the '.' as the argument to the function.\n//Line 9: This checks to see if none of the above conditions are true, and assumes the selector argument is a tag name. It will assign the elements variable to the result of the getElementsByTagName function, using the selector argument as the argument to the function. \n//Line 12: This checks to see if the length of the elements variable is equal to 1. If it is, it will return the first element of the elements array. \n//Line 13: This is the else statement for the above if statement. If the length of the elements variable is not equal to 1, it will return the entire elements array.",
    useCase:
      "\n\nDocument.querySelector is used in JavaScript to select and return the first element that matches a specified CSS selector or group of selectors. It is a powerful tool for accessing and manipulating elements on a page. This method is often used to select and modify elements in a page without having to traverse the page's DOM tree.",
  },
  {
    code: "\n\nif (!document.visibilityState) {\n\tObject.defineProperty(document, 'visibilityState', {\n\t\tget: function() {\n\t\t\tvar visibility;\n\t\t\tif (document.webkitVisibilityState) {\n\t\t\t\tvisibility = document.webkitVisibilityState;\n\t\t\t} else if (document.mozVisibilityState) {\n\t\t\t\tvisibility = document.mozVisibilityState;\n\t\t\t} else if (document.msVisibilityState) {\n\t\t\t\tvisibility = document.msVisibilityState;\n\t\t\t} else if (document.oVisibilityState) {\n\t\t\t\tvisibility = document.oVisibilityState;\n\t\t\t}\n\t\t\treturn visibility;\n\t\t}\n\t});\n}",
    term: "document.visibilityState",
    explain:
      "\n\n// Line 1: Checks if the document.visibilityState property exists on the document object. \n// Line 2: If it doesn't exist, define it with the help of the Object.defineProperty() method.\n// Line 3-9: The getter property of the defineProperty() method to set the visibilityState property.\n// This method checks for the different browser implementations of the visibilityState property, \n// and sets it accordingly. \n// Line 10: Close the if statement.",
    useCase:
      "\n\nDocument.visibilityState is used in JavaScript to determine the current visibility state of a document. It is used to detect if a document is visible or hidden in the browser. This can be used to pause or stop certain activities when a document is hidden, such as playing videos or refreshing content. Additionally, it can be used to detect if a user has switched away from a tab or window. Knowing the visibility state can help to create a more user-friendly experience by allowing developers to optimize the user's experience.",
  },
  {
    code: "\n\nconst myFetch = (url, {\n  method = 'GET',\n  data = {},\n  headers = {}\n}) => {\n  const request = new XMLHttpRequest();\n  const promise = new Promise((resolve, reject) => {\n    request.open(method, url);\n    Object.keys(headers).forEach((key) => {\n      request.setRequestHeader(key, headers[key]);\n    });\n    request.send(JSON.stringify(data));\n    request.onload = () => {\n      const res = JSON.parse(request.response);\n      resolve(res);\n    };\n    request.onerror = () => reject(request.statusText);\n  });\n  return promise;\n};",
    term: "fetch",
    explain:
      "\n\n1. const myFetch = (url, { \n      method = 'GET', \n      data = {}, \n      headers = {} \n    }) => { \n   // this line declares a constant variable named myFetch and assigns a function to it. This function takes two parameters url and an object with 3 properties method, data and headers. The properties method, data and headers are set to default values of GET, an empty object and an empty object respectively. \n\n2. const request = new XMLHttpRequest(); \n// this line declares a constant variable named request and assigns a new instance of XMLHttpRequest to it. \n\n3. const promise = new Promise((resolve, reject) => { \n// this line declares a constant variable named promise and assigns a new instance of Promise to it. The promise constructor takes two parameters - resolve and reject. \n\n4. request.open(method, url); \n// this line calls the open method on the request object and passes the method and url parameters to it. \n\n5. Object.keys(headers).forEach((key) => { \n// this line calls the keys method on the Object object and passes the headers object as parameter. The forEach loop is used to iterate over the keys of the object. \n\n6. request.setRequestHeader(key, headers[key]); \n// this line calls the setRequestHeader method on the request object and passes the key and the corresponding value from the headers object as parameters. \n\n7. request.send(JSON.stringify(data)); \n// this line calls the send method on the request object and passes the data object as parameter. The data object is first converted to a JSON string using the JSON.stringify method. \n\n8. request.onload = () => { \n// this line assigns an anonymous function to the onload property of the request object. \n\n9. const res = JSON.parse(request.response); \n// this line declares a constant variable named res and assigns the result of parsing the response property of the request object. \n\n10. resolve(res); \n// this line calls the resolve method on the promise object and passes the res variable as a parameter. \n\n11. request.onerror = () => reject(request.statusText); \n// this line assigns an anonymous function to the onerror property of the request object. The function calls the reject method on the promise object and passes the statusText property of the request object as a parameter. \n\n12. return promise; \n// this line returns the promise object.",
    useCase:
      "\n\nFetch is used in JavaScript to make asynchronous requests to the server and download data in the background without having to refresh the page. It is a built-in feature of JavaScript, and allows developers to send requests to a server from a client-side JavaScript application. Fetch is a great tool for creating dynamic web applications that can communicate with a server and make changes on the page without the user having to manually refresh the page.",
  },
  {
    code: "\n\nif (typeof window.getComputedStyle !== \"function\") {\n  window.getComputedStyle=function(el, pseudo){\n    this.el = el;\n    this.getPropertyValue=function(prop){\n      var re = /(\\-([a-z]){1})/g;\n      if (prop == 'float') prop = 'styleFloat';\n      if (re.test(prop)) {\n        prop = prop.replace(re, function () {\n          return arguments[2].toUpperCase();\n        });\n      }\n      return el.currentStyle[prop] ? el.currentStyle[prop] : null;\n    }\n    return this;\n  }\n}",
    term: "getComputedStyle",
    explain:
      "\n\n// Line 1: \n// This line checks if the function window.getComputedStyle is a function. If not, it will proceed to the next lines. \n\n// Line 2-5: \n// These lines define the window.getComputedStyle function. The function takes 2 parameters, el and pseudo. \n\n// Line 6-10: \n// These lines define a getPropertyValue function which takes a parameter prop. It checks if the prop is 'float', if it is, it will replace it with 'styleFloat'. It then returns the currentStyle of the prop if it exists, or null otherwise. \n\n// Line 11: \n// This line returns the object with the getPropertyValue function.",
    useCase:
      "\n\nGetComputedStyle is used in Javascript to get the calculated values of an element's style. It provides information about the styling applied to an element, such as font-size, margin, padding, width, height, etc. It can be used to detect the styling of an element at runtime, which can be used to make decisions within a script. This also allows the user to find out how an element is being styled by its parent elements, which is especially useful when debugging code.",
  },
  {
    code: "\n\nlet globalThis;\n\nif (typeof self !== 'undefined') {\n    globalThis = self;\n} else if (typeof window !== 'undefined') {\n    globalThis = window;\n} else if (typeof global !== 'undefined') {\n    globalThis = global;\n} else {\n    globalThis = Function('return this')();\n}",
    term: "globalThis",
    explain:
      "\n\n//This line sets an empty variable called globalThis\nlet globalThis;\n\n//This line checks if the self variable is defined and if it is, set the globalThis variable to equal self\nif (typeof self !== 'undefined') {\n    globalThis = self;\n\n//This line checks if the window variable is defined and if it is, set the globalThis variable to equal window\n} else if (typeof window !== 'undefined') {\n    globalThis = window;\n\n//This line checks if the global variable is defined and if it is, set the globalThis variable to equal global\n} else if (typeof global !== 'undefined') {\n    globalThis = global;\n\n//This line sets the globalThis variable to the Function('return this')();\n} else {\n    globalThis = Function('return this')();\n}",
    useCase:
      "\n\nGlobalThis is a new global variable introduced in the ES2020 JavaScript version. It is used to provide a consistent means of accessing the global object in all environments, no matter the implementation or context. By using GlobalThis, developers can write code that is more robust and portable as it will work in all types of environments, such as Node.js, web browsers, and even iframes. This is especially helpful when trying to create code that is future-proof and can run in any environment.",
  },
  {
    code: '\n\nObject.defineProperty(window, "innerHeight", {\n    get: function () { \n        var docElement = document.documentElement; \n        if (docElement) { \n            return Math.max(\n                docElement.clientHeight, \n                document.body.scrollHeight, \n                document.body.offsetHeight, \n                docElement.scrollHeight, \n                docElement.offsetHeight\n            ); \n        }\n    }\n});',
    term: "innerHeight",
    explain:
      '\n\n//Object.defineProperty(window, "innerHeight", { \n// This line defines a new property called "innerHeight" on the window object.\n\n//    get: function () {\n// This line creates a getter function that will be called when we try to access the innerHeight property.\n\n//        var docElement = document.documentElement; \n// This line creates a variable called docElement that stores the documentElement object from the document.\n\n//        if (docElement) {\n// This line checks if the docElement variable is not undefined or null.\n\n//            return Math.max(\n// This line returns the maximum value of the following parameters.\n\n//                docElement.clientHeight, \n// This parameter returns the height of the viewport.\n\n//                document.body.scrollHeight, \n// This parameter returns the height of the entire document including the scrollable area.\n\n//                document.body.offsetHeight, \n// This parameter returns the height of the entire document, excluding the scrollable area.\n\n//                docElement.scrollHeight, \n// This parameter returns the height of the entire document including the scrollable area.\n\n//                docElement.offsetHeight\n// This parameter returns the height of the entire document excluding the scrollable area.\n\n//            ); \n// This line closes the parameters for the Math.max function.\n\n//        }\n// This line closes the if statement.\n\n//    }\n// This line closes the getter function.\n\n//});\n// This line closes the Object.defineProperty function.',
    useCase:
      "\n\nInnerHeight is used to get the height of a window's content area, or the document's body, or the height of an element. It is useful for determining the size of an element in the browser window and can be used to adjust the size of an element dynamically. It can also be used to determine the size of an element in order to create responsive designs.",
  },
  {
    code: "\n\nObject.defineProperty(window, 'innerWidth', {\n    get: function() {\n        var width;\n        if (document.documentElement.clientWidth) {\n            width = document.documentElement.clientWidth;\n        } else if (document.body.clientWidth) {\n            width = document.body.clientWidth;\n        } else if (window.outerWidth) {\n            width = window.outerWidth;\n        }\n        return width;\n    }\n});",
    term: "innerWidth",
    explain:
      "\n\n//Line 1: This line creates a property on the window object called innerWidth and sets up its getter. \n//Line 2: This line creates a variable called width that will hold the value of the innerWidth.\n//Line 3: This line checks if the document element has a clientWidth property and if it does, the width variable is set to the value of the clientWidth.\n//Line 4: This line checks if the body of the document has a clientWidth property and if it does, the width variable is set to the value of the clientWidth.\n//Line 5: This line checks if the window has an outerWidth property and if it does, the width variable is set to the value of the outerWidth.\n//Line 6: This line returns the value of the width variable.",
    useCase:
      "\n\ninnerWidth is a property of the Window object in JavaScript that allows you to access the width of the browser window. It can be used to make sure that elements are sized appropriately for different window sizes, and also to create responsive designs that look good on any device.",
  },
  {
    code: "\n\nif (window.localStorage === undefined) {\n  window.localStorage = {\n    setItem: function(key, value) {\n      this[key] = value;\n    },\n    getItem: function(key) {\n      return this[key];\n    },\n    removeItem: function(key) {\n      delete this[key];\n    },\n    clear: function() {\n      for (var key in this) {\n        if (this.hasOwnProperty(key)) {\n          delete this[key];\n        }\n      }\n    }\n  };\n}",
    term: "localStorage",
    explain:
      "\n\n// Line 1: This line checks to see if the browser does not have the localStorage feature available. \n// Line 2: If the browser does not have the localStorage feature available, then this line creates a localStorage object with setItem, getItem, removeItem, and clear methods.\n// Line 3: This line creates the setItem method which takes in two parameters, key and value. It sets the key to the value.\n// Line 4: This line creates the getItem method which takes in one parameter, key. It then returns the value of the key.\n// Line 5: This line creates the removeItem method which takes in one parameter, key. It then deletes the key.\n// Line 6: This line creates the clear method which takes in no parameters. It then loops through all the keys and deletes them.",
    useCase:
      "\n\nLocalStorage is used in JavaScript to store data on the client-side in key-value pairs. This data is persistent and doesn't expire, which means it can still be accessed when the user returns to the website. It is used for things such as saving user preferences, storing data for offline access, and creating a more responsive user experience.",
  },
  {
    code: "\n\nif (!window.location.origin) window.location.origin = window.location.protocol + \"//\" + window.location.hostname + (window.location.port ? ':' + window.location.port : '');",
    term: "location.origin",
    explain:
      "\n\nLine 1: This line checks if the origin of the window location is not defined. \n\nLine 2: If the origin of the window location is not defined, it sets the origin to the protocol + hostname + port of the window location. The ternary operator is used to check if there is a port to add to the origin.",
    useCase:
      "\n\nLocation.origin is used in JavaScript to provide the full URL of the current page. This includes the protocol (e.g. http or https), hostname (e.g. www.example.com), and the port number (e.g. :8080). This information is often necessary in order to construct absolute URLs from within the page. For example, when constructing an AJAX request to a server, a full URL must be used in order for the request to reach the correct server. Location.origin provides an easy way to construct such a URL.",
  },
  {
    code: "\n\n// polyfill of matchMedia in Javascript\nif (!window.matchMedia) {\n  window.matchMedia = (query) => {\n    let mql = {\n      matches: false,\n      media: query,\n      addListener: () => {},\n      removeListener: () => {}\n    };\n\n    if (query.substring(0,4) === 'only') {\n      mql.matches = matchQuery(query.substring(4), window.innerWidth, window.innerHeight);\n    } else if (query.substring(0,4) === 'not ') {\n      mql.matches = !matchQuery(query.substring(4), window.innerWidth, window.innerHeight);\n    } else {\n      mql.matches = matchQuery(query, window.innerWidth, window.innerHeight);\n    }\n\n    return mql;\n  }\n}\n\n// Helper function to match media queries\nfunction matchQuery(query, w, h) {\n  const expressions = query.split(/\\sand\\s|\\sor\\s/);\n  let matched = true;\n  expressions.forEach(expression => {\n    let [feature, value] = expression.split(/\\:(.+)/);\n    value = parseInt(value);\n    switch(feature) {\n      case 'min-width':\n        matched = matched && w >= value;\n        break;\n      case 'max-width':\n        matched = matched && w <= value;\n        break;\n      case 'min-height':\n        matched = matched && h >= value;\n        break;\n      case 'max-height':\n        matched = matched && h <= value;\n        break;\n    }\n  });\n  return matched;\n}",
    term: "matchMedia",
    explain:
      "\n\n// Line 1:\n// This line creates a polyfill of matchMedia in Javascript if it doesn't already exist. This is done by checking to see if window.matchMedia is defined.\n\n// Line 2:\n// This line creates an object called mql that contains the keys matches, media, addListener, and removeListener. The matches key is set to false to begin.\n\n// Line 3:\n// This line checks to see if the media query starts with the substring 'only' and sets the matches key of the mql object to the result of the matchQuery function, passing in the substring after 'only' as an argument.\n\n// Line 4:\n// This line checks to see if the media query starts with the substring 'not' and sets the matches key of the mql object to the logical negation of the result of the matchQuery function, passing in the substring after 'not' as an argument.\n\n// Line 5:\n// This line checks to see if the media query does not start with either 'only' or 'not' and sets the matches key of the mql object to the result of the matchQuery function, passing in the media query as an argument.\n\n// Line 6:\n// This line returns the mql object.\n\n// Line 8:\n// This line is the start of the helper function matchQuery, which takes three arguments: query, w, and h.\n\n// Line 9:\n// This line creates an array called expressions, which is created by splitting the query argument on the strings 'and' and 'or'.\n\n// Line 10:\n// This line creates a variable called matched, which is set to true.\n\n// Line 11:\n// This line is a forEach loop that goes through each element in the expressions array.\n\n// Line 12:\n// This line creates two variables called feature and value, which are set to the result of splitting the expression on the string ':'.\n\n// Line 13:\n// This line parses the value variable into an integer.\n\n// Line 14-19:\n// These lines check the feature variable to see which media query it matches and sets the matched variable to the appropriate value.\n\n// Line 20:\n// This line returns the matched variable.",
    useCase:
      "\n\nMatchMedia is used in Javascript to allow web developers to determine the state of a user's device or browser in order to serve them appropriate content or styling. It can be used to detect a user's screen resolution, device orientation, or other information about the device or browser in order to serve the best possible experience to the user. It is used to help design responsive websites, as well as to adjust styling based on the user's device or browser.",
  },
  {
    code: "\n\nif (navigator.geolocation) {\n  navigator.geolocation.getCurrentPosition((position) => {\n    const pos = {\n      lat: position.coords.latitude,\n      lng: position.coords.longitude\n    };\n  });\n} else {\n  const url = 'https://www.googleapis.com/geolocation/v1/geolocate?key=YOUR_API_KEY';\n  const options = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  };\n\n  fetch(url, options).then(res => {\n    return res.json();\n  }).then(data => {\n    const pos = {\n      lat: data.location.lat,\n      lng: data.location.lng\n    }\n  }).catch((err) => {\n    console.error(err);\n  });\n}",
    term: "navigator.geolocation",
    explain:
      "\n\n// Line 1: This line checks to see if the browser used has geolocation available.\n// Line 2: If geolocation is available, this line gets the current position of the user.\n// Line 4: This line stores the latitude and longitude of the user in a constant named pos.\n// Line 6: If geolocation is not available, this line stores the URL of the Google Geolocation API in a constant named url.\n// Line 8: This line stores the options for the fetch request in a constant named options.\n// Line 11-15: This block of code sends a POST request to the Google Geolocation API, converts the response to JSON, stores the latitude and longitude of the user in a constant named pos, and logs any errors.",
    useCase:
      "\n\nNavigator.geolocation is used in Javascript to determine the geographical location of a user. This is done using the Global Positioning System (GPS) to get the user's latitude, longitude, and altitude. This information can be used to provide location-based services such as mapping, local search, and navigation. It can also be used to customize web content based on the user's location.",
  },
  {
    code: "\n\nif (!navigator.sendBeacon) {\n  navigator.sendBeacon = function(url, data) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('POST', url);\n    xhr.setRequestHeader('Accept', '*/*');\n    xhr.withCredentials = true;\n    xhr.send(data);\n  };\n}",
    term: "navigator.sendBeacon",
    explain:
      "\n\n// This code checks to see if the navigator has the method sendBeacon.\n// If it does not, it creates a function called sendBeacon with two parameters, url and data. \n// It then creates a new XMLHttpRequest object, sets the request type to POST and the Accept header to '*/*'. \n// It also sets the withCredentials property to true and sends the data.",
    useCase:
      "\n\nNavigator.sendBeacon is used in Javascript to asynchronously transfer small amounts of data from the client to the server. It is useful for sending data that doesn't require a response from the server, such as analytics or logging data. It is also useful for situations where the user has navigated away from the page before the data can be sent, as the data will still be sent in the background.",
  },
  {
    code: "\n\n(function () {\n  if (window.pageXOffset === undefined) {\n    Object.defineProperty(window, 'pageXOffset', {\n      configurable: true,\n      enumerable: true,\n      get: function () {\n        return window.scrollX;\n      },\n    });\n  }\n})();",
    term: "pageXOffset",
    explain:
      "\n\nLine 1: (function () {\n  // This is an IIFE (immediately invoked function expression). It immediately calls the function it defines.\n\nLine 2: if (window.pageXOffset === undefined) {\n  // This line checks if the window.pageXOffset property is undefined.\n\nLine 3: Object.defineProperty(window, 'pageXOffset', {\n  // This line adds a property to the window object with the name pageXOffset.\n\nLine 4: configurable: true,\n  // This sets the configurable property of the pageXOffset property to true.\n\nLine 5: enumerable: true,\n  // This sets the enumerable property of the pageXOffset property to true.\n\nLine 6: get: function () {\n    return window.scrollX;\n  },\n  // This defines a getter function for the pageXOffset property. It returns the value of window.scrollX.\n\nLine 7: });\n  // This closes the object definition.\n\nLine 8: })();\n  // This ends the IIFE and invokes the function.",
    useCase:
      "\n\nPageXOffset is used in Javascript to determine the horizontal coordinate of the current scroll position on the page. This property is particularly useful when creating dynamic web content or animations that must remain in sync with the user's scroll position. It is also used to create smooth scrolling effects when the user scrolls through a page.",
  },
  {
    code: "\n\nfunction pageYOffset() {\n  const doc = document.documentElement \n  return (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0)\n}",
    term: "pageYOffset",
    explain:
      "\n\n//This line creates the function pageYOffset()\n//The function will return the distance from the top of the page that has been scrolled\n\nconst doc = document.documentElement\n\n//This line creates a variable called 'doc' which stores the document element of the page\n\nreturn (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0)\n\n//This line returns the distance from the top of the page that has been scrolled. \n//It checks the pageYOffset of the window and if that doesn't exist, it uses the scrollTop of the document element. \n//It then subtracts the clientTop of the document element from the total if it exists, otherwise it sets it to 0.",
    useCase:
      "\n\nPageYOffset is used in Javascript to retrieve the number of pixels that the document has already been scrolled vertically. This value is useful to detect the current scroll position of an element and to take action accordingly. It is also used to implement custom scrollbars, lazy loading, and other scroll-based effects.",
  },
  {
    code: '\n\n// Polyfill of performance.now()\n(function () {\n  if ("performance" in window == false) {\n    window.performance = {};\n  }\n  \n  Date.now = (Date.now || function () {  // Use pre-existing Date.now if available\n    return new Date().getTime();\n  });\n\n  if ("now" in window.performance == false) {\n    \n    var nowOffset = Date.now();\n    \n    if (window.performance.timing && window.performance.timing.navigationStart) {\n      nowOffset = window.performance.timing.navigationStart\n    }\n    \n    window.performance.now = function now(){\n      return Date.now() - nowOffset;\n    }\n  }\n\n})();',
    term: "performance.now",
    explain:
      "\n\n/*\n1. (function () { \n    // This is an anonymous self-invoking function. It helps create a local scope and prevents polluting the global namespace.\n\n2. if (\"performance\" in window == false) {\n    window.performance = {};\n    // This line checks to see if the 'window.performance' object exists. If it does not exist, we create an empty object.\n\n3. Date.now = (Date.now || function () {  \n    // Use pre-existing Date.now if available\n    return new Date().getTime();\n    // The pre-existing Date.now function is used if available. Otherwise, a new Date object is created and the time is returned in milliseconds.\n\n4. if (\"now\" in window.performance == false) {\n    // This line checks to see if the 'window.performance.now' object exists. If it does not exist, we create a new function.\n\n5. var nowOffset = Date.now();\n    // This line creates a variable 'nowOffset' and assigns the value of the pre-existing Date.now() function.\n\n6. if (window.performance.timing && window.performance.timing.navigationStart) {\n    nowOffset = window.performance.timing.navigationStart\n    // This line checks to see if the 'window.performance.timing.navigationStart' object exists. If it does, the value of the 'nowOffset' variable is set to 'window.performance.timing.navigationStart'\n\n7. window.performance.now = function now(){\n    return Date.now() - nowOffset;\n    // This line creates a new 'window.performance.now' function which returns the value of Date.now() - nowOffset.\n\n8. })();\n    // This is the closing line of the anonymous self-invoking function.\n*/",
    useCase:
      "\n\nPerformance.now() is used in JavaScript to measure the performance of code execution. It provides a high-resolution timestamp in milliseconds, which allows developers to measure the duration of code execution as accurately as possible. This is especially useful for benchmarking code, as it allows developers to track the performance of code over time and identify any issues that may be slowing down its execution.",
  },
  {
    code: "\n\nif (!window.queueMicrotask) {\n    window.queueMicrotask = (function () {\n        var flushing = false;\n        var queue = [];\n        function flushQueue() {\n            while (queue.length) {\n                queue.shift()();\n            }\n            flushing = false;\n        }\n        function queueMicrotask(callback) {\n            queue.push(callback);\n            if (!flushing) {\n                Promise.resolve().then(flushQueue);\n                flushing = true;\n            }\n        }\n        return queueMicrotask;\n    })();\n}",
    term: "queueMicrotask",
    explain:
      '\n\n// Line 1: \n// This line is checking if the global object "window" has a property "queueMicrotask", and if it does not, it will execute the code inside the if statement. \n\n// Line 2: \n// This line is assigning the value of an anonymous function to the property "queueMicrotask" of the global object "window". \n\n// Line 3: \n// This line is declaring a variable named "flushing" with a value of false. \n\n// Line 4: \n// This line is declaring a variable named "queue" with a value of an empty array. \n\n// Line 5: \n// This line is declaring a function named "flushQueue". This function will loop through the array "queue" and execute each item in the array. \n\n// Line 6: \n// This line is inside the "flushQueue" function, and it is looping through the array "queue" and executing each item in the array. \n\n// Line 7: \n// This line is setting the value of the variable "flushing" to false after the "flushQueue" function is done looping through the array. \n\n// Line 8: \n// This line is declaring a function named "queueMicrotask" which takes a callback as an argument. \n\n// Line 9: \n// This line is pushing the callback passed into the "queueMicrotask" function into the array "queue".\n\n// Line 10: \n// This line is checking if the variable "flushing" is false, and if it is, it will execute the code inside the if statement. \n\n// Line 11: \n// This line is using the "Promise.resolve" method to execute the "flushQueue" function. \n\n// Line 12: \n// This line is setting the value of the variable "flushing" to true after the "Promise.resolve" method is called. \n\n// Line 13: \n// This line is returning the "queueMicrotask" function. \n\n// Line 14: \n// This line is the end of the if statement.',
    useCase:
      "\n\nQueueMicrotask is used in Javascript to execute a function asynchronously at the end of the current event loop. It is often used to ensure that certain code runs after all other synchronous code in the same event loop has finished running. For example, it can be used to ensure that a Promise chain is resolved before other code runs, or to ensure that a certain set of operations is completed before other code runs.",
  },
  {
    code: "\n\n(function() {\n  var lastTime = 0;\n  var vendors = ['ms', 'moz', 'webkit', 'o'];\n  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n  }\n  if (!window.requestAnimationFrame)\n    window.requestAnimationFrame = function(callback, element) {\n      var currTime = new Date().getTime();\n      var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n      var id = window.setTimeout(function() {\n        callback(currTime + timeToCall);\n      }, timeToCall);\n      lastTime = currTime + timeToCall;\n      return id;\n    };\n  if (!window.cancelAnimationFrame)\n    window.cancelAnimationFrame = function(id) {\n      clearTimeout(id);\n    };\n}());",
    term: "requestAnimationFrame",
    explain:
      "\n\n// Line 1: This line is starting a self-invoking anonymous function. This means that the code within the function will be executed immediately after the function is defined. \n// Line 2: This line is creating a variable called lastTime and setting it as 0.\n// Line 3: This line is creating an array of strings called vendors which contains the strings 'ms', 'moz', 'webkit', and 'o'.\n// Line 4: This line is starting a for loop which will iterate over the vendors array.\n// Line 5: This line is checking to see if the window.requestAnimationFrame property exists. If it does not exist, the code in the for loop will execute.\n// Line 6: This line is assigning the window.requestAnimationFrame property to the result of the vendors array index combined with the string 'RequestAnimationFrame'.\n// Line 7: This line is assigning the window.cancelAnimationFrame property to the result of the vendors array index combined with the string 'CancelRequestAnimationFrame' or the string 'CancelAnimationFrame'.\n// Line 8: This line is checking to see if the window.requestAnimationFrame property does not exist.\n// Line 9: This line is creating a function called requestAnimationFrame which takes in two parameters, a callback function and an element.\n// Line 10: This line is creating a variable called currTime which is set to the current time in milliseconds.\n// Line 11: This line is creating a variable called timeToCall which is set to the maximum of 0 and 16 minus (currTime minus lastTime).\n// Line 12: This line is creating a variable called id which is set to a setTimeout function which will execute the callback function with the currTime plus timeToCall.\n// Line 13: This line is setting the lastTime variable to the currTime plus timeToCall.\n// Line 14: This line is returning the id variable.\n// Line 15: This line is checking to see if the window.cancelAnimationFrame property does not exist.\n// Line 16: This line is creating a function called cancelAnimationFrame which takes in one parameter, an id.\n// Line 17: This line is executing the clearTimeout function with the id parameter.\n// Line 18: This line is ending the anonymous function.",
    useCase:
      "\n\nRequestAnimationFrame is used in JavaScript to optimize the performance of an animation by minimizing the amount of repainting and reflowing of the page. It allows the browser to determine the optimal time to repaint the page according to the user's hardware and current workload. This helps to ensure that animations appear smooth and perform well, while also saving resources and improving battery life.",
  },
  {
    code: "\n\nif (!window.requestIdleCallback) {\n  window.requestIdleCallback = function (callback, options) {\n    var now = Date.now();\n    var deadline = (options && options.timeout) ? now + options.timeout : now + 50;\n    setTimeout(function () {\n      callback({\n        timeRemaining: function () {\n          return Math.max(0, deadline - Date.now());\n        }\n      });\n    }, 1);\n  };\n}",
    term: "requestIdleCallback",
    explain:
      "\n\n// Line 1: \n// This line checks if the window object has a property called requestIdleCallback. If it does not, the code block below it will be executed. \n\n// Line 2: \n// This line assigns a function to the property requestIdleCallback on the window object.\n\n// Line 3: \n// This line creates a variable called now and assigns it the value of the current time.\n\n// Line 4: \n// This line creates a variable called deadline and assigns it either the value of the option object's timeout property, or the current time plus 50 milliseconds, whichever is greater.\n\n// Line 5: \n// This line sets a timeout for the callback function with a delay of 1 millisecond.\n\n// Line 6-9: \n// This block is the callback function that is passed to the setTimeout. It returns an object with a timeRemaining property that returns the difference between the deadline and the current time.",
    useCase:
      "\n\nRequestIdleCallback is used in Javascript to help developers take advantage of idle time in the main thread. This is beneficial for tasks that do not need to be completed immediately, such as animations, background calculations, garbage collection, etc. RequestIdleCallback allows developers to specify a callback function to be executed when the main thread is idle, ensuring that the user experience is not affected by long-running processes.",
  },
  {
    code: "\n\n// get the current orientation value\nlet orientation = window.screen.orientation;\n\n// declare a new object to store orientation data\nlet screenOrientation = {\n    type: orientation.type\n};\n\n// detect if orientation value is changed\nwindow.addEventListener('orientationchange', function () {\n    // update the orientation value\n    orientation = window.screen.orientation;\n    // update the orientation object\n    screenOrientation.type = orientation.type;\n});\n\n// assign the orientation object to the window object\nwindow.screen.orientation = screenOrientation;",
    term: "screen.orientation",
    explain:
      '\n\n// Line 1: The variable "orientation" is assigned the value of the window.screen.orientation. This value is the current orientation of the device screen. \n// Line 2: A new object named "screenOrientation" is declared with a property of "type", which is set to the current orientation value. \n// Line 3: An event listener is added to the window object to detect when the orientation of the device changes. \n// Line 4: When the orientation of the device changes, the new orientation value is assigned to the "orientation" variable. \n// Line 5: The "type" property of the "screenOrientation" object is updated with the new orientation value. \n// Line 6: The "screenOrientation" object is assigned to the "window.screen.orientation" property. This allows the new orientation value to be accessible for other scripts.',
    useCase:
      "\n\nScreen.orientation is used in Javascript in order to detect the current orientation of the device's screen. This can be used to determine the layout of a page or application based on whether the device is held in portrait or landscape mode. This is useful for providing a better user experience, as it can allow for a more responsive design that is optimized for both orientations.",
  },
  {
    code: "\n\nElement.prototype.scroll = function (x, y) {\n  if (x === undefined) {\n    x = this.scrollLeft;\n  } else {\n    this.scrollLeft = x;\n  }\n\n  if (y === undefined) {\n    y = this.scrollTop;\n  } else {\n    this.scrollTop = y;\n  }\n\n  return {\n    x: x,\n    y: y\n  };\n};",
    term: "scroll",
    explain:
      "\n\n// Element.prototype.scroll()  -  This line creates a scroll() function on the Element prototype. This means that it will be available to all elements in the DOM.\n\n// if (x === undefined)  -  This line checks if the x parameter passed to the scroll() function is undefined.\n\n// x = this.scrollLeft;  -  If the x parameter is undefined, this line sets x to the current scrollLeft value of the element the scroll() function was called on.\n\n// if (y === undefined)  -  This line checks if the y parameter passed to the scroll() function is undefined.\n\n// y = this.scrollTop;  -  If the y parameter is undefined, this line sets y to the current scrollTop value of the element the scroll() function was called on.\n\n// this.scrollLeft = x;  -  This line sets the scrollLeft value of the element the scroll() function was called on to x.\n\n// this.scrollTop = y;  -  This line sets the scrollTop value of the element the scroll() function was called on to y.\n\n// return { x: x, y: y };  -  This line returns an object containing the x and y values that were used to set the scrollLeft and scrollTop values.",
    useCase:
      "\n\nScroll is used in JavaScript to enable a user to scroll through a webpage or application, allowing them to access content that they would not be able to see without the scroll. Scroll is commonly used in applications with large amounts of content, such as a blog or an e-commerce store, where users need to be able to quickly access content without having to manually scroll through the page.",
  },
  {
    code: "\n §§ 1000\n+// polyfill of scrollBy in Javascript\n+\n+if (window.scrollBy) {\n+  (function () {\n+    var scrollBy = window.scrollBy;\n+\n+    window.scrollBy = function (x, y) {\n+      var doc = document.documentElement,\n+          win = document.defaultView;\n+      if (y === undefined) {\n+        scrollBy(0, x);\n+      } else {\n+        scrollBy(x, y);\n+      }\n+      if (doc && doc.scrollTo) {\n+        doc.scrollTo(\n+          win.pageXOffset + x,\n+          win.pageYOffset + y\n+        );\n+      } else if (win && win.scroll) {\n+        win.scroll(\n+          win.pageXOffset + x,\n+          win.pageYOffset + y\n+        );\n+      }\n+    }\n+  })();\n+}\n",
    term: "scrollBy",
    explain:
      '\nLine 1: //polyfill of scrollBy in Javascript\nThis line is a comment and describes what the code will do.\n\nLine 2: if (window.scrollBy) {\nThis line checks if the window object has a "scrollBy" method.\n\nLine 3: (function () {\nThis line creates an anonymous function to encapsulate the code.\n\nLine 4: var scrollBy = window.scrollBy;\nThis line creates a variable called "scrollBy" and assigns it the value of the "scrollBy" method from the window object.\n\nLine 5: window.scrollBy = function (x, y) {\nThis line overwrites the "scrollBy" method of the window object with a new function that takes two parameters (x and y).\n\nLine 6: var doc = document.documentElement,\n\t  win = document.defaultView;\nThis line creates two variables: "doc" and "win" and assigns them the value of the "documentElement" and "defaultView" properties of the document object respectively.\n\nLine 7: if (y === undefined) {\nThis line checks if the parameter "y" is undefined.\n\nLine 8: scrollBy(0, x);\nThis line calls the "scrollBy" method with "0" as the value for "x" and the value of "x" as the value for "y".\n\nLine 9: } else {\nThis line is an else statement that is executed if the parameter "y" is not undefined.\n\nLine 10: scrollBy(x, y);\nThis line calls the "scrollBy" method with the values of both "x" and "y" as parameters.\n\nLine 11: if (doc && doc.scrollTo) {\nThis line checks if the "doc" variable is truthy and if the "scrollTo" property of "doc" is truthy.\n\nLine 12: doc.scrollTo(\nThis line calls the "scrollTo" method of the "doc" variable.\n\nLine 13: win.pageXOffset + x,\nThis line adds the value of "x" to the value of the "pageXOffset" property of the "win" variable.\n\nLine 14: win.pageYOffset + y\nThis line adds the value of "y" to the value of the "pageYOffset" property of the "win" variable.\n\nLine 15: else if (win && win.scroll) {\nThis line checks if the "win" variable is truthy and if the "scroll" property of "win" is truthy.\n\nLine 16: win.scroll(\nThis line calls the "scroll" method of the "win" variable.\n\nLine 17: win.pageXOffset + x,\nThis line adds the value of "x" to the value of the "pageXOffset" property of the "win" variable.\n\nLine 18: win.pageYOffset + y\nThis line adds the value of "y" to the value of the "pageYOffset" property of the "win" variable.',
    useCase:
      "\n\nScrollBy is used in Javascript to scroll the document in the window by a specified number of pixels. This is useful for web pages that have long content, such as articles, and need to be scrolled to be read. It is also helpful for navigation, as it allows the user to quickly scroll to different sections. It can also be used to create smooth scrolling effects, such as when a user clicks a link to jump to a specific part of the page.",
  },
  {
    code: "\n\nfunction scrollIntoView(element) {\n\n  // Get the top position of the element\n  var topPos = element.offsetTop;\n\n  // Calculate the appropriate scroll position\n  var yScrollPos = topPos - window.innerHeight / 2;\n\n  // Scroll the window\n  window.scrollTo(0, yScrollPos);\n\n}",
    term: "scrollIntoView",
    explain:
      "\n\n//This function sets the window scroll position to be centered on the given element.\n\n//1. Declare a function called scrollIntoView that takes a parameter called element\n//This function will take a given element and scroll the window to center that element.\n\n//2. Declare a variable called topPos and set it equal to the offsetTop of the given element\n//This variable stores the position of the element from the top of the page.\n\n//3. Declare a variable called yScrollPos and set it equal to the topPos minus half the window's innerHeight\n//This variable calculates the appropriate scroll position of the window such that the element is centered. \n\n//4. Call the window.scrollTo() method, passing in 0 and the yScrollPos variable as parameters\n//This method sets the scroll position of the window so that the given element is centered in the window.",
    useCase:
      "\n\nScrollIntoView is used in Javascript to ensure that an element within a document is visible to the user. This is often used when the user is trying to find a particular element on a page, but the element is not visible. By using scrollIntoView, the element can be quickly brought into view so that the user can easily find what they are looking for.",
  },
  {
    code: "\n\nif (typeof window.scrollX === 'undefined') {\n  window.scrollX = (() => {\n    if ('scrollingElement' in document) {\n      return document.scrollingElement.scrollLeft;\n    } else if ('documentElement' in document) {\n      return document.documentElement.scrollLeft;\n    } else if ('body' in document) {\n      return document.body.scrollLeft;\n    }\n  })();\n}",
    term: "scrollX",
    explain:
      "\n\n1. if (typeof window.scrollX === 'undefined') { // This statement checks if the property scrollX of window is undefined.\n\n2. window.scrollX = (() => { // This line assigns a function to the scrollX property.\n\n3. if ('scrollingElement' in document) { // This statement checks if the document has a scrollingElement property.\n\n4. return document.scrollingElement.scrollLeft; // If the document has the scrollingElement property, this line will return the scrollLeft of the scrollingElement.\n\n5. } else if ('documentElement' in document) { // This statement checks if the document has a documentElement property.\n\n6. return document.documentElement.scrollLeft; // If the document has the documentElement property, this line will return the scrollLeft of the documentElement.\n\n7. } else if ('body' in document) { // This statement checks if the document has a body property.\n\n8. return document.body.scrollLeft; // If the document has the body property, this line will return the scrollLeft of the body.\n\n9. } // Closing the if else statement.\n\n10. })(); // Closing the function and invoking it.\n\n11. } // Closing the if statement.",
    useCase:
      "\n\nScrollX is used in JavaScript to determine the horizontal scrolling position of an element or the document. It can be used to determine the current position of the horizontal scrollbar, or to set the horizontal scrollbar to a specific position. This can be useful when creating a webpage with a lot of content, as it allows the user to easily scroll through the page without having to manually scroll the page.",
  },
  {
    code: "\n\nfunction scrollYPolyfill() {\n    if (window.scrollY === undefined) {\n        let supportPageOffset = window.pageXOffset !== undefined;\n        let isCSS1Compat = ((document.compatMode || '') === 'CSS1Compat');\n        let y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? document.documentElement.scrollTop : document.body.scrollTop;\n        window.scrollY = y;\n        return y;\n    }\n    return window.scrollY;\n}",
    term: "scrollY",
    explain:
      "\n\n//Function statement\n//This function defines a function called 'scrollYPolyfill'\n\n//First if statement\n//This line checks if the window.scrollY variable is undefined.\n\n//let supportPageOffset = window.pageXOffset !== undefined\n//This line assigns the value of the window.pageXOffset to the variable 'supportPageOffset' and checks if it is not undefined.\n\n//let isCSS1Compat = ((document.compatMode || '') === 'CSS1Compat');\n//This line assigns the value of the document.compatMode to the variable 'isCSS1Compat' and checks if it is equal to 'CSS1Compact'.\n\n//let y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? document.documentElement.scrollTop : document.body.scrollTop\n//This line assigns the value of the window.pageYOffset to the variable 'y' if the variable 'supportPageOffset' is true. Otherwise, it checks if the variable 'isCSS1Compat' is true, and assigns the value of the document.documentElement.scrollTop to the variable 'y'. If it is false, it assigns the value of the document.body.scrollTop to the variable 'y'.\n\n//window.scrollY = y\n//This line assigns the value of the variable 'y' to the window.scrollY variable.\n\n//return y\n//This line returns the value of the variable 'y'.\n\n//Second if statement\n//This line checks if the window.scrollY variable is defined.\n\n//return window.scrollY\n//This line returns the value of the window.scrollY variable.",
    useCase:
      "\n\nScrollY is used in Javascript to get the number of pixels an element has already been scrolled vertically. It can be used to determine how far down the page the user has scrolled, which can be used to modify the page's behavior or display. For example, it can be used to show or hide elements depending on how far down the page the user has scrolled, or to create an infinite scroll effect where new content is loaded as the user scrolls down the page.",
  },
  {
    code: '\n\nfunction setImmediate(fn) {\n\tif (typeof window !== undefined && window.setImmediate) {\n\t\treturn window.setImmediate(fn);\n\t} \n\n\tif (typeof MessageChannel !== "undefined") {\n\t\tconst channel = new MessageChannel();\n\t\tchannel.port1.onmessage = e => fn(e.data);\n\t\treturn channel.port2.postMessage(null);\n\t}\n\n\tif (typeof global !== "undefined" && global.setImmediate) {\n\t\treturn global.setImmediate(fn);\n\t} \n\n\tconst cb = () => fn();\n\tsetTimeout(cb, 0);\n}',
    term: "setImmediate",
    explain:
      "\n\n// Line 1: This line declares a function called setImmediate that takes in a function as an argument. \n// Line 2: This line checks if the type of window is not undefined and if window.setImmediate exists. If both conditions are true, the function fn is returned. \n// Line 3: This line checks if the type of MessageChannel is not undefined. If this condition is true, a new message channel is created and the onmessage event is set to the function fn with the data parameter. \n// Line 4: This line checks if the type of global is not undefined and if global.setImmediate exists. If both conditions are true, the function fn is returned. \n// Line 5: This line declares a callback function which calls the function fn. \n// Line 6: This line sets a timeout for the callback function cb with a delay of 0.",
    useCase:
      "\n\nSetImmediate is used in Javascript to schedule asynchronous callbacks to be executed at a later time, allowing for the execution of code at a specific time without blocking the main thread. It is used to provide a more efficient and optimized way to handle asynchronous operations, allowing for code to be executed as soon as possible while keeping the main thread free from blocking. It is also used to provide a way to handle multiple asynchronous tasks concurrently, allowing for more efficient use of resources.",
  },
  {
    code: "\n\nif (!('scrollBehavior' in document.documentElement.style)) {\n    var scrollElement = document.scrollingElement || document.documentElement;\n    var originalScrollTop = scrollElement.scrollTop;\n\n    window.scroll = function(options) {\n        var scrollTop = originalScrollTop;\n        if (options.top !== undefined) {\n            scrollTop = options.top;\n        } else if (options.left !== undefined) {\n            scrollTop = options.left;\n        }\n\n        scrollElement.scrollTop = scrollTop;\n    }\n}",
    term: "smoothscroll",
    explain:
      "\n\n// Line 1: This line checks to see if the scrollBehavior styling is present in the document element. If not, then the following code will be executed. \n// Line 2: This line declares a variable called scrollElement and sets it equal to the document scrolling element or the document element. \n// Line 3: This line declares a variable called originalScrollTop and sets it equal to the scrollElement's scrollTop. \n// Line 4: This line creates a function called window.scroll which takes in an options parameter. \n// Line 5: This line declares a variable called scrollTop and sets it equal to the originalScrollTop.\n// Line 6: This line checks to see if the top property of the options parameter is defined and if so, sets the scrollTop variable to the top property of the options parameter.\n// Line 7: This line checks to see if the left property of the options parameter is defined and if so, sets the scrollTop variable to the left property of the options parameter. \n// Line 8: This line sets the scrollElement's scrollTop property to the scrollTop variable.",
    useCase:
      "\n\nSmoothscroll is used in Javascript to create a smooth scrolling effect when navigating through a web page. This is done by using the scrollTo() method in the Javascript library, which allows for a smooth scrolling animation. Smoothscroll helps to provide a better user experience when navigating a website, as the scrolling will be more fluid and appear more natural. Additionally, the smooth scrolling effect can be used to create a more visually appealing page and to help draw the users attention to certain elements on the page.",
  },
  {
    code: "\n\n// viewport polyfill\n(function() {\n  // if viewport not supported, create it\n  if (!window.hasOwnProperty('viewport')) {\n    window.viewport = {\n      width: window.innerWidth,\n      height: window.innerHeight\n    };\n  }\n\n  // throttle events\n  var throttle = function(func, limit) {\n    var inThrottle;\n    return function() {\n      var args = arguments;\n      var context = this;\n      if (!inThrottle) {\n        func.apply(context, args);\n        inThrottle = true;\n        setTimeout(function() {\n          inThrottle = false;\n        }, limit);\n      }\n    };\n  };\n\n  // event listener\n  var onResize = function() {\n    window.viewport.width = window.innerWidth;\n    window.viewport.height = window.innerHeight;\n  };\n\n  // bind listener to resize event\n  window.addEventListener('resize', throttle(onResize, 100));\n})();",
    term: "viewport",
    explain:
      '\n\n// 1. This line sets up an immediately invoked function expression (IIFE) to create a scope for the code that follows:\n(function() {\n\n// 2. This line checks whether a viewport object already exists on the window object. If it doesn\'t, then it creates one with the current width and height of the window:\n  if (!window.hasOwnProperty(\'viewport\')) {\n    window.viewport = {\n      width: window.innerWidth,\n      height: window.innerHeight\n    };\n  }\n\n// 3. This line defines a function called "throttle" which will be used to throttle events:\n  var throttle = function(func, limit) {\n\n// 4. This line sets up a variable to keep track whether the function that is passed in is in throttle:\n    var inThrottle;\n\n// 5. This line returns a new function that will be used to check if the function that was passed in is in throttle:\n    return function() {\n\n// 6. These lines set up variables to store the arguments and context of the function that was passed in:\n      var args = arguments;\n      var context = this;\n\n// 7. This line checks if the function that was passed in is not in throttle. If it isn\'t, then the function is applied with the given context and arguments and the inThrottle variable is set to true:\n      if (!inThrottle) {\n        func.apply(context, args);\n        inThrottle = true;\n\n// 8. This line sets up a timeout to set the inThrottle variable to false after the limit has passed:\n        setTimeout(function() {\n          inThrottle = false;\n        }, limit);\n      }\n    };\n  };\n\n// 9. This line defines a function called "onResize" which will update the viewport width and height based on the current window size:\n  var onResize = function() {\n    window.viewport.width = window.innerWidth;\n    window.viewport.height = window.innerHeight;\n  };\n\n// 10. This line binds the "onResize" function to the "resize" event and passes in the "throttle" function with a limit of 100 milliseconds:\n  window.addEventListener(\'resize\', throttle(onResize, 100));\n\n// 11. This line closes the IIFE:\n})();',
    useCase:
      "\n\nViewport is used in Javascript to control the size of the web page on different devices. It helps the website to adjust its layout according to the size of the device. This ensures that the website is displayed properly on different devices and allows the user to have the best experience.",
  },
  {
    code: "\n\n// check if window.scroll is already defined\nif (!window.scroll) {\n  // define window.scroll\n  window.scroll = function(x, y) {\n    // get the current scroll position\n    var scrollX = window.pageXOffset || document.documentElement.scrollLeft;\n    var scrollY = window.pageYOffset || document.documentElement.scrollTop;\n\n    // scroll the page\n    window.scrollTo(scrollX + x, scrollY + y);\n  };\n}",
    term: "window.scroll",
    explain:
      "\n\n// Line 1: This line checks if the window.scroll function has already been defined, and if not, it will move on to the next line.\n\n// Line 2: This line defines the window.scroll function, which takes two arguments (x, y).\n\n// Line 3: This line gets the current scroll position of the page, which is stored in the variables scrollX and scrollY.\n\n// Line 4: This line uses the scrollTo method to scroll the page by the specified amount (x and y).",
    useCase:
      "\n\nWindow.scroll is used in Javascript to enable the user to scroll the contents of a web page. It allows the user to navigate through the page content by scrolling up, down, left, and right. This is especially useful for webpages with a lot of content, as it allows the user to quickly and easily access the desired content.",
  },
  {
    code: "\n\n//polyfill for window.scrollBy\nif (!window.scrollBy) {\n  window.scrollBy = function(x, y) {\n    window.scrollTo(window.pageXOffset + x, window.pageYOffset + y);\n  }\n}",
    term: "window.scrollBy",
    explain:
      "\n\n//This line checks to see if the window.scrollBy method exists in the current environment\nif (!window.scrollBy) {\n\n//This line defines a function to simulate the window.scrollBy method\n  window.scrollBy = function(x, y) {\n\n//This line calls the window.scrollTo method, passing in the existing pageXOffset and pageYOffset values plus the x and y values passed in to the window.scrollBy function.\n    window.scrollTo(window.pageXOffset + x, window.pageYOffset + y);\n  }\n}",
    useCase:
      "\n\nWindow.scrollBy is used in JavaScript to allow users to scroll a web page, either vertically or horizontally. It can be used to scroll by a specified number of pixels or by a percentage of the window size, allowing the user to quickly and easily move around a page. It's a useful tool for allowing users to quickly access different parts of a web page without having to manually scroll.",
  },
  {
    code: "\n\nif (!('viewport' in document.documentElement)) {\n    Object.defineProperty(document.documentElement, \"viewport\", {\n        get: function() {\n            var viewportWidth;\n            if (document.compatMode === 'BackCompat') {\n                viewportWidth = document.body.clientWidth;\n            } else {\n                viewportWidth = document.documentElement.clientWidth;\n            }\n            return viewportWidth;\n        }\n    });\n}",
    term: "~viewport",
    explain:
      '\n\n// Line 1:\n// This line checks if the \'viewport\' property exists in the document.documentElement object. If it doesn\'t, the code inside the if statement will be executed. \n\n// Line 2:\n// This line creates a new property in the document.documentElement object called "viewport".\n\n// Line 3:\n// This line defines the getter function for the "viewport" property. The function will be called whenever the "viewport" property is accessed.\n\n// Line 4:\n// This line creates a variable called "viewportWidth" and assigns it a value based on the document\'s "compatMode" property. If the "compatMode" property is "BackCompat", the "viewportWidth" variable will be set to the "body.clientWidth". Otherwise, it will be set to the "documentElement.clientWidth".\n\n// Line 5:\n// This line returns the value of the "viewportWidth" variable.\n\n// Line 6:\n// This line closes the if statement.',
    useCase:
      "\n\nViewport is used in JavaScript to control the area of the webpage that is visible to the user. It is used to set the width and height of the webpage, as well as the initial scale of the page when it is first loaded. This is especially important for mobile devices, as it ensures that the page is displayed correctly regardless of the device’s size.",
  },
];
